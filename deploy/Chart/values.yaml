global:
  # Configure global.imageRegistry to use a custom container registry for all Radius images.
  # When empty (default), images will use ghcr.io/radius-project as the registry.
  # Example: global.imageRegistry=myregistry.azurecr.io
  imageRegistry: ""

  # Configure global.imageTag to use a specific tag for all Radius images.
  # When empty (default), images will use the tag derived from Chart AppVersion.
  # Example: global.imageTag=0.48
  imageTag: ""

  # Configure global.imagePullSecrets for pulling images from private registries.
  # Secrets must be manually created in the namespace.
  # Example:
  # imagePullSecrets:
  #   - name: myregistrykey
  imagePullSecrets: []

  # Configure global.rootCA.cert to use the intermediate CA cert in Radius containers.
  # Otherwise, Radius containers use the default root CA provided by base OS image.
  rootCA:
    cert: ""
    secretName: "root-ca-cert"
    volumeName: "root-ca-vol"
    mountPath: "/tmp/sslcerts"
    # SSL_CERT_DIR is used to override the default root CA location.
    # Dotnet runtime and Go use this environment variable to load the root CA.
    sslCertDirEnvVar: "SSL_CERT_DIR"

  appendRootCA:
    # Auto-enabled when global.rootCA.cert is provided via --set-file
    # Init image to normalize and prepare certs directory
    initImage: "alpine:3.23"
    # Working and target mount paths
    workDir: "/work/certs"
    targetMountPath: "/etc/ssl/certs"

  prometheus:
    enabled: true
    path: "/metrics"
    port: 9090
  #
  # Configure global.zipkin.url to enable distributed trace. Replace the example url
  # below with the environment specific url
  # zipkin:
  #   url: "http://jaeger-collector.radius-monitoring.svc.cluster.local:9411/api/v2/spans"
  #

  # Configure global.azureWorkloadIdentity.enabled=true to enable Azure Workload Identity.
  # Disabled by default.
  azureWorkloadIdentity:
    enabled: false

  # Configure global.aws.irsa.enabled=true to enable AWS IRSA.
  # Disabled by default.
  aws:
    irsa:
      enabled: false

  # Configure terraform binary source for pre-downloading terraform binaries
  # This avoids downloading terraform on each recipe execution
  terraform:
    # Enable terraform binary pre-downloading during pod startup
    enabled: true
    # URL for downloading Terraform binary
    # Leave empty to automatically fetch the latest version from HashiCorp
    # Or provide a complete direct download URL for custom sources
    downloadUrl: ""
    # Configure Terraform log level for terraform-exec execution
    # Valid values: TRACE, DEBUG, INFO, WARN, ERROR, OFF
    # Default: ERROR
    loglevel: "ERROR"
    # Storage size for shared terraform PVC (used by UCP installer and recipe execution)
    # This PVC stores installed Terraform versions managed via `rad terraform install`
    storageSize: "1Gi"
    # Storage class name for the terraform PVC
    # Leave empty to use the default storage class
    # For ReadWriteMany access, use a storage class that supports it (e.g., NFS, EFS, Azure Files)
    storageClassName: ""

controller:
  image: controller
  # Default tag uses Chart AppVersion.
  # tag: latest
  resources:
    requests:
      memory: "60Mi"
    limits:
      memory: "300Mi"

de:
  image: deployment-engine
  # Default tag uses Chart AppVersion.
  # tag: latest
  resources:
    requests:
      # request memory is the average memory usage + 10% buffer.
      memory: "130Mi"
    limits:
      memory: "300Mi"

ucp:
  image: ucpd
  # Default tag uses Chart AppVersion.
  # tag: latest
  resources:
    requests:
      # request memory is the average memory usage + 10% buffer.
      memory: "60Mi"
    limits:
      memory: "300Mi"

dynamicrp:
  image: dynamic-rp
  # Default tag uses Chart AppVersion.
  # tag: latest
  resources:
    requests:
      # request memory is the average memory usage + 10% buffer.
      memory: "160Mi"
    limits:
      # limit is higher for dynamic-rp because the Terraform execution
      # can spike memory usage.
      memory: "500Mi"
  bicep:
    deleteRetryCount: 20
    deleteRetryDelaySeconds: 60
  terraform:
    path: "/terraform"

rp:
  image: applications-rp
  # Default tag uses Chart AppVersion.
  # tag: latest
  publicEndpointOverride: ""
  resources:
    requests:
      # request memory is the average memory usage + 10% buffer.
      memory: "160Mi"
    limits:
      # limit is higher for applications-rp because the Terraform execution
      # can spike memory usage.
      memory: "500Mi"
  bicep:
    deleteRetryCount: 20
    deleteRetryDelaySeconds: 60
  terraform:
    path: "/terraform"

dashboard:
  enabled: true
  containerPort: 7007
  image: dashboard
  # Default tag uses Chart AppVersion.
  # tag: latest
  resources:
    requests:
      memory: "60Mi"
    limits:
      memory: "300Mi"

database:
  enabled: false # Enable the Postgres database install
  postgres_user: "radius"
  image: mirror/postgres
  tag: latest
  storageClassName: "" # set to the storage class name if required, the empty string will pickup the default storage class.
  # Minimum resource requirements, may need to revisit and scale.
  storageSize: "1Gi"
  resources:
    requests:
      cpu: "2"
      memory: "512Mi"
    limits:
      cpu: "2"
      memory: "1024Mi"

bicep:
  image: bicep
  # Default tag uses Chart AppVersion.
  # tag: latest

preupgrade:
  # Enable pre-upgrade preflight checks
  enabled: false
  # Container image for pre-upgrade checks
  # Can be overridden with a full registry path (e.g., myregistry.azurecr.io/pre-upgrade)
  # or use just the image name to use global.imageRegistry
  image: pre-upgrade
  # Image tag override. If not set, uses global.imageTag or Chart AppVersion
  # tag: latest
  # Target version for upgrade validation. If not set, uses Chart AppVersion
  # targetVersion: 0.49.0
  # Individual preflight checks configuration
  # All checks are optional and can be enabled/disabled independently
  # For production upgrades, recommended: version=true, helm=true, installation=true, kubernetes=true
  checks:
    # Version compatibility check - validates upgrade path compatibility (RECOMMENDED)
    version: true
    # Helm connectivity check - validates Helm can connect to cluster (RECOMMENDED)
    helm: true
    # Installation check - validates Radius is properly installed (RECOMMENDED)
    installation: true
    # Kubernetes connectivity check - validates cluster connectivity and permissions (RECOMMENDED)
    kubernetes: true
    # Resource availability check - checks if cluster has sufficient resources (OPTIONAL - warning only)
    resources: false
  # Timeout for preflight checks in seconds (default: 60)
  timeoutSeconds: 60
  # Log level for preflight checks (DEBUG, INFO, WARN, ERROR)
  logLevel: INFO
  # Log profile (production for JSON logs, development for human-readable)
  logProfile: production
  # Retry configuration for handling transient failures
  retryAttempts: 1 # Number of attempts (1 = no retries)
  retryDelaySeconds: 2 # Delay between retry attempts
  # Job configuration
  ttlSecondsAfterFinished: 300
  # Resource requirements
  resources:
    requests:
      cpu: "100m"
      memory: "64Mi"
    limits:
      cpu: "200m"
      memory: "128Mi"
  # Security context for the container
  securityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 65532
    runAsGroup: 65532
    seccompProfile:
      type: RuntimeDefault
  # Pod security context
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 65532
    runAsGroup: 65532
    fsGroup: 65532

# Encryption key rotation configuration
# Enables automatic rotation of encryption keys used for securing sensitive data
encryption:
  rotation:
    # Enable automatic key rotation via CronJob
    enabled: true
    
    # Cron schedule for key rotation
    # Format: minute hour day month weekday
    # Note: Cron day-of-month only supports 1-31, cannot use */90
    # Examples:
    #   "0 0 1 */3 *"  - Every 3 months on the 1st at midnight (~90 days, default)
    #   "0 0 1 1,4,7,10 *" - Every quarter (Jan, Apr, Jul, Oct) at midnight
    #   "0 2 1 */2 *"  - Every 2 months on the 1st at 2 AM
    #   "*/2 * * * *"  - Every 2 minutes (for testing only)
    schedule: "0 0 1 */3 *"
    
    # Number of days a key remains valid for encryption (default: 90 days)
    # After this period, a new key version is generated
    intervalDays: 90
    
    # Grace period in days for keeping old keys after expiration (default: 1 day)
    # During this period, old encrypted data can still be decrypted
    # Keys are removed after: expiresAt + gracePeriodDays
    gracePeriodDays: 1
