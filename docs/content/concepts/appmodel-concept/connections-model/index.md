---
type: docs
title: "Radius Connections concept"
linkTitle: "Connections"
description: "Learn how to model resource interactions and relationships with Radius Connections."
weight: 400
---

Once you define your Application and the Components inside of it, you can define the Connections between them. Connections are defined as:

{{% alert title="ðŸ“„ Connections" color="primary" %}}
A **logical** unit of communication between Components.
{{% /alert %}}

The use cases for Connections are flexible, and include features like: 

- Configuring role based access control (RBAC) between Components.
- Passing resource information like connection strings, credentials, etc. between Components.
- Configuring security policies between Components and runtimes like Dapr.

{{% alert title="ðŸ’¡ Key concept" color="info" %}}
A Connection dependency between Components *may* affect the deployment order of Components depending on the kind. (*eg. a database will be deployed and connection string generated before a container is deployed and the value passed in*)
{{% /alert %}} 

## Injected values

Declaring a connection between two components also injects information in the form of environment variables based on the name of the connection and its kind. This is a form of *cloud-native service discovery* and makes it easy for you to decouple your application code from the environment where its deployed.

These environment variables follow a naming convention that makes their use predictable. The naming pattern includes the connection name, which is part of the consuming component. This way the code that needs to read the values gets to define how they are named.

{{% alert title="ðŸ’¡ Key concept" color="info" %}}
Each kind of connection defines values that are useful for communication. These could be URIs, connection strings, access keys, or anything that application code needs to successfully communicate.
{{% /alert %}} 

The names and semantic meaning of the values available are defined by the connection kind. The [Resource Library]({{< ref resources >}}) documentation contains a reference to the mapping between connection kinds and variables. 

The values provided through connections are a convenience and are also available as properties and functions (for secrets) when authoring your `.bicep` files. You can ignore the values generated by a connection if you prefer to be explicit, or you if your already have a convention you like to follow. 

{{% alert title="ðŸš§ Under construction" color="info" %}}
In the future we plan to make the conventions used for connections configurable. Stay tuned for updates.
{{% /alert %}}

#### Bicep example

In the following example, a `frontend` service connects to a backend service via an `HttpRoute`. The connection is defined as part of `frontend` and is named `orders`.

{{< rad file="snippets/injected-values.bicep" embed=true marker="//SAMPLE" replace-key-container="//CONTAINER" replace-value-container="container: {...}" >}}

This example would define the following environment variables for use inside `frontend`:

| Environment Variable       | Example Value                             | Description                                                                               |
| -------------------------- | ----------------------------------------- | ----------------------------------------------------------------------------------------- |
| `CONNECTION_ORDERS_HOST`   | `orders.default.svc.cluster.local`        | A hostname that can be used to route traffic to the `HttpRoute`'s destination.            |
| `CONNECTION_ORDERS_PORT`   | `80`                                      | The listening port of the `HttpRoute`.                                                    |
| `CONNECTION_ORDERS_SCHEME` | `http`                                    | The protocol of the `HttpRoute`.                                                          |
| `CONNECTION_ORDERS_URL`    | `http://orders.default.svc.cluster.local` | A fully-qualified URL that can be used to route traffic to the `HttpRoute`'s destination. |


## Types of Connections

Connections come in three forms:

- **Direct** to non-runnable Components
- Through **routes** to runnable Components
- To **platform-specific resources** without a Component

### Direct

When a runnable Component needs to interact with a non-runnable Component, it can be done by directly connecting to it. For example, a shopping basket service might need to connect to an inventory store database to read and write to it.

Each [Connection kind]({{< ref resources >}}) defines the RBAC roles, environment variables, secrets, and other configuration that are mapped into the runnable component automatically.

#### Bicep example

{{< rad file="snippets/direct.bicep" embed=true marker="//SAMPLE" replace-key-container="//CONTAINER" replace-value-container="container: {...}" replace-key-properties="//PROPERTIES" replace-value-properties="properties: {...}" >}}

### Routes

Runnable components are also able talk to interact with eachother, even when cycles exist, via Routes. For example, the `HttpRoute` allows runnable Components to provide and consume HTTP endpoints.

#### Bicep example

In the following example, a frontend service connects to a backend service via an `HttpRoute`. Backend defines a port and provides the Route, and frontend defines a connection to the Route.

{{< rad file="snippets/route.bicep" embed=true marker="//SAMPLE" replace-key-container="//CONTAINER" replace-value-container="container: {...}" >}}

### Platform-specific resources

Often, platforms will have resources that are not portable across Radius platforms. For example, your application may use an Azure storage account, or specific features of Azure CosmosDB that cannot be abstracted with MongoDB. In this case, runnable Components can define a connection directly to the platform resource in Bicep.

{{% alert title="ðŸš§ Under construction" color="info" %}}
Connecting directly to platform resources in Bicep is still in design/development. Stay tuned for updates.
{{% /alert %}}

## Next step

Now that you are familiar with Radius Connections, the next step is to learn about Radius Traits.

{{< button text="Learn about Traits" page="traits-model.md" >}}
