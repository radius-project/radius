# GitHub Copilot Instructions for Radius CLI Development

This file provides instructions for GitHub Copilot when working with the Radius CLI codebase.

## Environment Detection

Always check the user's environment before suggesting terminal commands:
- If environment shows `"powershell.exe"`: Use PowerShell syntax (`.\main.exe`, `Remove-Item`, `Get-ChildItem`)
- If environment shows bash/zsh: Use Unix syntax (`./main.exe`, `rm`, `ls`)
- When suggesting `run_in_terminal` commands, match the detected shell environment

## CLI Command Patterns

When creating new CLI commands for Radius:

### Runner Pattern
```go
type Runner struct {
    ConfigHolder        *framework.ConfigHolder
    Output              output.Interface
    HelmInterface       helm.Interface
    KubernetesInterface kubernetes.Interface
    Workspace           *workspaces.Workspace
    
    // Store command flags here during Validate
    FlagName string
}

func (r *Runner) Validate(cmd *cobra.Command, args []string) error {
    // Get workspace using this pattern
    workspace, err := cli.RequireWorkspace(cmd, r.ConfigHolder.Config, r.ConfigHolder.DirectoryConfig)
    if err != nil {
        return err
    }
    r.Workspace = workspace
    
    // Parse and store flags here
    r.FlagName, err = cmd.Flags().GetString("flag-name")
    
    return nil
}

func (r *Runner) Run(ctx context.Context) error {
    // Use stored flags from Validate, don't try to access cmd here
    // Use r.Workspace for workspace operations
    return nil
}
```

### Workspace Validation
```go
// Check connection type
if workspace.Connection["kind"] != workspaces.KindKubernetes {
    return fmt.Errorf("workspace must be connected to a Kubernetes cluster")
}

// Get Kubernetes context
kubeContext, ok := r.Workspace.KubernetesContext()
if !ok {
    return fmt.Errorf("no kubernetes context found")
}
```

### Required Imports for CLI Commands
```go
import (
    "github.com/radius-project/radius/pkg/cli"
    "github.com/radius-project/radius/pkg/cli/framework"
    "github.com/radius-project/radius/pkg/cli/kubernetes"
    "github.com/radius-project/radius/pkg/cli/workspaces"
    "github.com/radius-project/radius/pkg/cli/helm"
    "github.com/radius-project/radius/pkg/cli/output"
)
```

## Helm Operations

### Check Radius Installation
```go
installState, err := r.HelmInterface.CheckRadiusInstall(kubeContext)
if !installState.RadiusInstalled {
    return fmt.Errorf("Radius not installed")
}
```

### Upgrade Radius with Custom Values
```go
clusterOptions := helm.ClusterOptions{
    Radius: helm.RadiusChartOptions{
        ChartOptions: helm.ChartOptions{
            Namespace:   namespace,
            ReleaseName: releaseName,
            SetArgs:     []string{"key=value", "another=value"},
            Wait:        true,
        },
    },
}
err := r.HelmInterface.UpgradeRadius(ctx, clusterOptions, kubeContext)
```

## Secret and Resource Validation

### Check Kubernetes Secrets
```go
exists, err := r.KubernetesInterface.CheckSecretExists(ctx, secretName, namespace)
if err != nil {
    return fmt.Errorf("failed to check secret: %w", err)
}
if !exists {
    return fmt.Errorf("secret %s/%s not found", namespace, secretName)
}
```

### Deduplication Pattern
When handling lists that may contain duplicates:
```go
seen := make(map[string]bool)
var unique []string
for _, item := range items {
    key := generateUniqueKey(item)
    if !seen[key] {
        seen[key] = true
        unique = append(unique, item)
    }
}
```

## Testing Patterns

### CLI Command Tests
```go
func TestCommand(t *testing.T) {
    // Use radcli.SharedValidateValidation pattern
    require := require.New(t)
    
    // Create mocks
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    
    mockFactory := framework.NewMockFactory(ctrl)
    // Setup expectations - only mock methods that exist in interfaces
}
```

### Mock Usage
- Check generated mock files for available methods before using
- Don't mock methods that don't exist in the actual interface
- Use `gomock.Any()` for parameters when exact values don't matter

## Command Registration

### In initSubCommands() function
```go
func initSubCommands() {
    framework := &framework.Impl{
        // ... framework setup
    }
    
    // For commands needing framework
    myCmd, _ := mypackage.NewCommand(framework)
    RootCmd.AddCommand(myCmd)
}
```

### Command Factory Pattern
```go
func NewCommand(factory framework.Factory) (*cobra.Command, framework.Runner) {
    runner := NewRunner(factory)
    cmd := &cobra.Command{
        Use:   "command-name",
        Short: "Short description",
        RunE:  framework.RunCommand(runner),
    }
    return cmd, runner
}
```

## Error Handling and Logging

### Consistent Error Messages
```go
return fmt.Errorf("failed to operation: %w", err)  // Wrap errors
r.Output.LogInfo("âœ… Success message")             // Success
r.Output.LogInfo("Informational message")          // Info
```

### Resource Not Found Pattern
```go
if !found {
    return fmt.Errorf("%s not found in namespace %s. Please ensure %s is installed", resourceType, namespace, resourceType)
}
```

## File Naming and Organization

- CLI commands: `pkg/cli/cmd/commandgroup/subcommand/`
- Tests: Same directory with `_test.go` suffix
- Mocks: Same directory, generated with `//go:generate` comments
- Interfaces: Check existing interfaces before creating new ones

## Common Gotchas

- Never try to access `cmd` parameter in `Run()` method - store flags in `Validate()`
- Import paths matter - check existing similar commands for correct imports
- Interface method names are exact - check actual interface definitions
- Helm operations use specific option structs - follow existing patterns
- Always handle the case where workspace connection is not Kubernetes
