# GitHub Copilot Instructions for Radius CLI Development

This file provides instructions for GitHub Copilot when working with the Radius CLI codebase.

## Copilot Functions

### rebase-upstream
Fetches upstream/main and rebases the current branch on it.

```typescript
function rebase_upstream(): void {
  // Fetch the latest changes from upstream
  git fetch upstream
  
  // Rebase current branch on upstream/main
  git rebase upstream/main
}
```

### review-pr
Sets up a PR review environment and returns key information for Copilot analysis.

```typescript
function review_pr(pr_number: string): string {
  // Create a worktree for the PR review
  git worktree add ../pr-${pr_number} HEAD
  
  // Fetch the PR branch
  git fetch upstream pull/${pr_number}/head:pr-${pr_number}
  
  // Switch to the PR worktree and checkout the PR branch
  cd ../pr-${pr_number}
  git checkout pr-${pr_number}
  
  // Get PR information for analysis
  const prInfo = {
    number: pr_number,
    changedFiles: git diff --name-only upstream/main...pr-${pr_number},
    diffStat: git diff --stat upstream/main...pr-${pr_number},
    commitMessages: git log --oneline upstream/main..pr-${pr_number}
  };
  
  
  // Return structured information for Copilot to analyze
  return `PR #${pr_number} Analysis:
  
Files Changed: ${prInfo.changedFiles}
Diff Statistics: ${prInfo.diffStat}
Commits: ${prInfo.commitMessages}

The PR is now checked out in ../pr-${pr_number} for detailed review.
Ask me to analyze specific files or provide a code review summary.`;
}
```

### cleanup-pr-review
Returns to the main radius directory and cleans up PR review worktree.

```typescript
function cleanup_pr_review(pr_number: string): string {
  // Ensure we're in the main radius directory
  cd ../radius
  
  // Remove the PR worktree
  git worktree remove ../pr-${pr_number} --force
  
  // Delete the local PR branch
  git branch -D pr-${pr_number}
  
  return `Cleaned up PR #${pr_number} review:
- Removed worktree ../pr-${pr_number}
- Deleted local branch pr-${pr_number}
- Returned to main radius repository`;
}
```

### Using Copilot Functions for Code Review

**Workflow:**
1. **Setup**: `@workspace /review-pr 1234` - Sets up PR environment
2. **Review**: Ask Copilot to analyze the PR:
   - "Analyze the Go files changed in this PR for potential issues"
   - "Check if the PR follows the Radius CLI patterns documented here"
   - "Review the test coverage for the new functionality"
   - "Summarize the key changes and their impact"
   - "Check for any security concerns in the changed code"
3. **Cleanup**: `@workspace /cleanup-pr-review 1234` - Clean up when done

The function sets up the environment, then Copilot can access and analyze the checked-out PR code.

## Environment Detection

Always check the user's environment before suggesting terminal commands:
- If environment shows `"powershell.exe"`: Use PowerShell syntax (`.\main.exe`, `Remove-Item`, `Get-ChildItem`)
- If environment shows bash/zsh: Use Unix syntax (`./main.exe`, `rm`, `ls`)
- When suggesting `run_in_terminal` commands, match the detected shell environment

## CLI Command Patterns

When creating new CLI commands for Radius:

### Runner Pattern
```go
type Runner struct {
    ConfigHolder        *framework.ConfigHolder
    Output              output.Interface
    HelmInterface       helm.Interface
    KubernetesInterface kubernetes.Interface
    Workspace           *workspaces.Workspace
    
    // Store command flags here during Validate
    FlagName string
}

func (r *Runner) Validate(cmd *cobra.Command, args []string) error {
    // Get workspace using this pattern
    workspace, err := cli.RequireWorkspace(cmd, r.ConfigHolder.Config, r.ConfigHolder.DirectoryConfig)
    if err != nil {
        return err
    }
    r.Workspace = workspace
    
    // Parse and store flags here
    r.FlagName, err = cmd.Flags().GetString("flag-name")
    
    return nil
}

func (r *Runner) Run(ctx context.Context) error {
    // Use stored flags from Validate, don't try to access cmd here
    // Use r.Workspace for workspace operations
    return nil
}
```

### Workspace Validation
```go
// Check connection type
if workspace.Connection["kind"] != workspaces.KindKubernetes {
    return fmt.Errorf("workspace must be connected to a Kubernetes cluster")
}

// Get Kubernetes context
kubeContext, ok := r.Workspace.KubernetesContext()
if !ok {
    return fmt.Errorf("no kubernetes context found")
}
```

### Required Imports for CLI Commands
```go
import (
    "github.com/radius-project/radius/pkg/cli"
    "github.com/radius-project/radius/pkg/cli/framework"
    "github.com/radius-project/radius/pkg/cli/kubernetes"
    "github.com/radius-project/radius/pkg/cli/workspaces"
    "github.com/radius-project/radius/pkg/cli/helm"
    "github.com/radius-project/radius/pkg/cli/output"
)
```

## Helm Operations

### Check Radius Installation
```go
installState, err := r.HelmInterface.CheckRadiusInstall(kubeContext)
if !installState.RadiusInstalled {
    return fmt.Errorf("Radius not installed")
}
```

### Upgrade Radius with Custom Values
```go
clusterOptions := helm.ClusterOptions{
    Radius: helm.RadiusChartOptions{
        ChartOptions: helm.ChartOptions{
            Namespace:   namespace,
            ReleaseName: releaseName,
            SetArgs:     []string{"key=value", "another=value"},
            Wait:        true,
        },
    },
}
err := r.HelmInterface.UpgradeRadius(ctx, clusterOptions, kubeContext)
```

## Secret and Resource Validation

### Check Kubernetes Secrets
```go
exists, err := r.KubernetesInterface.CheckSecretExists(ctx, secretName, namespace)
if err != nil {
    return fmt.Errorf("failed to check secret: %w", err)
}
if !exists {
    return fmt.Errorf("secret %s/%s not found", namespace, secretName)
}
```

### Deduplication Pattern
When handling lists that may contain duplicates:
```go
seen := make(map[string]bool)
var unique []string
for _, item := range items {
    key := generateUniqueKey(item)
    if !seen[key] {
        seen[key] = true
        unique = append(unique, item)
    }
}
```

## Testing Patterns

### CLI Command Tests
```go
func TestCommand(t *testing.T) {
    // Use radcli.SharedValidateValidation pattern
    require := require.New(t)
    
    // Create mocks
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()
    
    mockFactory := framework.NewMockFactory(ctrl)
    // Setup expectations - only mock methods that exist in interfaces
}
```

### Mock Usage
- Check generated mock files for available methods before using
- Don't mock methods that don't exist in the actual interface
- Use `gomock.Any()` for parameters when exact values don't matter

## Command Registration

### In initSubCommands() function
```go
func initSubCommands() {
    framework := &framework.Impl{
        // ... framework setup
    }
    
    // For commands needing framework
    myCmd, _ := mypackage.NewCommand(framework)
    RootCmd.AddCommand(myCmd)
}
```

### Command Factory Pattern
```go
func NewCommand(factory framework.Factory) (*cobra.Command, framework.Runner) {
    runner := NewRunner(factory)
    cmd := &cobra.Command{
        Use:   "command-name",
        Short: "Short description",
        RunE:  framework.RunCommand(runner),
    }
    return cmd, runner
}
```

## Error Handling and Logging

### Consistent Error Messages
```go
return fmt.Errorf("failed to operation: %w", err)  // Wrap errors
r.Output.LogInfo("âœ… Success message")             // Success
r.Output.LogInfo("Informational message")          // Info
```

### Resource Not Found Pattern
```go
if !found {
    return fmt.Errorf("%s not found in namespace %s. Please ensure %s is installed", resourceType, namespace, resourceType)
}
```

## File Naming and Organization

- CLI commands: `pkg/cli/cmd/commandgroup/subcommand/`
- Tests: Same directory with `_test.go` suffix
- Mocks: Same directory, generated with `//go:generate` comments
- Interfaces: Check existing interfaces before creating new ones

## Common Gotchas

- Never try to access `cmd` parameter in `Run()` method - store flags in `Validate()`
- Import paths matter - check existing similar commands for correct imports
- Interface method names are exact - check actual interface definitions
- Helm operations use specific option structs - follow existing patterns
- Always handle the case where workspace connection is not Kubernetes
