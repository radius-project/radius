# ------------------------------------------------------------
# Copyright 2023 The Radius Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#    
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ------------------------------------------------------------


name: E2E test on Azure
on:
  schedule:
    # Run every 4 hours on weekdays.
    - cron: "30 0,4,8,12,16,20 * * 0-6"
  pull_request:
    branches:
      - main
  # Dispatch on external events
  repository_dispatch:
    types: [e2e-tests]

env:
  # Go version
  GOVER: '^1.20'
  GOPROXY: https://proxy.golang.org

  # gotestsum version - see: https://github.com/gotestyourself/gotestsum
  GOTESTSUM_VER: 1.10.0

  # ACR for storing test images
  CACHE_REGISTRY: radiusdev.azurecr.io
  # The radius functional test timeout
  FUNCTIONALTEST_TIMEOUT: 60m
  # The Azure Location to store test resources
  AZURE_LOCATION: westus3
  # The base directory for storing test logs
  RADIUS_CONTAINER_LOG_BASE: dist/container_logs
  # The Radius helm chart location.
  RADIUS_CHART_LOCATION: deploy/Chart/
  # The region for AWS resources
  AWS_REGION: 'us-west-2'
  # The AWS account ID
  AWS_ACCOUNT_ID: '${{ secrets.FUNCTEST_AWS_ACCOUNT_ID }}'

  AKS_CLUSTER_NAME: 'radiuse2e00-aks'
  AKS_RESOURCE_GROUP: 'radiuse2e00'

jobs:
  build:
    name: Build Radius for test
    runs-on: [ self-hosted, 1ES.Pool=1ES-Radius ]
    outputs:
      SKIP_BUILD: ${{ steps.skip-build.outputs.SKIP_BUILD }}
      REL_VERSION: ${{ steps.gen-id.outputs.REL_VERSION }}
      UNIQUE_ID: ${{ steps.gen-id.outputs.UNIQUE_ID }}
      PR_NUMBER: ${{ steps.gen-id.outputs.PR_NUMBER }}
      CHECKOUT_REPO: ${{ steps.gen-id.outputs.CHECKOUT_REPO }}
      CHECKOUT_REF: ${{ steps.gen-id.outputs.CHECKOUT_REF }}
      RAD_CLI_ARTIFACT_NAME: ${{ steps.gen-id.outputs.RAD_CLI_ARTIFACT_NAME }}
    steps:
      - name: Restore the latest cached binaries
        uses: actions/cache/restore@v3
        with:
          path: ./dist/cache
          key: radius-test-latest-
      - name: Skip build if build is still valid
        id: skip-build
        run: |
          # check if the last build time to see if we need to build again
          if [ -f ./dist/cache/.lastbuildtime ]; then
            lastbuild=$(cat ./dist/cache/.lastbuildtime)
            current_time=$(date +%s)
            if [ $((current_time-lastbuild)) -lt 43200 ]; then
              echo "Skipping build as the last build is still valid."
              echo "SKIP_BUILD=true" >> $GITHUB_OUTPUT
            fi
          fi
      - name: Set up checkout target (scheduled)
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' && github.event_name == 'schedule'
        run: |
          echo "CHECKOUT_REPO=${{ github.repository }}" >> $GITHUB_ENV
          echo "CHECKOUT_REF=refs/heads/main" >> $GITHUB_ENV
      - name: Set up checkout target (pull_request)
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' && github.event_name == 'pull_request'
        run: |
            echo "CHECKOUT_REPO=${{ github.event.pull_request.head.repo.full_name }}" >> $GITHUB_ENV
            echo "CHECKOUT_REF=${{ github.event.pull_request.head.sha }}" >> $GITHUB_ENV
            echo "PR_NUMBER=${{ github.event.pull_request.number }}" >> $GITHUB_ENV
      - name: Set up checkout target (repository_dispatch)
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' && github.event_name == 'repository_dispatch'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GH_RAD_CI_BOT_PAT }}
          script: |
            const testPayload = context.payload.client_payload;
            if (testPayload && testPayload.command === `ok-to-test`) {
              var fs = require('fs');
              // Set environment variables
              fs.appendFileSync(process.env.GITHUB_ENV,
                `CHECKOUT_REPO=${testPayload.pull_head_repo}\n`+
                `CHECKOUT_REF=${testPayload.pull_head_ref}\n`+
                `PR_NUMBER=${testPayload.issue.number}`
              );
            }
      - name: Generate ID for release
        id: gen-id
        run: |
          if [ -z "${{ steps.skip-build.outputs.SKIP_BUILD }}" ]; then
            BASE_STR="RADIUS|${GITHUB_SHA}|${GITHUB_SERVER_URL}|${GITHUB_REPOSITORY}|${GITHUB_RUN_ID}|${GITHUB_RUN_ATTEMPT}"
            UNIQUE_ID=$(echo $BASE_STR | sha1sum | head -c 10)
            echo "REL_VERSION=pr-${UNIQUE_ID}" >> $GITHUB_ENV
            
            # Set output variables to be used in the other jobs
            echo "REL_VERSION=pr-${UNIQUE_ID}" >> $GITHUB_OUTPUT
            echo "UNIQUE_ID=${UNIQUE_ID}" >> $GITHUB_OUTPUT
            echo "CHECKOUT_REPO=${{ env.CHECKOUT_REPO }}" >> $GITHUB_OUTPUT
            echo "CHECKOUT_REF=${{ env.CHECKOUT_REF }}" >> $GITHUB_OUTPUT
            echo "AZURE_TEST_RESOURCE_GROUP=radtest-${UNIQUE_ID}" >> $GITHUB_OUTPUT
            echo "RAD_CLI_ARTIFACT_NAME=rad_cli_linux_amd64" >> $GITHUB_OUTPUT
            echo "PR_NUMBER=${{ env.PR_NUMBER }}" >> $GITHUB_OUTPUT
          else
            cat ./dist/cache/.buildenv >> $GITHUB_OUTPUT
            echo "## Radius functional test environment varibles" >> $GITHUB_STEP_SUMMARY
            echo "Use the previously built binaries for the current test run:" >> $GITHUB_STEP_SUMMARY
            cat ./dist/cache/.buildenv >> $GITHUB_STEP_SUMMARY
          fi
      - name: Check out code
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' 
        uses: actions/checkout@v3
        with:
          repository: ${{ env.CHECKOUT_REPO }}
          ref: ${{ env.CHECKOUT_REF }}
      - name: Set up Go ${{ env.GOVER }}
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' 
        uses: actions/setup-go@v3
        with:
          go-version: ${{ env.GOVER }}
      - name: Get Go Cache path
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' 
        id: go-cache-paths
        run: |
          echo "go-build=$(go env GOCACHE)" >> $GITHUB_OUTPUT
          echo "go-mod=$(go env GOMODCACHE)" >> $GITHUB_OUTPUT
      - uses: actions/cache@v3
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' 
        with:
          path: |
            ${{ steps.go-cache-paths.outputs.go-build }}
            ${{ steps.go-cache-paths.outputs.go-mod }}
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      - name: Log the summary of test build.
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' 
        continue-on-error: true
        run: |
          cat <<EOF > summary.md
          ## Radius functional test overview

          | Name | Value |
          |------|-------|
          |**Repository** | ${{ steps.gen-id.outputs.CHECKOUT_REPO }} |
          |**Commit ref** | ${{ steps.gen-id.outputs.CHECKOUT_REF }} |
          |**Unique ID** | ${{ steps.gen-id.outputs.UNIQUE_ID }} |
          |**Image tag** | ${{ steps.gen-id.outputs.REL_VERSION }} |

          <details>
          <summary> Click here to see the list of tools in the current test run</summary>

          * gotestsum ${{ env.GOTESTSUM_VER }}
          * recipe location `${{ env.CACHE_REGISTRY}}/test/functional/shared/recipes/<name>:${{ steps.gen-id.outputs.REL_VERSION }}`
          * applications-rp test image location: `${{ env.CACHE_REGISTRY }}/applications-rp:${{ steps.gen-id.outputs.REL_VERSION }}`
          * ucp test image location: `${{ env.CACHE_REGISTRY }}/ucpd:${{ steps.gen-id.outputs.REL_VERSION }}`

          </details>
          
          ## Test Status
          EOF
          cat summary.md >> $GITHUB_STEP_SUMMARY
      - name: Setup Azure CLI
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' 
        run: curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
      - name: Login to Azure
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' 
        uses: azure/login@v1
        with:
          creds: '{"clientId":"${{ secrets.INTEGRATION_TEST_SP_APP_ID }}","clientSecret":"${{ secrets.INTEGRATION_TEST_SP_PASSWORD }}","subscriptionId":"${{ secrets.INTEGRATION_TEST_SUBSCRIPTION_ID }}","tenantId":"${{ secrets.INTEGRATION_TEST_TENANT_ID }}"}'
      - name: Login ACR - ${{ env.CACHE_REGISTRY }}
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' 
        run: |
          az acr login -n ${{ env.CACHE_REGISTRY }}
      - name: Build and Push container images
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' 
        run: |
          make build && make docker-build && make docker-push
        env:
          DOCKER_REGISTRY: ${{ env.CACHE_REGISTRY }}
          DOCKER_TAG_VERSION: ${{ env.REL_VERSION }}
      - name: Upload CLI binary
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' 
        uses: actions/upload-artifact@v3
        with:
          name: ${{ steps.gen-id.outputs.RAD_CLI_ARTIFACT_NAME }}
          path: |
            ./dist/linux_amd64/release/rad
      - name: Log the result (success)
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' && success()
        continue-on-error: true
        run: |
          echo ":white_check_mark: Container images build succeeded" >> $GITHUB_STEP_SUMMARY
      - name: Log the result (success)
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' && failure()
        continue-on-error: true
        run: |
          echo ":x: Container images build failed" >> $GITHUB_STEP_SUMMARY
      - name: Log recipe publish status
        if: steps.skip-build.outputs.SKIP_BUILD != 'true'
        continue-on-error: true
        run: |
          echo ":hourglass: Publishing Bicep Recipes for functional tests..." >> $GITHUB_STEP_SUMMARY
      - name: Download rad-bicep
        if: steps.skip-build.outputs.SKIP_BUILD != 'true'
        run: |
          mkdir -p dist
          ./.github/scripts/curl-with-retries.sh https://get.radapp.dev/tools/bicep-extensibility/edge/linux-x64/rad-bicep --output dist/rad-bicep
          chmod +x dist/rad-bicep
      - name: Move the latest binaries to cache
        if: steps.skip-build.outputs.SKIP_BUILD != 'true'
        run: |
          mkdir -p ./dist/cache
          mv ./dist/linux_amd64/release/rad ./dist/cache
          echo $(date +%s) > ./dist/cache/.lastbuildtime
          echo "UNIQUE_ID=${{ steps.gen-id.outputs.UNIQUE_ID }}" >> ./dist/cache/.buildenv
          echo "REL_VERSION=${{ steps.gen-id.outputs.REL_VERSION }}" >> ./dist/cache/.buildenv
          echo "CHECKOUT_REPO=${{ steps.gen-id.outputs.CHECKOUT_REPO }}" >> ./dist/cache/.buildenv
          echo "CHECKOUT_REF=$(git rev-parse HEAD)" >> ./dist/cache/.buildenv
          echo "PR_NUMBER=${{ steps.gen-id.outputs.PR_NUMBER }}" >> ./dist/cache/.buildenv
          echo "RECIPE_TAG_VERSION=${{ steps.gen-id.outputs.REL_VERSION }}" >> ./dist/cache/.buildenv
      - name: Store the latest binaries into cache
        uses: actions/cache/save@v3
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' && success()
        with:
          path: ./dist/cache
          key: radius-test-latest-${{ github.sha }}-${{ github.run_number }}
      - name: Publish Bicep Test Recipes
        if: steps.skip-build.outputs.SKIP_BUILD != 'true'
        run: |
          make publish-test-recipes
        env:
          RECIPE_REGISTRY: ${{ env.CACHE_REGISTRY }}
          RECIPE_TAG_VERSION: ${{ env.REL_VERSION }}
          RAD_BICEP_PATH: dist
      - name: Log recipe publish status (success)
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' && success()
        run: |
          echo ":white_check_mark: Recipe publishing succeeded" >> $GITHUB_STEP_SUMMARY
      - name: Log recipe publish status (failure)
        if: steps.skip-build.outputs.SKIP_BUILD != 'true' && failure()
        run: |
          echo ":x: Test recipe publishing failed" >> $GITHUB_STEP_SUMMARY
  tests:
    name: Run ${{ matrix.name }} functional tests
    needs: build
    runs-on: [ self-hosted, 1ES.Pool=1ES-Radius ]
    strategy:
      fail-fast: true
      matrix:
        name: [shared]
    env:
      SKIP_BUILD: ${{ needs.build.outputs.SKIP_BUILD }}
      UNIQUE_ID: ${{ needs.build.outputs.UNIQUE_ID }}
      REL_VERSION: ${{ needs.build.outputs.REL_VERSION }}
      CHECKOUT_REPO: ${{ needs.build.outputs.CHECKOUT_REPO }}
      CHECKOUT_REF: ${{ needs.build.outputs.CHECKOUT_REF }}
      PR_NUMBER: ${{ needs.build.outputs.PR_NUMBER }}
      AZURE_TEST_RESOURCE_GROUP: radtest-${{ needs.build.outputs.UNIQUE_ID }}-${{ matrix.name }}
      RAD_CLI_ARTIFACT_NAME: ${{ needs.build.outputs.RAD_CLI_ARTIFACT_NAME }}
      RECIPE_TAG_VERSION: ${{ needs.build.outputs.REL_VERSION }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          repository: ${{ env.CHECKOUT_REPO }}
          ref: ${{ env.CHECKOUT_REF }}
      - name: Set up Go ${{ env.GOVER }}
        uses: actions/setup-go@v3
        with:
          go-version: ${{ env.GOVER }}
      - name: Get Go Cache path
        id: go-cache-paths
        run: |
          echo "go-build=$(go env GOCACHE)" >> $GITHUB_OUTPUT
          echo "go-mod=$(go env GOMODCACHE)" >> $GITHUB_OUTPUT
      - uses: actions/cache@v3
        with:
          path: |
            ${{ steps.go-cache-paths.outputs.go-build }}
            ${{ steps.go-cache-paths.outputs.go-mod }}
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      - name: Download rad CLI
        if: env.SKIP_BUILD != 'true'
        uses: actions/download-artifact@v3
        with:
          name: ${{ env.RAD_CLI_ARTIFACT_NAME }}
          path: bin
      - name: Restore the latest cached binaries
        if: env.SKIP_BUILD == 'true'
        uses: actions/cache/restore@v3
        with:
          path: ./dist/cache
          key: radius-test-latest-
      - name: Install rad CLI in bin
        if: env.SKIP_BUILD == 'true'
        run: |
          mkdir -p ./bin
          mv ./dist/cache/rad ./bin/
          chmod +x ./bin/rad
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: '{"clientId":"${{ secrets.INTEGRATION_TEST_SP_APP_ID }}","clientSecret":"${{ secrets.INTEGRATION_TEST_SP_PASSWORD }}","subscriptionId":"${{ secrets.INTEGRATION_TEST_SUBSCRIPTION_ID }}","tenantId":"${{ secrets.INTEGRATION_TEST_TENANT_ID }}"}'
      - name: Create azure resource group - ${{ env.AZURE_TEST_RESOURCE_GROUP }}
        run: |
          current_time=$(date +%s)
          az group create \
            --location ${{ env.AZURE_LOCATION }} \
            --name $RESOURCE_GROUP \
            --subscription ${{ secrets.INTEGRATION_TEST_SUBSCRIPTION_ID }} \
            --tags creationTime=$current_time
          while [ $(az group exists --name $RESOURCE_GROUP) = false ]; do sleep 2; done
        env:
          RESOURCE_GROUP: ${{ env.AZURE_TEST_RESOURCE_GROUP }}
      - name: Get kubeconf credential for AKS cluster
        run: |
          az aks get-credentials \
            --subscription ${{ secrets.INTEGRATION_TEST_SUBSCRIPTION_ID }} \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} --admin
        env:
          RESOURCE_GROUP: ${{ env.AZURE_TEST_RESOURCE_GROUP }}
      - name: Download Bicep
        run: |
          chmod +x ./bin/rad
          export PATH=$GITHUB_WORKSPACE/bin:$PATH
          which rad || { echo "cannot find rad"; exit 1; }
          rad bicep download
          rad version
      - name: Install gotestsum (test reporting tool)
        run: |
          go install gotest.tools/gotestsum@v${{ env.GOTESTSUM_VER }}
      - name: Install Radius
        if: env.SKIP_BUILD != 'true'
        run: |
          export PATH=$GITHUB_WORKSPACE/bin:$PATH
          which rad || { echo "cannot find rad"; exit 1; }

          echo "*** Installing Radius to Kubernetes ***"
          rad install kubernetes --reinstall \
            --chart ${{ env.RADIUS_CHART_LOCATION }} \
            --set rp.image=${{ env.CACHE_REGISTRY }}/applications-rp,rp.tag=${{ env.REL_VERSION }},ucp.image=${{ env.CACHE_REGISTRY }}/ucpd,ucp.tag=${{ env.REL_VERSION }}
      - name: Configure Radius test workspace
        run: |
          export PATH=$GITHUB_WORKSPACE/bin:$PATH
          which rad || { echo "cannot find rad"; exit 1; }

          echo "*** Create workspace, group and environment for test ***"
          rad workspace create kubernetes
          rad group create radiuse2e00-aks-admin
          rad group switch radiuse2e00-aks-admin

          # The functional test is designed to use default namespace. So you must create the environment for default namespace.
          rad env create radiuse2e00-aks-admin --namespace default
          rad env switch radiuse2e00-aks-admin

          echo "*** Configuring Azure provider ***"
          rad env update radiuse2e00-aks-admin --azure-subscription-id ${{ secrets.INTEGRATION_TEST_SUBSCRIPTION_ID }} \
            --azure-resource-group ${{ env.AZURE_TEST_RESOURCE_GROUP }}
          rad credential register azure --client-id ${{ secrets.INTEGRATION_TEST_SP_APP_ID }} \
            --client-secret ${{ secrets.INTEGRATION_TEST_SP_PASSWORD }} \
            --tenant-id ${{ secrets.INTEGRATION_TEST_TENANT_ID }}

          echo "*** Configuring AWS provider ***"
          rad env update radiuse2e00-aks-admin --aws-region ${{ env.AWS_REGION }} --aws-account-id ${{ secrets.FUNCTEST_AWS_ACCOUNT_ID }}
          rad credential register aws \
            --access-key-id ${{ secrets.FUNCTEST_AWS_ACCESS_KEY_ID }} --secret-access-key ${{ secrets.FUNCTEST_AWS_SECRET_ACCESS_KEY }}
          
          az acr login -n ${{ env.CACHE_REGISTRY }}
      - name: Log radius installation status (failure)
        if: failure()
        run: |
          echo ":x: Failed to install Radius for ${{ matrix.name }} functional test." >> $GITHUB_STEP_SUMMARY
      - name: Get OIDC Issuer from AKS cluster
        run: |
          echo "FUNCTEST_OIDC_ISSUER=$(az aks show -n ${{ env.AKS_CLUSTER_NAME }} -g ${{ env.AKS_RESOURCE_GROUP }} --query "oidcIssuerProfile.issuerUrl" -otsv)" >> $GITHUB_ENV
      - name: Run functional tests
        run: |
          # Ensure rad cli is in path before running tests.
          export PATH=$GITHUB_WORKSPACE/bin:$PATH
          cd $GITHUB_WORKSPACE

          which rad || { echo "cannot find rad"; exit 1; }

          # Populate the following test environment variables from JSON secret.
          # AZURE_MONGODB_RESOURCE_ID
          # AZURE_COSMOS_MONGODB_ACCOUNT_ID
          # AZURE_TABLESTORAGE_RESOURCE_ID
          # AZURE_SERVICEBUS_RESOURCE_ID
          # AZURE_REDIS_RESOURCE_ID
          # AZURE_MSSQL_RESOURCE_ID
          # AZURE_MSSQL_USERNAME
          # AZURE_MSSQL_PASSWORD
          eval "export $(echo "${{ secrets.FUNCTEST_PREPROVISIONED_RESOURCE_JSON }}" | jq -r 'to_entries | map("\(.key)=\(.value)") | @sh')"

          make test-functional-${{ matrix.name }}
        env:
          TEST_TIMEOUT: ${{ env.FUNCTIONALTEST_TIMEOUT }}
          RADIUS_CONTAINER_LOG_PATH: ${{ github.workspace }}/${{ env.RADIUS_CONTAINER_LOG_BASE }}
          AWS_ACCESS_KEY_ID: ${{ secrets.FUNCTEST_AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.FUNCTEST_AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ env.AWS_REGION }}
          RADIUS_SAMPLES_REPO_ROOT: ${{ github.workspace }}/samples
          # Test_MongoDB_Recipe_Parameters is using the following environment variable.
          INTEGRATION_TEST_RESOURCE_GROUP_NAME: ${{ env.AZURE_TEST_RESOURCE_GROUP }}
          RECIPE_REGISTRY: ${{ env.CACHE_REGISTRY }}
          RECIPE_TAG_VERSION: ${{ env.RECIPE_TAG_VERSION }}
          FUNC_TEST_OIDC_ISSUER: ${{ env.FUNCTEST_OIDC_ISSUER }}
      - name: Log radius e2e test status (success)
        if: success()
        run: |
          echo ":white_check_mark: ${{ matrix.name }} functional tests succeeded" >> $GITHUB_STEP_SUMMARY
      - name: Log radius e2e test status (failure)
        if: failure()
        run: |
          echo ":x: ${{ matrix.name }} functional test failed." >> $GITHUB_STEP_SUMMARY
      - name: Delete azure resource group - ${{ env.AZURE_TEST_RESOURCE_GROUP }}
        if: always()
        run: |
          # if deletion fails, purge workflow will purge the resource group and its resources later.
          az group delete \
            --subscription ${{ secrets.INTEGRATION_TEST_SUBSCRIPTION_ID }} \
            --name ${{ env.AZURE_TEST_RESOURCE_GROUP }} \
            --yes --verbose
      - name: delete namespaces
        if: always()
        run: |
          kubectl delete resources.ucp.dev -n radius-system --all
          kubectl delete queuemessages.ucp.dev -n radius-system --all
          kubectl delete namespace $(kubectl get namespace | grep -E '^corerp.*|^default-.*|^radiusfunctionaltestbucket.*|^kubernetes-cli.*|^dpsb-.*|^azstorage-workload.*|^dapr-serviceinvocation|^msc823.*|^mse0af.*' | awk '{print $1}')
