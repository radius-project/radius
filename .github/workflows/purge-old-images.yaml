name: Purge test container images

permissions:
  id-token: write
  contents: read
  packages: write

on:
  # Enable manual trigger
  workflow_dispatch:
    inputs:
      image_names:
        description: "Container package name patterns (comma-separated), e.g. dev/* or dev/*,other/*"
        required: false
        default: "dev/*"
      tag_filter:
        description: "Tag pattern to match versions for deletion (supports * and ? wildcards)"
        required: false
        default: "pr-*"
      cut_off_hours:
        description: "Only delete versions older than this many hours"
        required: false
        default: "48"
      dry_run:
        description: "If true, list deletions without deleting"
        required: false
        default: "false"
  schedule:
    # Run twice a day
    - cron: "30 0,12 * * *"

env:
  ACTION_LINK: "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

jobs:
  purge_ghcr_dev:
    name: Delete old unused test container images
    runs-on: ubuntu-latest
    if: github.repository == 'radius-project/radius'
    steps:
      - name: Purge dev/* images with pr-* tags older than 48 hours (GHCR)
        uses: actions/github-script@v7
        env:
          IMAGE_NAMES: ${{ github.event.inputs.image_names || 'dev/*' }}
          TAG_FILTER: ${{ github.event.inputs.tag_filter || 'pr-*' }}
          CUT_OFF_HOURS: ${{ github.event.inputs.cut_off_hours || '48' }}
          DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
        with:
          github-token: ${{ secrets.GH_RAD_CI_BOT_PAT }}
          script: |
            const org = 'radius-project';
            const imageNames = (process.env.IMAGE_NAMES || 'dev/*')
              .split(',')
              .map(s => s.trim())
              .filter(Boolean);
            const tagFilter = process.env.TAG_FILTER || 'pr-*';
            const cutOffHours = Number(process.env.CUT_OFF_HOURS || '48');
            const dryRun = (process.env.DRY_RUN || 'false').toLowerCase() === 'true';
            const cutoff = new Date(Date.now() - cutOffHours * 60 * 60 * 1000);
            const perPage = 100;

            function globToRegExp(glob) {
              const esc = s => s.replace(/[.+^${}()|[\]\\]/g, '\\$&');
              const re = '^' + esc(glob).replace(/\\\*/g, '.*').replace(/\\\?/g, '.') + '$';
              return new RegExp(re);
            }

            const imageNameRegexes = imageNames.map(globToRegExp);
            const tagRegex = globToRegExp(tagFilter);

            async function listAllPackages() {
              let page = 1;
              const out = [];
              while (true) {
                const { data } = await github.request('GET /orgs/{org}/packages', {
                  org,
                  package_type: 'container',
                  per_page: perPage,
                  page,
                });
                if (!data || data.length === 0) break;
                out.push(...data);
                if (data.length < perPage) break;
                page++;
              }
              return out;
            }

            async function listAllVersions(pkgName) {
              let page = 1;
              const out = [];
              while (true) {
                const { data } = await github.request('GET /orgs/{org}/packages/{package_type}/{package_name}/versions', {
                  org,
                  package_type: 'container',
                  package_name: pkgName,
                  per_page: perPage,
                  page,
                });
                if (!data || data.length === 0) break;
                out.push(...data);
                if (data.length < perPage) break;
                page++;
              }
              return out;
            }

            function tagMatches(tags) {
              if (!Array.isArray(tags)) return false;
              return tags.some(t => typeof t === 'string' && tagRegex.test(t));
            }

            function isOlderThanCutoff(version) {
              const d = new Date(version.updated_at || version.created_at || 0);
              return d < cutoff;
            }

            let deleted = 0;
            let examined = 0;
            const pkgsAll = await listAllPackages();
            const pkgs = pkgsAll.filter(p => p.name && imageNameRegexes.some(re => re.test(p.name)));
            core.info(`Found ${pkgs.length} matching container packages (patterns: ${imageNames.join(', ')})`);

            for (const pkg of pkgs) {
              const versions = await listAllVersions(pkg.name);
              for (const v of versions) {
                examined++;
                const tags = v?.metadata?.container?.tags || [];
                if (!tagMatches(tags)) continue;
                if (!isOlderThanCutoff(v)) continue;
                try {
                  if (dryRun) {
                    core.info(`[DRY RUN] Would delete ${pkg.name}@${v.id} (tags: ${tags.join(',')})`);
                  } else {
                    await github.request('DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}', {
                      org,
                      package_type: 'container',
                      package_name: pkg.name,
                      package_version_id: v.id,
                    });
                    deleted++;
                    core.info(`Deleted ${pkg.name}@${v.id} (tags: ${tags.join(',')})`);
                  }
                } catch (err) {
                  core.warning(`Failed to delete ${pkg.name}@${v.id}: ${err?.message || err}`);
                }
              }
            }

            core.info(`Examined versions: ${examined}, deleted: ${deleted}`);

  create_issue_on_failure:
    name: Create issue for failing purge old images resources run
    needs: [purge_ghcr_dev]
    runs-on: ubuntu-latest
    if: ${{ failure() && github.event_name != 'workflow_dispatch' }}
    steps:
      - uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GH_RAD_CI_BOT_PAT }}
          script: |
            github.rest.issues.create({
              ...context.repo,
              title: `Purge old images failed - Run ID: ${context.runId}`,
              labels: ['test-failure'],
              body: `## Bug information \n\nThis bug is generated automatically if the purge old images workflow fails. For further investigation, please visit [here](${process.env.ACTION_LINK}).`
            })
