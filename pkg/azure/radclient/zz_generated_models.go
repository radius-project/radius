//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package radclient

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// ApplicationBeginCreateOrUpdateOptions contains the optional parameters for the Application.BeginCreateOrUpdate method.
type ApplicationBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ApplicationBeginDeleteOptions contains the optional parameters for the Application.BeginDelete method.
type ApplicationBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ApplicationGetOptions contains the optional parameters for the Application.Get method.
type ApplicationGetOptions struct {
	// placeholder for future optional parameters
}

// ApplicationList - List of Application resources.
type ApplicationList struct {
	// REQUIRED; List of Application resources.
	Value []*ApplicationResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationList.
func (a ApplicationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// ApplicationListOptions contains the optional parameters for the Application.List method.
type ApplicationListOptions struct {
	// placeholder for future optional parameters
}

// ApplicationProperties - Properties of an application.
type ApplicationProperties struct {
	// Status of the application
	Status *ApplicationStatus `json:"status,omitempty"`
}

// ApplicationResource - Application resource.
type ApplicationResource struct {
	TrackedResource
	// Properties of the application.
	Properties *ApplicationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationResource.
func (a ApplicationResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationResource.
func (a *ApplicationResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, &a.Properties)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.TrackedResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ApplicationStatus - Status of an application.
type ApplicationStatus struct {
	// Health errors for the application
	HealthErrorDetails *string `json:"healthErrorDetails,omitempty"`

	// Health state of the application
	HealthState *string `json:"healthState,omitempty"`

	// Provisioning errors for the application
	ProvisioningErrorDetails *string `json:"provisioningErrorDetails,omitempty"`

	// Provisioning state of the application
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// AzureComKeyVaultBeginCreateOrUpdateOptions contains the optional parameters for the AzureComKeyVault.BeginCreateOrUpdate method.
type AzureComKeyVaultBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// AzureComKeyVaultBeginDeleteOptions contains the optional parameters for the AzureComKeyVault.BeginDelete method.
type AzureComKeyVaultBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// AzureComKeyVaultGetOptions contains the optional parameters for the AzureComKeyVault.Get method.
type AzureComKeyVaultGetOptions struct {
	// placeholder for future optional parameters
}

// AzureComKeyVaultListOptions contains the optional parameters for the AzureComKeyVault.List method.
type AzureComKeyVaultListOptions struct {
	// placeholder for future optional parameters
}

// AzureComServiceBusQueueBeginCreateOrUpdateOptions contains the optional parameters for the AzureComServiceBusQueue.BeginCreateOrUpdate method.
type AzureComServiceBusQueueBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// AzureComServiceBusQueueBeginDeleteOptions contains the optional parameters for the AzureComServiceBusQueue.BeginDelete method.
type AzureComServiceBusQueueBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// AzureComServiceBusQueueGetOptions contains the optional parameters for the AzureComServiceBusQueue.Get method.
type AzureComServiceBusQueueGetOptions struct {
	// placeholder for future optional parameters
}

// AzureComServiceBusQueueListOptions contains the optional parameters for the AzureComServiceBusQueue.List method.
type AzureComServiceBusQueueListOptions struct {
	// placeholder for future optional parameters
}

// AzureEntityResource - The resource model definition for an Azure Resource Manager resource with an etag.
type AzureEntityResource struct {
	Resource
	// READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureEntityResource.
func (a AzureEntityResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.Resource.marshalInternal(objectMap)
	populate(objectMap, "etag", a.Etag)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureEntityResource.
func (a *AzureEntityResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
				err = unpopulate(val, &a.Etag)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type AzureFileShareVolumeProperties struct {
	VolumeProperties
	// The ID of the volume to use for this resource
	Resource *string `json:"resource,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileShareVolumeProperties.
func (a AzureFileShareVolumeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.VolumeProperties.marshalInternal(objectMap, "azure.com.fileshare")
	populate(objectMap, "resource", a.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileShareVolumeProperties.
func (a *AzureFileShareVolumeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resource":
				err = unpopulate(val, &a.Resource)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.VolumeProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AzureKeyVaultList - List of azure.com.KeyVault resources.
type AzureKeyVaultList struct {
	// REQUIRED; List of azure.com.KeyVault resources.
	Value []*AzureKeyVaultResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureKeyVaultList.
func (a AzureKeyVaultList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

type AzureKeyVaultProperties struct {
	BasicResourceProperties
	// REQUIRED; The ID of the user-managed KeyVault to use
	Resource *string `json:"resource,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureKeyVaultProperties.
func (a AzureKeyVaultProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.BasicResourceProperties.marshalInternal(objectMap)
	populate(objectMap, "resource", a.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureKeyVaultProperties.
func (a *AzureKeyVaultProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resource":
				err = unpopulate(val, &a.Resource)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.BasicResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AzureKeyVaultResource - Azure KeyVault
type AzureKeyVaultResource struct {
	ProxyResource
	// REQUIRED
	Properties *AzureKeyVaultProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureKeyVaultResource.
func (a AzureKeyVaultResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureKeyVaultResource.
func (a *AzureKeyVaultResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, &a.Properties)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type AzureKeyVaultVolumeProperties struct {
	VolumeProperties
	// The KeyVault certificates that this volume exposes
	Certificates map[string]*CertificateObjectProperties `json:"certificates,omitempty"`

	// The KeyVault keys that this volume exposes
	Keys map[string]*KeyObjectProperties `json:"keys,omitempty"`

	// The ID of the keyvault to use for this volume resource
	Resource *string `json:"resource,omitempty"`

	// The KeyVault secrets that this volume exposes
	Secrets map[string]*SecretObjectProperties `json:"secrets,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureKeyVaultVolumeProperties.
func (a AzureKeyVaultVolumeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.VolumeProperties.marshalInternal(objectMap, "azure.com.keyvault")
	populate(objectMap, "certificates", a.Certificates)
	populate(objectMap, "keys", a.Keys)
	populate(objectMap, "resource", a.Resource)
	populate(objectMap, "secrets", a.Secrets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureKeyVaultVolumeProperties.
func (a *AzureKeyVaultVolumeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "certificates":
				err = unpopulate(val, &a.Certificates)
				delete(rawMsg, key)
		case "keys":
				err = unpopulate(val, &a.Keys)
				delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, &a.Resource)
				delete(rawMsg, key)
		case "secrets":
				err = unpopulate(val, &a.Secrets)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.VolumeProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AzureServiceBusList - List of azure.com.ServiceBusQueue resources.
type AzureServiceBusList struct {
	// REQUIRED; List of azure.com.ServiceBusQueue resources.
	Value []*AzureServiceBusResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureServiceBusList.
func (a AzureServiceBusList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

type AzureServiceBusProperties struct {
	BasicResourceProperties
	// REQUIRED; The ID of the user-managed ServiceBus queue to use
	Resource *string `json:"resource,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureServiceBusProperties.
func (a AzureServiceBusProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.BasicResourceProperties.marshalInternal(objectMap)
	populate(objectMap, "resource", a.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureServiceBusProperties.
func (a *AzureServiceBusProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resource":
				err = unpopulate(val, &a.Resource)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.BasicResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AzureServiceBusResource - Azure ServiceBus
type AzureServiceBusResource struct {
	ProxyResource
	// REQUIRED
	Properties *AzureServiceBusProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureServiceBusResource.
func (a AzureServiceBusResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureServiceBusResource.
func (a *AzureServiceBusResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, &a.Properties)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// BasicResourceProperties - Basic properties of a Radius resource.
type BasicResourceProperties struct {
	// Status of the resource
	Status *ResourceStatusAutoGenerated `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BasicResourceProperties.
func (b BasicResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	b.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BasicResourceProperties.
func (b *BasicResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return b.unmarshalInternal(rawMsg)
}

func (b BasicResourceProperties) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "status", b.Status)
}

func (b *BasicResourceProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "status":
				err = unpopulate(val, &b.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BasicRouteProperties - Basic properties of a route.
type BasicRouteProperties struct {
	// Status of the resource
	Status *RouteStatus `json:"status,omitempty"`
}

type CertificateObjectProperties struct {
	// REQUIRED; The name of the certificate
	Name *string `json:"name,omitempty"`

	// REQUIRED; Certificate object to be downloaded - the certificate itself, private key or public key of the certificate
	Value *CertificateObjectPropertiesValue `json:"value,omitempty"`

	// File name when written to disk.
	Alias *string `json:"alias,omitempty"`

	// Encoding format. Default utf-8
	Encoding *CertificateObjectPropertiesEncoding `json:"encoding,omitempty"`

	// Certificate format. Default pem
	Format *CertificateObjectPropertiesFormat `json:"format,omitempty"`

	// Certificate version
	Version *string `json:"version,omitempty"`
}

// CheckNameAvailabilityRequest - The check availability request body.
type CheckNameAvailabilityRequest struct {
	// The name of the resource for which availability needs to be checked.
	Name *string `json:"name,omitempty"`

	// The resource type.
	Type *string `json:"type,omitempty"`
}

// CheckNameAvailabilityResponse - The check availability result.
type CheckNameAvailabilityResponse struct {
	// Detailed reason why the given name is available.
	Message *string `json:"message,omitempty"`

	// Indicates if the resource name is available.
	NameAvailable *bool `json:"nameAvailable,omitempty"`

	// The reason why the given name is not available.
	Reason *CheckNameAvailabilityReason `json:"reason,omitempty"`
}

// Connection - Specifies a connection to another resource
type Connection struct {
	// REQUIRED; The kind of connection
	Kind *ConnectionKind `json:"kind,omitempty"`

	// REQUIRED; The source of the connection
	Source *string `json:"source,omitempty"`

	// RBAC permissions to be assigned on the source resource
	Roles []*string `json:"roles,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Connection.
func (c Connection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "kind", c.Kind)
	populate(objectMap, "roles", c.Roles)
	populate(objectMap, "source", c.Source)
	return json.Marshal(objectMap)
}

// Container - Definition of a container.
type Container struct {
	// REQUIRED; The registry and image to download and run in your container
	Image *string `json:"image,omitempty"`

	// Dictionary of
	Env map[string]*string `json:"env,omitempty"`

	// Properties for readiness/liveness probe
	LivenessProbe HealthProbePropertiesClassification `json:"livenessProbe,omitempty"`

	// Dictionary of
	Ports map[string]*ContainerPort `json:"ports,omitempty"`

	// Properties for readiness/liveness probe
	ReadinessProbe HealthProbePropertiesClassification `json:"readinessProbe,omitempty"`

	// Dictionary of
	Volumes map[string]VolumeClassification `json:"volumes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Container.
func (c Container) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "env", c.Env)
	populate(objectMap, "image", c.Image)
	populate(objectMap, "livenessProbe", c.LivenessProbe)
	populate(objectMap, "ports", c.Ports)
	populate(objectMap, "readinessProbe", c.ReadinessProbe)
	populate(objectMap, "volumes", c.Volumes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Container.
func (c *Container) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "env":
				err = unpopulate(val, &c.Env)
				delete(rawMsg, key)
		case "image":
				err = unpopulate(val, &c.Image)
				delete(rawMsg, key)
		case "livenessProbe":
				c.LivenessProbe, err = unmarshalHealthProbePropertiesClassification(val)
				delete(rawMsg, key)
		case "ports":
				err = unpopulate(val, &c.Ports)
				delete(rawMsg, key)
		case "readinessProbe":
				c.ReadinessProbe, err = unmarshalHealthProbePropertiesClassification(val)
				delete(rawMsg, key)
		case "volumes":
				c.Volumes, err = unmarshalVolumeClassificationMap(val)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ContainerBeginCreateOrUpdateOptions contains the optional parameters for the Container.BeginCreateOrUpdate method.
type ContainerBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ContainerBeginDeleteOptions contains the optional parameters for the Container.BeginDelete method.
type ContainerBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ContainerGetOptions contains the optional parameters for the Container.Get method.
type ContainerGetOptions struct {
	// placeholder for future optional parameters
}

// ContainerList - List of Container resources.
type ContainerList struct {
	// REQUIRED; List of Container resources.
	Value []*ContainerResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContainerList.
func (c ContainerList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// ContainerListOptions contains the optional parameters for the Container.List method.
type ContainerListOptions struct {
	// placeholder for future optional parameters
}

// ContainerPort - Specifies a listening port for the container
type ContainerPort struct {
	// REQUIRED; The listening port number
	ContainerPort *int32 `json:"containerPort,omitempty"`

	// Protocol in use by the port
	Protocol *ContainerPortProtocol `json:"protocol,omitempty"`

	// Specifies a route provided by this port
	Provides *string `json:"provides,omitempty"`
}

type ContainerProperties struct {
	BasicResourceProperties
	// Dictionary of
	Connections map[string]*Connection `json:"connections,omitempty"`

	// Definition of a container.
	Container *Container `json:"container,omitempty"`

	// Traits spec of the resource
	Traits []ResourceTraitClassification `json:"traits,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContainerProperties.
func (c ContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.BasicResourceProperties.marshalInternal(objectMap)
	populate(objectMap, "connections", c.Connections)
	populate(objectMap, "container", c.Container)
	populate(objectMap, "traits", c.Traits)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerProperties.
func (c *ContainerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connections":
				err = unpopulate(val, &c.Connections)
				delete(rawMsg, key)
		case "container":
				err = unpopulate(val, &c.Container)
				delete(rawMsg, key)
		case "traits":
				c.Traits, err = unmarshalResourceTraitClassificationArray(val)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.BasicResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ContainerResource - The radius.dev/Container resource provides an abstraction for a container workload that can be run on any Radius platform
type ContainerResource struct {
	ProxyResource
	// REQUIRED
	Properties *ContainerProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContainerResource.
func (c ContainerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerResource.
func (c *ContainerResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, &c.Properties)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type DaprHTTPRouteProperties struct {
	BasicRouteProperties
	// REQUIRED; The Dapr appId used for the route
	AppID *string `json:"appId,omitempty"`
}

// DaprInvokeHTTPRouteList - List of dapr.io.InvokeHttpRoute resources.
type DaprInvokeHTTPRouteList struct {
	// REQUIRED; List of dapr.io.InvokeHttpRoute resources.
	Value []*DaprInvokeHTTPRouteResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DaprInvokeHTTPRouteList.
func (d DaprInvokeHTTPRouteList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DaprInvokeHTTPRouteResource - Resource that specifies an Dapr HTTP Service Invocation Route. A Dapr HTTP Service Invocation Route describes a pattern
// of communication between resources.
type DaprInvokeHTTPRouteResource struct {
	ProxyResource
	// REQUIRED
	Properties *DaprHTTPRouteProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DaprInvokeHTTPRouteResource.
func (d DaprInvokeHTTPRouteResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DaprInvokeHTTPRouteResource.
func (d *DaprInvokeHTTPRouteResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, &d.Properties)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DaprIoInvokeHTTPRouteBeginCreateOrUpdateOptions contains the optional parameters for the DaprIoInvokeHTTPRoute.BeginCreateOrUpdate method.
type DaprIoInvokeHTTPRouteBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DaprIoInvokeHTTPRouteBeginDeleteOptions contains the optional parameters for the DaprIoInvokeHTTPRoute.BeginDelete method.
type DaprIoInvokeHTTPRouteBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// DaprIoInvokeHTTPRouteGetOptions contains the optional parameters for the DaprIoInvokeHTTPRoute.Get method.
type DaprIoInvokeHTTPRouteGetOptions struct {
	// placeholder for future optional parameters
}

// DaprIoInvokeHTTPRouteListOptions contains the optional parameters for the DaprIoInvokeHTTPRoute.List method.
type DaprIoInvokeHTTPRouteListOptions struct {
	// placeholder for future optional parameters
}

// DaprIoPubSubTopicBeginCreateOrUpdateOptions contains the optional parameters for the DaprIoPubSubTopic.BeginCreateOrUpdate method.
type DaprIoPubSubTopicBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DaprIoPubSubTopicBeginDeleteOptions contains the optional parameters for the DaprIoPubSubTopic.BeginDelete method.
type DaprIoPubSubTopicBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// DaprIoPubSubTopicGetOptions contains the optional parameters for the DaprIoPubSubTopic.Get method.
type DaprIoPubSubTopicGetOptions struct {
	// placeholder for future optional parameters
}

// DaprIoPubSubTopicListOptions contains the optional parameters for the DaprIoPubSubTopic.List method.
type DaprIoPubSubTopicListOptions struct {
	// placeholder for future optional parameters
}

// DaprIoStateStoreBeginCreateOrUpdateOptions contains the optional parameters for the DaprIoStateStore.BeginCreateOrUpdate method.
type DaprIoStateStoreBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DaprIoStateStoreBeginDeleteOptions contains the optional parameters for the DaprIoStateStore.BeginDelete method.
type DaprIoStateStoreBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// DaprIoStateStoreGetOptions contains the optional parameters for the DaprIoStateStore.Get method.
type DaprIoStateStoreGetOptions struct {
	// placeholder for future optional parameters
}

// DaprIoStateStoreListOptions contains the optional parameters for the DaprIoStateStore.List method.
type DaprIoStateStoreListOptions struct {
	// placeholder for future optional parameters
}

type DaprPubSubTopicAzureServiceBusResourceProperties struct {
	DaprPubSubTopicProperties
	// REQUIRED; PubSub resource
	Resource *string `json:"resource,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DaprPubSubTopicAzureServiceBusResourceProperties.
func (d DaprPubSubTopicAzureServiceBusResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DaprPubSubTopicProperties.marshalInternal(objectMap, "pubsub.azure.servicebus")
	populate(objectMap, "resource", d.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DaprPubSubTopicAzureServiceBusResourceProperties.
func (d *DaprPubSubTopicAzureServiceBusResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resource":
				err = unpopulate(val, &d.Resource)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DaprPubSubTopicProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type DaprPubSubTopicGenericResourceProperties struct {
	DaprPubSubTopicProperties
	// REQUIRED; Metadata for the pub sub resource. This should match the values specified in Dapr component spec
	Metadata map[string]interface{} `json:"metadata,omitempty"`

	// REQUIRED; Dapr PubSub type. These strings match the format used by Dapr Kubernetes configuration format.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Dapr component version
	Version *string `json:"version,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DaprPubSubTopicGenericResourceProperties.
func (d DaprPubSubTopicGenericResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DaprPubSubTopicProperties.marshalInternal(objectMap, "generic")
	populate(objectMap, "metadata", d.Metadata)
	populate(objectMap, "type", d.Type)
	populate(objectMap, "version", d.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DaprPubSubTopicGenericResourceProperties.
func (d *DaprPubSubTopicGenericResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "metadata":
				err = unpopulate(val, &d.Metadata)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &d.Type)
				delete(rawMsg, key)
		case "version":
				err = unpopulate(val, &d.Version)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DaprPubSubTopicProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DaprPubSubTopicList - List of dapr.io.PubSubTopic resources.
type DaprPubSubTopicList struct {
	// REQUIRED; List of dapr.io.PubSubTopic resources.
	Value []*DaprPubSubTopicResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DaprPubSubTopicList.
func (d DaprPubSubTopicList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DaprPubSubTopicPropertiesClassification provides polymorphic access to related types.
// Call the interface's GetDaprPubSubTopicProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DaprPubSubTopicAzureServiceBusResourceProperties, *DaprPubSubTopicGenericResourceProperties, *DaprPubSubTopicProperties
type DaprPubSubTopicPropertiesClassification interface {
	// GetDaprPubSubTopicProperties returns the DaprPubSubTopicProperties content of the underlying type.
	GetDaprPubSubTopicProperties() *DaprPubSubTopicProperties
}

type DaprPubSubTopicProperties struct {
	BasicResourceProperties
	// REQUIRED; The DaprPubSubTopicProperties kind
	Kind *string `json:"kind,omitempty"`
}

// GetDaprPubSubTopicProperties implements the DaprPubSubTopicPropertiesClassification interface for type DaprPubSubTopicProperties.
func (d *DaprPubSubTopicProperties) GetDaprPubSubTopicProperties() *DaprPubSubTopicProperties { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DaprPubSubTopicProperties.
func (d *DaprPubSubTopicProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DaprPubSubTopicProperties) marshalInternal(objectMap map[string]interface{}, discValue string) {
	d.BasicResourceProperties.marshalInternal(objectMap)
	d.Kind = &discValue
	objectMap["kind"] = d.Kind
}

func (d *DaprPubSubTopicProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, &d.Kind)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.BasicResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DaprPubSubTopicResource - Resource for Dapr Pub/Sub
type DaprPubSubTopicResource struct {
	ProxyResource
	// REQUIRED
	Properties DaprPubSubTopicPropertiesClassification `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DaprPubSubTopicResource.
func (d DaprPubSubTopicResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DaprPubSubTopicResource.
func (d *DaprPubSubTopicResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				d.Properties, err = unmarshalDaprPubSubTopicPropertiesClassification(val)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type DaprSecretStoreProperties struct {
	BasicResourceProperties
	// REQUIRED; Radius kind for Dapr Secret Store
	Kind *DaprSecretStorePropertiesKind `json:"kind,omitempty"`

	// REQUIRED; Metadata for the Secret Store resource. This should match the values specified in Dapr component spec
	Metadata map[string]interface{} `json:"metadata,omitempty"`

	// REQUIRED; Dapr Secret Store type. These strings match the types defined in Dapr Component format: https://docs.dapr.io/reference/components-reference/supported-secret-stores/
	Type *string `json:"type,omitempty"`

	// REQUIRED; Dapr component version
	Version *string `json:"version,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DaprSecretStoreProperties.
func (d DaprSecretStoreProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.BasicResourceProperties.marshalInternal(objectMap)
	populate(objectMap, "kind", d.Kind)
	populate(objectMap, "metadata", d.Metadata)
	populate(objectMap, "type", d.Type)
	populate(objectMap, "version", d.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DaprSecretStoreProperties.
func (d *DaprSecretStoreProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, &d.Kind)
				delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, &d.Metadata)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &d.Type)
				delete(rawMsg, key)
		case "version":
				err = unpopulate(val, &d.Version)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.BasicResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DaprSecretStoreResource - Resource for Dapr Secret Store.
type DaprSecretStoreResource struct {
	ProxyResource
	// REQUIRED
	Properties *DaprSecretStoreProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DaprSecretStoreResource.
func (d DaprSecretStoreResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DaprSecretStoreResource.
func (d *DaprSecretStoreResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, &d.Properties)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DaprSidecarTrait - The specifies that the resource should have a Dapr sidecar injected
type DaprSidecarTrait struct {
	ResourceTrait
	// REQUIRED; The Dapr appId. Specifies the identifier used by Dapr for service invocation.
	AppID *string `json:"appId,omitempty"`

	// The Dapr appPort. Specifies the internal listening port for the application to handle requests from the Dapr sidecar.
	AppPort *int32 `json:"appPort,omitempty"`

	// Specifies the Dapr configuration to use for the resource.
	Config *string `json:"config,omitempty"`

	// Specifies the Dapr app-protocol to use for the resource.
	Protocol *DaprSidecarTraitProtocol `json:"protocol,omitempty"`

	// Specifies the resource id of a dapr.io.InvokeHttpRoute that can route traffic to this resource.
	Provides *string `json:"provides,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DaprSidecarTrait.
func (d DaprSidecarTrait) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ResourceTrait.marshalInternal(objectMap, "dapr.io/Sidecar@v1alpha1")
	populate(objectMap, "appId", d.AppID)
	populate(objectMap, "appPort", d.AppPort)
	populate(objectMap, "config", d.Config)
	populate(objectMap, "protocol", d.Protocol)
	populate(objectMap, "provides", d.Provides)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DaprSidecarTrait.
func (d *DaprSidecarTrait) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appId":
				err = unpopulate(val, &d.AppID)
				delete(rawMsg, key)
		case "appPort":
				err = unpopulate(val, &d.AppPort)
				delete(rawMsg, key)
		case "config":
				err = unpopulate(val, &d.Config)
				delete(rawMsg, key)
		case "protocol":
				err = unpopulate(val, &d.Protocol)
				delete(rawMsg, key)
		case "provides":
				err = unpopulate(val, &d.Provides)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ResourceTrait.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type DaprStateStoreAzureTableStorageResourceProperties struct {
	DaprStateStoreResourceProperties
	// REQUIRED; PubSub resource
	Resource *string `json:"resource,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DaprStateStoreAzureTableStorageResourceProperties.
func (d DaprStateStoreAzureTableStorageResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DaprStateStoreResourceProperties.marshalInternal(objectMap, "state.azure.tablestorage")
	populate(objectMap, "resource", d.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DaprStateStoreAzureTableStorageResourceProperties.
func (d *DaprStateStoreAzureTableStorageResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resource":
				err = unpopulate(val, &d.Resource)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DaprStateStoreResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type DaprStateStoreGenericResourceProperties struct {
	DaprStateStoreResourceProperties
	// REQUIRED; Metadata for the state store resource. This should match the values specified in Dapr component spec
	Metadata map[string]interface{} `json:"metadata,omitempty"`

	// REQUIRED; Dapr StateStore type. These strings match the format used by Dapr Kubernetes configuration format.
	Type *string `json:"type,omitempty"`

	// REQUIRED; Dapr component version
	Version *string `json:"version,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DaprStateStoreGenericResourceProperties.
func (d DaprStateStoreGenericResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DaprStateStoreResourceProperties.marshalInternal(objectMap, "generic")
	populate(objectMap, "metadata", d.Metadata)
	populate(objectMap, "type", d.Type)
	populate(objectMap, "version", d.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DaprStateStoreGenericResourceProperties.
func (d *DaprStateStoreGenericResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "metadata":
				err = unpopulate(val, &d.Metadata)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &d.Type)
				delete(rawMsg, key)
		case "version":
				err = unpopulate(val, &d.Version)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DaprStateStoreResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DaprStateStoreList - List of dapr.io.StateStore resources.
type DaprStateStoreList struct {
	// REQUIRED; List of dapr.io.StateStore resources.
	Value []*DaprStateStoreResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DaprStateStoreList.
func (d DaprStateStoreList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DaprStateStoreResource - Resource for Dapr state store
type DaprStateStoreResource struct {
	ProxyResource
	// REQUIRED
	Properties DaprStateStoreResourcePropertiesClassification `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DaprStateStoreResource.
func (d DaprStateStoreResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DaprStateStoreResource.
func (d *DaprStateStoreResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				d.Properties, err = unmarshalDaprStateStoreResourcePropertiesClassification(val)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DaprStateStoreResourcePropertiesClassification provides polymorphic access to related types.
// Call the interface's GetDaprStateStoreResourceProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DaprStateStoreAzureTableStorageResourceProperties, *DaprStateStoreGenericResourceProperties, *DaprStateStoreResourceProperties,
// - *DaprStateStoreSqlServerResourceProperties
type DaprStateStoreResourcePropertiesClassification interface {
	// GetDaprStateStoreResourceProperties returns the DaprStateStoreResourceProperties content of the underlying type.
	GetDaprStateStoreResourceProperties() *DaprStateStoreResourceProperties
}

type DaprStateStoreResourceProperties struct {
	BasicResourceProperties
	// REQUIRED; The DaprStateStoreResourceProperties kind
	Kind *string `json:"kind,omitempty"`
}

// GetDaprStateStoreResourceProperties implements the DaprStateStoreResourcePropertiesClassification interface for type DaprStateStoreResourceProperties.
func (d *DaprStateStoreResourceProperties) GetDaprStateStoreResourceProperties() *DaprStateStoreResourceProperties { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DaprStateStoreResourceProperties.
func (d *DaprStateStoreResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DaprStateStoreResourceProperties) marshalInternal(objectMap map[string]interface{}, discValue string) {
	d.BasicResourceProperties.marshalInternal(objectMap)
	d.Kind = &discValue
	objectMap["kind"] = d.Kind
}

func (d *DaprStateStoreResourceProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, &d.Kind)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.BasicResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type DaprStateStoreSQLServerResourceProperties struct {
	DaprStateStoreResourceProperties
	// REQUIRED; PubSub resource
	Resource *string `json:"resource,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DaprStateStoreSQLServerResourceProperties.
func (d DaprStateStoreSQLServerResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DaprStateStoreResourceProperties.marshalInternal(objectMap, "state.sqlserver")
	populate(objectMap, "resource", d.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DaprStateStoreSQLServerResourceProperties.
func (d *DaprStateStoreSQLServerResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resource":
				err = unpopulate(val, &d.Resource)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DaprStateStoreResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// EncryptionProperties - Configuration of key for data encryption
type EncryptionProperties struct {
	// Key vault properties.
	KeyVaultProperties *KeyVaultProperties `json:"keyVaultProperties,omitempty"`

	// Indicates whether or not the encryption is enabled for container registry.
	Status *EncryptionStatus `json:"status,omitempty"`
}

// EphemeralVolume - Specifies an ephemeral volume for a container
type EphemeralVolume struct {
	Volume
	// REQUIRED; Backing store for the ephemeral volume
	ManagedStore *EphemeralVolumeManagedStore `json:"managedStore,omitempty"`

	// REQUIRED; The path where the volume is mounted
	MountPath *string `json:"mountPath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EphemeralVolume.
func (e EphemeralVolume) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.Volume.marshalInternal(objectMap, "ephemeral")
	populate(objectMap, "managedStore", e.ManagedStore)
	populate(objectMap, "mountPath", e.MountPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EphemeralVolume.
func (e *EphemeralVolume) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "managedStore":
				err = unpopulate(val, &e.ManagedStore)
				delete(rawMsg, key)
		case "mountPath":
				err = unpopulate(val, &e.MountPath)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := e.Volume.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ErrorAdditionalInfo - The resource management error additional info.
type ErrorAdditionalInfo struct {
	// READ-ONLY; The additional info.
	Info map[string]interface{} `json:"info,omitempty" azure:"ro"`

	// READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ErrorDetail - The error detail.
type ErrorDetail struct {
	// READ-ONLY; The error additional info.
	AdditionalInfo []*ErrorAdditionalInfo `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	Details []*ErrorDetail `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The error target.
	Target *string `json:"target,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// ErrorResponse - Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData
// error response format.).
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponse struct {
	raw string
	// The error object.
	InnerError *ErrorDetail `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponse) Error() string {
	return e.raw
}

// ExecHealthProbeProperties - Specifies the properties for readiness/liveness probe using an executable
type ExecHealthProbeProperties struct {
	HealthProbeProperties
	// REQUIRED; Command to execute to probe readiness/liveness
	Command *string `json:"command,omitempty"`

	// Threshold number of times the probe fails after which a failure would be reported
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`

	// Initial delay in seconds before probing for readiness/liveness
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`

	// Interval for the readiness/liveness probe in seconds
	PeriodSeconds *float32 `json:"periodSeconds,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExecHealthProbeProperties.
func (e ExecHealthProbeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.HealthProbeProperties.marshalInternal(objectMap, "exec")
	populate(objectMap, "command", e.Command)
	populate(objectMap, "failureThreshold", e.FailureThreshold)
	populate(objectMap, "initialDelaySeconds", e.InitialDelaySeconds)
	populate(objectMap, "periodSeconds", e.PeriodSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecHealthProbeProperties.
func (e *ExecHealthProbeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "command":
				err = unpopulate(val, &e.Command)
				delete(rawMsg, key)
		case "failureThreshold":
				err = unpopulate(val, &e.FailureThreshold)
				delete(rawMsg, key)
		case "initialDelaySeconds":
				err = unpopulate(val, &e.InitialDelaySeconds)
				delete(rawMsg, key)
		case "periodSeconds":
				err = unpopulate(val, &e.PeriodSeconds)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := e.HealthProbeProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// GatewayBeginCreateOrUpdateOptions contains the optional parameters for the Gateway.BeginCreateOrUpdate method.
type GatewayBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// GatewayBeginDeleteOptions contains the optional parameters for the Gateway.BeginDelete method.
type GatewayBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// GatewayGetOptions contains the optional parameters for the Gateway.Get method.
type GatewayGetOptions struct {
	// placeholder for future optional parameters
}

// GatewayList - List of Gateway resources.
type GatewayList struct {
	// REQUIRED; List of Gateway resources.
	Value []*GatewayResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GatewayList.
func (g GatewayList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// GatewayListOptions contains the optional parameters for the Gateway.List method.
type GatewayListOptions struct {
	// placeholder for future optional parameters
}

type GatewayListener struct {
	// The port to listen on.
	Port *float32 `json:"port,omitempty"`

	// The protocol to use for this listener.
	Protocol *string `json:"protocol,omitempty"`
}

type GatewayProperties struct {
	// Dictionary of
	Listeners map[string]*GatewayListener `json:"listeners,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GatewayProperties.
func (g GatewayProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "listeners", g.Listeners)
	return json.Marshal(objectMap)
}

// GatewayResource - Resource that specifies how traffic is exposed to the application.
type GatewayResource struct {
	ProxyResource
	Properties *GatewayProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GatewayResource.
func (g GatewayResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	g.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", g.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayResource.
func (g *GatewayResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, &g.Properties)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := g.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type GenericProperties struct {
	BasicResourceProperties
	// Dictionary of
	Properties map[string]interface{} `json:"properties,omitempty"`

	// Dictionary of
	Secrets map[string]interface{} `json:"secrets,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GenericProperties.
func (g GenericProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	g.BasicResourceProperties.marshalInternal(objectMap)
	populate(objectMap, "properties", g.Properties)
	populate(objectMap, "secrets", g.Secrets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GenericProperties.
func (g *GenericProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, &g.Properties)
				delete(rawMsg, key)
		case "secrets":
				err = unpopulate(val, &g.Secrets)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := g.BasicResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// GenericResource - Generic Resource
type GenericResource struct {
	ProxyResource
	// REQUIRED
	Properties *GenericProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GenericResource.
func (g GenericResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	g.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", g.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GenericResource.
func (g *GenericResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, &g.Properties)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := g.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// HTTPGetHealthProbeProperties - Specifies the properties for readiness/liveness probe using HTTP Get
type HTTPGetHealthProbeProperties struct {
	HealthProbeProperties
	// REQUIRED; The listening port number
	ContainerPort *int32 `json:"containerPort,omitempty"`

	// REQUIRED; The route to make the HTTP request on
	Path *string `json:"path,omitempty"`

	// Threshold number of times the probe fails after which a failure would be reported
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`

	// Custom HTTP headers to add to the get request
	Headers map[string]*string `json:"headers,omitempty"`

	// Initial delay in seconds before probing for readiness/liveness
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`

	// Interval for the readiness/liveness probe in seconds
	PeriodSeconds *float32 `json:"periodSeconds,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HTTPGetHealthProbeProperties.
func (h HTTPGetHealthProbeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	h.HealthProbeProperties.marshalInternal(objectMap, "httpGet")
	populate(objectMap, "containerPort", h.ContainerPort)
	populate(objectMap, "failureThreshold", h.FailureThreshold)
	populate(objectMap, "headers", h.Headers)
	populate(objectMap, "initialDelaySeconds", h.InitialDelaySeconds)
	populate(objectMap, "path", h.Path)
	populate(objectMap, "periodSeconds", h.PeriodSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPGetHealthProbeProperties.
func (h *HTTPGetHealthProbeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerPort":
				err = unpopulate(val, &h.ContainerPort)
				delete(rawMsg, key)
		case "failureThreshold":
				err = unpopulate(val, &h.FailureThreshold)
				delete(rawMsg, key)
		case "headers":
				err = unpopulate(val, &h.Headers)
				delete(rawMsg, key)
		case "initialDelaySeconds":
				err = unpopulate(val, &h.InitialDelaySeconds)
				delete(rawMsg, key)
		case "path":
				err = unpopulate(val, &h.Path)
				delete(rawMsg, key)
		case "periodSeconds":
				err = unpopulate(val, &h.PeriodSeconds)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := h.HealthProbeProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// HTTPRouteBeginCreateOrUpdateOptions contains the optional parameters for the HTTPRoute.BeginCreateOrUpdate method.
type HTTPRouteBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// HTTPRouteBeginDeleteOptions contains the optional parameters for the HTTPRoute.BeginDelete method.
type HTTPRouteBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// HTTPRouteGateway - Specifies configuration to allow public traffic from outside the network to the route. Configure a gateway to accept traffic from
// the internet.
type HTTPRouteGateway struct {
	// REQUIRED; Specifies the public hostname for the route. Use '*' to listen on all hostnames.
	Hostname *string `json:"hostname,omitempty"`

	// Dictionary of
	Rules map[string]*HTTPRouteGatewayRule `json:"rules,omitempty"`

	// The gateway which this route is part of.
	Source *string `json:"source,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HTTPRouteGateway.
func (h HTTPRouteGateway) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "hostname", h.Hostname)
	populate(objectMap, "rules", h.Rules)
	populate(objectMap, "source", h.Source)
	return json.Marshal(objectMap)
}

// HTTPRouteGatewayPath - Specifies path matching options to match requests on.
type HTTPRouteGatewayPath struct {
	// Specifies the path to match the incoming request.
	Type *string `json:"type,omitempty"`

	// Specifies the type of matching to match the path on. Supported values: 'prefix', 'exact'.
	Value *string `json:"value,omitempty"`
}

// HTTPRouteGatewayRule - Specifies the rule to match requests on.
type HTTPRouteGatewayRule struct {
	// Specifies the method to match on the incoming request.
	Method *string `json:"method,omitempty"`

	// Specifies path matching options to match requests on.
	Path *HTTPRouteGatewayPath `json:"path,omitempty"`
}

// HTTPRouteGetOptions contains the optional parameters for the HTTPRoute.Get method.
type HTTPRouteGetOptions struct {
	// placeholder for future optional parameters
}

// HTTPRouteList - List of HttpRoute resources.
type HTTPRouteList struct {
	// REQUIRED; List of HttpRoute resources.
	Value []*HTTPRouteResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HTTPRouteList.
func (h HTTPRouteList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// HTTPRouteListOptions contains the optional parameters for the HTTPRoute.List method.
type HTTPRouteListOptions struct {
	// placeholder for future optional parameters
}

type HTTPRouteProperties struct {
	BasicRouteProperties
	// Specifies configuration to allow public traffic from outside the network to the route. Configure a gateway to accept traffic from the internet.
	Gateway *HTTPRouteGateway `json:"gateway,omitempty"`

	// The internal hostname accepting traffic for the route. Readonly.
	Hostname *float32 `json:"hostname,omitempty"`

	// The port number for the route. Defaults to 80.
	Port *float32 `json:"port,omitempty"`

	// The scheme used for traffic. Readonly.
	Scheme *float32 `json:"scheme,omitempty"`

	// A stable URL that that can be used to route traffic to a resource. Readonly.
	URL *float32 `json:"url,omitempty"`
}

// HTTPRouteResource - Resource that specifies an HTTP Route. An HTTP Route resource provides a stable URL that can be used to route internal or extrnal
// traffic to a resource.
type HTTPRouteResource struct {
	ProxyResource
	Properties *HTTPRouteProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HTTPRouteResource.
func (h HTTPRouteResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	h.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", h.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPRouteResource.
func (h *HTTPRouteResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, &h.Properties)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := h.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// HealthProbePropertiesClassification provides polymorphic access to related types.
// Call the interface's GetHealthProbeProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ExecHealthProbeProperties, *HealthProbeProperties, *HttpGetHealthProbeProperties, *TcpHealthProbeProperties
type HealthProbePropertiesClassification interface {
	// GetHealthProbeProperties returns the HealthProbeProperties content of the underlying type.
	GetHealthProbeProperties() *HealthProbeProperties
}

// HealthProbeProperties - Properties for readiness/liveness probe
type HealthProbeProperties struct {
	// REQUIRED; The HealthProbeProperties kind
	Kind *string `json:"kind,omitempty"`
}

// GetHealthProbeProperties implements the HealthProbePropertiesClassification interface for type HealthProbeProperties.
func (h *HealthProbeProperties) GetHealthProbeProperties() *HealthProbeProperties { return h }

// UnmarshalJSON implements the json.Unmarshaller interface for type HealthProbeProperties.
func (h *HealthProbeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return h.unmarshalInternal(rawMsg)
}

func (h HealthProbeProperties) marshalInternal(objectMap map[string]interface{}, discValue string) {
	h.Kind = &discValue
	objectMap["kind"] = h.Kind
}

func (h *HealthProbeProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, &h.Kind)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Identity for the resource.
type Identity struct {
	// The identity type.
	Type *string `json:"type,omitempty"`

	// READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

type KeyObjectProperties struct {
	// REQUIRED; The name of the key
	Name *string `json:"name,omitempty"`

	// File name when written to disk.
	Alias *string `json:"alias,omitempty"`

	// Key version
	Version *string `json:"version,omitempty"`
}

type KeyVaultProperties struct {
	// The client ID of the identity which will be used to access key vault.
	Identity *string `json:"identity,omitempty"`

	// Key vault uri to access the encryption key.
	KeyIdentifier *string `json:"keyIdentifier,omitempty"`
}

// LocationData - Metadata pertaining to the geographic location of the resource.
type LocationData struct {
	// REQUIRED; A canonical name for the geographic or physical location.
	Name *string `json:"name,omitempty"`

	// The city or locality where the resource is located.
	City *string `json:"city,omitempty"`

	// The country or region where the resource is located
	CountryOrRegion *string `json:"countryOrRegion,omitempty"`

	// The district, state, or province where the resource is located.
	District *string `json:"district,omitempty"`
}

// ManualScalingTrait - ManualScaling Trait
type ManualScalingTrait struct {
	ResourceTrait
	// Replica count.
	Replicas *int32 `json:"replicas,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManualScalingTrait.
func (m ManualScalingTrait) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ResourceTrait.marshalInternal(objectMap, "radius.dev/ManualScaling@v1alpha1")
	populate(objectMap, "replicas", m.Replicas)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManualScalingTrait.
func (m *ManualScalingTrait) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "replicas":
				err = unpopulate(val, &m.Replicas)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ResourceTrait.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MicrosoftComSQLDatabaseBeginCreateOrUpdateOptions contains the optional parameters for the MicrosoftComSQLDatabase.BeginCreateOrUpdate method.
type MicrosoftComSQLDatabaseBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// MicrosoftComSQLDatabaseBeginDeleteOptions contains the optional parameters for the MicrosoftComSQLDatabase.BeginDelete method.
type MicrosoftComSQLDatabaseBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// MicrosoftComSQLDatabaseGetOptions contains the optional parameters for the MicrosoftComSQLDatabase.Get method.
type MicrosoftComSQLDatabaseGetOptions struct {
	// placeholder for future optional parameters
}

// MicrosoftComSQLDatabaseListOptions contains the optional parameters for the MicrosoftComSQLDatabase.List method.
type MicrosoftComSQLDatabaseListOptions struct {
	// placeholder for future optional parameters
}

// MicrosoftSQLDatabaseList - List of microsoft.com.SQLDatabase resources.
type MicrosoftSQLDatabaseList struct {
	// REQUIRED; List of microsoft.com.SQLDatabase resources.
	Value []*MicrosoftSQLDatabaseResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftSQLDatabaseList.
func (m MicrosoftSQLDatabaseList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

type MicrosoftSQLDatabaseProperties struct {
	BasicResourceProperties
	// The name of the SQL database.
	Database *string `json:"database,omitempty"`

	// The ID of the SQL database to use for this resource.
	Resource *string `json:"resource,omitempty"`

	// The fully qualified domain name of the SQL database.
	Server *string `json:"server,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftSQLDatabaseProperties.
func (m MicrosoftSQLDatabaseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.BasicResourceProperties.marshalInternal(objectMap)
	populate(objectMap, "database", m.Database)
	populate(objectMap, "resource", m.Resource)
	populate(objectMap, "server", m.Server)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftSQLDatabaseProperties.
func (m *MicrosoftSQLDatabaseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "database":
				err = unpopulate(val, &m.Database)
				delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, &m.Resource)
				delete(rawMsg, key)
		case "server":
				err = unpopulate(val, &m.Server)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.BasicResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MicrosoftSQLDatabaseResource - Microsoft SQL compatible database.
type MicrosoftSQLDatabaseResource struct {
	ProxyResource
	// REQUIRED
	Properties *MicrosoftSQLDatabaseProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftSQLDatabaseResource.
func (m MicrosoftSQLDatabaseResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftSQLDatabaseResource.
func (m *MicrosoftSQLDatabaseResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, &m.Properties)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MongoComMongoDatabaseBeginCreateOrUpdateOptions contains the optional parameters for the MongoComMongoDatabase.BeginCreateOrUpdate method.
type MongoComMongoDatabaseBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// MongoComMongoDatabaseBeginDeleteOptions contains the optional parameters for the MongoComMongoDatabase.BeginDelete method.
type MongoComMongoDatabaseBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// MongoComMongoDatabaseGetOptions contains the optional parameters for the MongoComMongoDatabase.Get method.
type MongoComMongoDatabaseGetOptions struct {
	// placeholder for future optional parameters
}

// MongoComMongoDatabaseListOptions contains the optional parameters for the MongoComMongoDatabase.List method.
type MongoComMongoDatabaseListOptions struct {
	// placeholder for future optional parameters
}

type MongoDBResourceProperties struct {
	BasicResourceProperties
	// The host name of the MongoDB to which you are connecting
	Host *string `json:"host,omitempty"`

	// The port value of the MongoDB to which you are connecting
	Port *int32 `json:"port,omitempty"`

	// The ID of the DB with Mongo API to use for this resource.
	Resource *string `json:"resource,omitempty"`

	// Secrets provided by resources,
	Secrets *MongoDBResourcePropertiesSecrets `json:"secrets,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDBResourceProperties.
func (m MongoDBResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.BasicResourceProperties.marshalInternal(objectMap)
	populate(objectMap, "host", m.Host)
	populate(objectMap, "port", m.Port)
	populate(objectMap, "resource", m.Resource)
	populate(objectMap, "secrets", m.Secrets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDBResourceProperties.
func (m *MongoDBResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "host":
				err = unpopulate(val, &m.Host)
				delete(rawMsg, key)
		case "port":
				err = unpopulate(val, &m.Port)
				delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, &m.Resource)
				delete(rawMsg, key)
		case "secrets":
				err = unpopulate(val, &m.Secrets)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.BasicResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MongoDBResourcePropertiesSecrets - Secrets provided by resources,
type MongoDBResourcePropertiesSecrets struct {
	// The connection string used to connect to this DB
	ConnectionString *string `json:"connectionString,omitempty"`

	// The password for this MongoDB instance
	Password *string `json:"password,omitempty"`

	// The password for this MongoDB instance
	Username *string `json:"username,omitempty"`
}

// MongoDatabaseList - List of mongo.com.MongoDatabase resources.
type MongoDatabaseList struct {
	// REQUIRED; List of mongo.com.MongoDatabase resources.
	Value []*MongoDatabaseResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDatabaseList.
func (m MongoDatabaseList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// MongoDatabaseResource - The mongo database resource is a portable resource which can be deployed to any Radius platform.
type MongoDatabaseResource struct {
	ProxyResource
	Properties *MongoDBResourceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDatabaseResource.
func (m MongoDatabaseResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDatabaseResource.
func (m *MongoDatabaseResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, &m.Properties)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// Operation - Details of a REST API operation, returned from the Resource Provider Operations API
type Operation struct {
	// Localized display information for this particular operation.
	Display *OperationDisplay `json:"display,omitempty"`

	// READ-ONLY; Enum. Indicates the action type. "Internal" refers to actions that are for internal only APIs.
	ActionType *ActionType `json:"actionType,omitempty" azure:"ro"`

	// READ-ONLY; Whether the operation applies to data-plane. This is "true" for data-plane operations and "false" for ARM/control-plane operations.
	IsDataAction *bool `json:"isDataAction,omitempty" azure:"ro"`

	// READ-ONLY; The name of the operation, as per Resource-Based Access Control (RBAC). Examples: "Microsoft.Compute/virtualMachines/write", "Microsoft.Compute/virtualMachines/capture/action"
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The intended executor of the operation; as in Resource Based Access Control (RBAC) and audit logs UX. Default value is "user,system"
	Origin *Origin `json:"origin,omitempty" azure:"ro"`
}

// OperationDisplay - Localized display information for this particular operation.
type OperationDisplay struct {
	// READ-ONLY; The short, localized friendly description of the operation; suitable for tool tips and detailed views.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The concise, localized friendly name for the operation; suitable for dropdowns. E.g. "Create or Update Virtual Machine", "Restart Virtual
// Machine".
	Operation *string `json:"operation,omitempty" azure:"ro"`

	// READ-ONLY; The localized friendly form of the resource provider name, e.g. "Microsoft Monitoring Insights" or "Microsoft Compute".
	Provider *string `json:"provider,omitempty" azure:"ro"`

	// READ-ONLY; The localized friendly name of the resource type related to this operation. E.g. "Virtual Machines" or "Job Schedule Collections".
	Resource *string `json:"resource,omitempty" azure:"ro"`
}

// OperationListResult - A list of REST API operations supported by an Azure Resource Provider. It contains an URL link to get the next set of results.
type OperationListResult struct {
	// READ-ONLY; URL to get the next set of operation list results (if there are any).
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; List of operations supported by the resource provider
	Value []*Operation `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationStatusResult - The current status of an async operation.
type OperationStatusResult struct {
	// REQUIRED; Operation status.
	Status *string `json:"status,omitempty"`

	// The end time of the operation.
	EndTime *time.Time `json:"endTime,omitempty"`

	// If present, details of the operation error.
	Error *ErrorDetail `json:"error,omitempty"`

	// Fully qualified ID for the async operation.
	ID *string `json:"id,omitempty"`

	// Name of the async operation.
	Name *string `json:"name,omitempty"`

	// The operations list.
	Operations []*OperationStatusResult `json:"operations,omitempty"`

	// Percent of the operation that is complete.
	PercentComplete *float32 `json:"percentComplete,omitempty"`

	// The start time of the operation.
	StartTime *time.Time `json:"startTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationStatusResult.
func (o OperationStatusResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "endTime", (*timeRFC3339)(o.EndTime))
	populate(objectMap, "error", o.Error)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "operations", o.Operations)
	populate(objectMap, "percentComplete", o.PercentComplete)
	populate(objectMap, "startTime", (*timeRFC3339)(o.StartTime))
	populate(objectMap, "status", o.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationStatusResult.
func (o *OperationStatusResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				o.EndTime = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "error":
				err = unpopulate(val, &o.Error)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &o.ID)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &o.Name)
				delete(rawMsg, key)
		case "operations":
				err = unpopulate(val, &o.Operations)
				delete(rawMsg, key)
		case "percentComplete":
				err = unpopulate(val, &o.PercentComplete)
				delete(rawMsg, key)
		case "startTime":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				o.StartTime = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, &o.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PersistentVolume - Specifies a persistent volume for a container
type PersistentVolume struct {
	Volume
	// REQUIRED; The path where the volume is mounted
	MountPath *string `json:"mountPath,omitempty"`

	// REQUIRED; The source of the volume
	Source *string `json:"source,omitempty"`

	// Container read/write access to the volume
	Rbac *PersistentVolumeRbac `json:"rbac,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PersistentVolume.
func (p PersistentVolume) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.Volume.marshalInternal(objectMap, "persistent")
	populate(objectMap, "mountPath", p.MountPath)
	populate(objectMap, "rbac", p.Rbac)
	populate(objectMap, "source", p.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PersistentVolume.
func (p *PersistentVolume) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "mountPath":
				err = unpopulate(val, &p.MountPath)
				delete(rawMsg, key)
		case "rbac":
				err = unpopulate(val, &p.Rbac)
				delete(rawMsg, key)
		case "source":
				err = unpopulate(val, &p.Source)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.Volume.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// Plan for the resource.
type Plan struct {
	// REQUIRED; A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market
// onboarding.
	Product *string `json:"product,omitempty"`

	// REQUIRED; The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`

	// A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`

	// The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

// ProxyResource - The resource model definition for a Azure Resource Manager proxy resource. It will not have tags and a location
type ProxyResource struct {
	Resource
}

func (p ProxyResource) marshalInternal(objectMap map[string]interface{}) {
	p.Resource.marshalInternal(objectMap)
}

func (p *ProxyResource) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	if err := p.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// RabbitMQMessageQueueList - List of rabbitmq.com.MessageQueue resources.
type RabbitMQMessageQueueList struct {
	// REQUIRED; List of rabbitmq.com.MessageQueue resources.
	Value []*RabbitMQMessageQueueResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RabbitMQMessageQueueList.
func (r RabbitMQMessageQueueList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RabbitMQMessageQueueResource - The RabbitMQMessageQueue resource is a Kubernetes specific resource for message brokering.
type RabbitMQMessageQueueResource struct {
	ProxyResource
	// REQUIRED
	Properties *RabbitMQMessageQueueResourceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RabbitMQMessageQueueResource.
func (r RabbitMQMessageQueueResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RabbitMQMessageQueueResource.
func (r *RabbitMQMessageQueueResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, &r.Properties)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type RabbitMQMessageQueueResourceProperties struct {
	BasicResourceProperties
	// REQUIRED; The name of the queue
	Queue *string `json:"queue,omitempty"`

	// Secrets provided by resources,
	Secrets *RabbitMQMessageQueueResourcePropertiesSecrets `json:"secrets,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RabbitMQMessageQueueResourceProperties.
func (r RabbitMQMessageQueueResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.BasicResourceProperties.marshalInternal(objectMap)
	populate(objectMap, "queue", r.Queue)
	populate(objectMap, "secrets", r.Secrets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RabbitMQMessageQueueResourceProperties.
func (r *RabbitMQMessageQueueResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "queue":
				err = unpopulate(val, &r.Queue)
				delete(rawMsg, key)
		case "secrets":
				err = unpopulate(val, &r.Secrets)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.BasicResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// RabbitMQMessageQueueResourcePropertiesSecrets - Secrets provided by resources,
type RabbitMQMessageQueueResourcePropertiesSecrets struct {
	// The connection string used to connect to this RabbitMQ instance
	ConnectionString *string `json:"connectionString,omitempty"`
}

// RabbitmqComMessageQueueBeginCreateOrUpdateOptions contains the optional parameters for the RabbitmqComMessageQueue.BeginCreateOrUpdate method.
type RabbitmqComMessageQueueBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// RabbitmqComMessageQueueBeginDeleteOptions contains the optional parameters for the RabbitmqComMessageQueue.BeginDelete method.
type RabbitmqComMessageQueueBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// RabbitmqComMessageQueueGetOptions contains the optional parameters for the RabbitmqComMessageQueue.Get method.
type RabbitmqComMessageQueueGetOptions struct {
	// placeholder for future optional parameters
}

// RabbitmqComMessageQueueListOptions contains the optional parameters for the RabbitmqComMessageQueue.List method.
type RabbitmqComMessageQueueListOptions struct {
	// placeholder for future optional parameters
}

// RadiusResource - Interface for generic resource -- useful for listing resources without specifying a type
type RadiusResource struct {
	ProxyResource
	// REQUIRED; Any object
	Properties map[string]interface{} `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RadiusResource.
func (r RadiusResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RadiusResource.
func (r *RadiusResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, &r.Properties)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// RadiusResourceBeginDeleteOptions contains the optional parameters for the RadiusResource.BeginDelete method.
type RadiusResourceBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// RadiusResourceGetOptions contains the optional parameters for the RadiusResource.Get method.
type RadiusResourceGetOptions struct {
	// placeholder for future optional parameters
}

// RadiusResourceList - List of RadiusResource resources.
type RadiusResourceList struct {
	// REQUIRED; List of RadiusResource resources.
	Value []*RadiusResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RadiusResourceList.
func (r RadiusResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RadiusResourceListOptions contains the optional parameters for the RadiusResource.List method.
type RadiusResourceListOptions struct {
	// placeholder for future optional parameters
}

// RedisCacheList - List of redislabs.com.RedisCache resources.
type RedisCacheList struct {
	// REQUIRED; List of redislabs.com.RedisCache resources.
	Value []*RedisCacheResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RedisCacheList.
func (r RedisCacheList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RedisCacheResource - The RedisCache resource is a portable resource which can be deployed to any Radius platform.
type RedisCacheResource struct {
	ProxyResource
	// REQUIRED
	Properties *RedisCacheResourceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RedisCacheResource.
func (r RedisCacheResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RedisCacheResource.
func (r *RedisCacheResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, &r.Properties)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type RedisCacheResourceProperties struct {
	BasicResourceProperties
	// The host name of the redis cache to which you are connecting
	Host *string `json:"host,omitempty"`

	// The port value of the redis cache to which you are connecting
	Port *int32 `json:"port,omitempty"`

	// The ID of the Redis cache to use for this resource
	Resource *string `json:"resource,omitempty"`
	Secrets *RedisCacheResourcePropertiesSecrets `json:"secrets,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RedisCacheResourceProperties.
func (r RedisCacheResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.BasicResourceProperties.marshalInternal(objectMap)
	populate(objectMap, "host", r.Host)
	populate(objectMap, "port", r.Port)
	populate(objectMap, "resource", r.Resource)
	populate(objectMap, "secrets", r.Secrets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RedisCacheResourceProperties.
func (r *RedisCacheResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "host":
				err = unpopulate(val, &r.Host)
				delete(rawMsg, key)
		case "port":
				err = unpopulate(val, &r.Port)
				delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, &r.Resource)
				delete(rawMsg, key)
		case "secrets":
				err = unpopulate(val, &r.Secrets)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := r.BasicResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type RedisCacheResourcePropertiesSecrets struct {
	// The Redis connection string used to connect to the redis cache
	ConnectionString *string `json:"connectionString,omitempty"`

	// The password for this Redis instance
	Password *string `json:"password,omitempty"`
}

// RedislabsComRedisCacheBeginCreateOrUpdateOptions contains the optional parameters for the RedislabsComRedisCache.BeginCreateOrUpdate method.
type RedislabsComRedisCacheBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// RedislabsComRedisCacheBeginDeleteOptions contains the optional parameters for the RedislabsComRedisCache.BeginDelete method.
type RedislabsComRedisCacheBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// RedislabsComRedisCacheGetOptions contains the optional parameters for the RedislabsComRedisCache.Get method.
type RedislabsComRedisCacheGetOptions struct {
	// placeholder for future optional parameters
}

// RedislabsComRedisCacheListOptions contains the optional parameters for the RedislabsComRedisCache.List method.
type RedislabsComRedisCacheListOptions struct {
	// placeholder for future optional parameters
}

// Resource - Common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// Status of an application.
	Status *ResourceStatus `json:"status,omitempty"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Resource.
func (r *Resource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "status", r.Status)
	populate(objectMap, "type", r.Type)
}

func (r *Resource) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, &r.ID)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &r.Name)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, &r.Status)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &r.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ResourceModelWithAllowedPropertySet - The resource model definition containing the full set of allowed properties for a resource. Except properties bag,
// there cannot be a top level property outside of this set.
type ResourceModelWithAllowedPropertySet struct {
	Identity *ResourceModelWithAllowedPropertySetIdentity `json:"identity,omitempty"`

	// Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites
// type. If supported, the resource provider must
// validate and persist this value.
	Kind *string `json:"kind,omitempty"`

	// The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// The fully qualified resource ID of the resource that manages this resource. Indicates if this resource is managed by another Azure resource. If this
// is present, complete mode deployment will not
// delete the resource if it is removed from the template since it is managed by another resource.
	ManagedBy *string `json:"managedBy,omitempty"`
	Plan *ResourceModelWithAllowedPropertySetPlan `json:"plan,omitempty"`
	SKU *ResourceModelWithAllowedPropertySetSKU `json:"sku,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The etag field is not required. If it is provided in the response body, it must also be provided as a header per the normal etag convention.
// Entity tags are used for comparing two or more entities
// from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and
// If-Range (section 14.27) header fields.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceModelWithAllowedPropertySet.
func (r ResourceModelWithAllowedPropertySet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", r.Etag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "identity", r.Identity)
	populate(objectMap, "kind", r.Kind)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "managedBy", r.ManagedBy)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "plan", r.Plan)
	populate(objectMap, "sku", r.SKU)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

type ResourceModelWithAllowedPropertySetIdentity struct {
	Identity
}

type ResourceModelWithAllowedPropertySetPlan struct {
	Plan
}

type ResourceModelWithAllowedPropertySetSKU struct {
	SKU
}

// ResourceStatus - Status of an application.
type ResourceStatus struct {
	// Health errors for the application
	HealthErrorDetails *string `json:"healthErrorDetails,omitempty"`

	// Health state of the application
	HealthState *string `json:"healthState,omitempty"`

	// Provisioning errors for the application
	ProvisioningErrorDetails *string `json:"provisioningErrorDetails,omitempty"`

	// Provisioning state of the application
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// ResourceStatusAutoGenerated - Status of a resource.
type ResourceStatusAutoGenerated struct {
	// Health errors for the resource
	HealthErrorDetails *string `json:"healthErrorDetails,omitempty"`

	// Health state of the resource
	HealthState *string `json:"healthState,omitempty"`
	OutputResources []map[string]interface{} `json:"outputResources,omitempty"`

	// Provisioning errors for the resource
	ProvisioningErrorDetails *string `json:"provisioningErrorDetails,omitempty"`

	// Provisioning state of the resource
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceStatusAutoGenerated.
func (r ResourceStatusAutoGenerated) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "healthErrorDetails", r.HealthErrorDetails)
	populate(objectMap, "healthState", r.HealthState)
	populate(objectMap, "outputResources", r.OutputResources)
	populate(objectMap, "provisioningErrorDetails", r.ProvisioningErrorDetails)
	populate(objectMap, "provisioningState", r.ProvisioningState)
	return json.Marshal(objectMap)
}

// ResourceTraitClassification provides polymorphic access to related types.
// Call the interface's GetResourceTrait() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DaprSidecarTrait, *ManualScalingTrait, *ResourceTrait
type ResourceTraitClassification interface {
	// GetResourceTrait returns the ResourceTrait content of the underlying type.
	GetResourceTrait() *ResourceTrait
}

// ResourceTrait - Trait of a resource.
type ResourceTrait struct {
	// REQUIRED; The ResourceTrait kind
	Kind *string `json:"kind,omitempty"`
}

// GetResourceTrait implements the ResourceTraitClassification interface for type ResourceTrait.
func (r *ResourceTrait) GetResourceTrait() *ResourceTrait { return r }

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceTrait.
func (r *ResourceTrait) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r ResourceTrait) marshalInternal(objectMap map[string]interface{}, discValue string) {
	r.Kind = &discValue
	objectMap["kind"] = r.Kind
}

func (r *ResourceTrait) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, &r.Kind)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RouteStatus - Status of a route.
type RouteStatus struct {
	// Health state of the route
	HealthState *string `json:"healthState,omitempty"`
	OutputResources []map[string]interface{} `json:"outputResources,omitempty"`

	// Provisioning state of the route
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RouteStatus.
func (r RouteStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "healthState", r.HealthState)
	populate(objectMap, "outputResources", r.OutputResources)
	populate(objectMap, "provisioningState", r.ProvisioningState)
	return json.Marshal(objectMap)
}

// SKU - The resource model definition representing SKU
type SKU struct {
	// REQUIRED; The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`

	// If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`

	// If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`

	// The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`

	// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
	Tier *SKUTier `json:"tier,omitempty"`
}

type SecretObjectProperties struct {
	// REQUIRED; The name of the secret
	Name *string `json:"name,omitempty"`

	// File name when written to disk.
	Alias *string `json:"alias,omitempty"`

	// Encoding format. Default utf-8
	Encoding *SecretObjectPropertiesEncoding `json:"encoding,omitempty"`

	// Secret version
	Version *string `json:"version,omitempty"`
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *CreatedByType `json:"createdByType,omitempty"`

	// The timestamp of resource last modification (UTC)
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *CreatedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "createdAt", (*timeRFC3339)(s.CreatedAt))
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populate(objectMap, "lastModifiedAt", (*timeRFC3339)(s.LastModifiedAt))
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				s.CreatedAt = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "createdBy":
				err = unpopulate(val, &s.CreatedBy)
				delete(rawMsg, key)
		case "createdByType":
				err = unpopulate(val, &s.CreatedByType)
				delete(rawMsg, key)
		case "lastModifiedAt":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				s.LastModifiedAt = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "lastModifiedBy":
				err = unpopulate(val, &s.LastModifiedBy)
				delete(rawMsg, key)
		case "lastModifiedByType":
				err = unpopulate(val, &s.LastModifiedByType)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TCPHealthProbeProperties - Specifies the properties for readiness/liveness probe using TCP
type TCPHealthProbeProperties struct {
	HealthProbeProperties
	// REQUIRED; The listening port number
	ContainerPort *int32 `json:"containerPort,omitempty"`

	// Threshold number of times the probe fails after which a failure would be reported
	FailureThreshold *float32 `json:"failureThreshold,omitempty"`

	// Initial delay in seconds before probing for readiness/liveness
	InitialDelaySeconds *float32 `json:"initialDelaySeconds,omitempty"`

	// Interval for the readiness/liveness probe in seconds
	PeriodSeconds *float32 `json:"periodSeconds,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TCPHealthProbeProperties.
func (t TCPHealthProbeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.HealthProbeProperties.marshalInternal(objectMap, "tcp")
	populate(objectMap, "containerPort", t.ContainerPort)
	populate(objectMap, "failureThreshold", t.FailureThreshold)
	populate(objectMap, "initialDelaySeconds", t.InitialDelaySeconds)
	populate(objectMap, "periodSeconds", t.PeriodSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TCPHealthProbeProperties.
func (t *TCPHealthProbeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerPort":
				err = unpopulate(val, &t.ContainerPort)
				delete(rawMsg, key)
		case "failureThreshold":
				err = unpopulate(val, &t.FailureThreshold)
				delete(rawMsg, key)
		case "initialDelaySeconds":
				err = unpopulate(val, &t.InitialDelaySeconds)
				delete(rawMsg, key)
		case "periodSeconds":
				err = unpopulate(val, &t.PeriodSeconds)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := t.HealthProbeProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// TrackedResource - The resource model definition for an Azure Resource Manager tracked top level resource which has 'tags' and a 'location'
type TrackedResource struct {
	Resource
	// The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TrackedResource.
func (t *TrackedResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return t.unmarshalInternal(rawMsg)
}

func (t TrackedResource) marshalInternal(objectMap map[string]interface{}) {
	t.Resource.marshalInternal(objectMap)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "tags", t.Tags)
}

func (t *TrackedResource) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
				err = unpopulate(val, &t.Location)
				delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, &t.Tags)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := t.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// VolumeClassification provides polymorphic access to related types.
// Call the interface's GetVolume() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *EphemeralVolume, *PersistentVolume, *Volume
type VolumeClassification interface {
	// GetVolume returns the Volume content of the underlying type.
	GetVolume() *Volume
}

// Volume - Specifies a volume for a container
type Volume struct {
	// REQUIRED; The Volume kind
	Kind *string `json:"kind,omitempty"`
}

// GetVolume implements the VolumeClassification interface for type Volume.
func (v *Volume) GetVolume() *Volume { return v }

// UnmarshalJSON implements the json.Unmarshaller interface for type Volume.
func (v *Volume) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return v.unmarshalInternal(rawMsg)
}

func (v Volume) marshalInternal(objectMap map[string]interface{}, discValue string) {
	v.Kind = &discValue
	objectMap["kind"] = v.Kind
}

func (v *Volume) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, &v.Kind)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VolumeBeginCreateOrUpdateOptions contains the optional parameters for the Volume.BeginCreateOrUpdate method.
type VolumeBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// VolumeBeginDeleteOptions contains the optional parameters for the Volume.BeginDelete method.
type VolumeBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// VolumeGetOptions contains the optional parameters for the Volume.Get method.
type VolumeGetOptions struct {
	// placeholder for future optional parameters
}

// VolumeList - List of Volume resources.
type VolumeList struct {
	// REQUIRED; List of Volume resources.
	Value []*VolumeResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VolumeList.
func (v VolumeList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// VolumeListOptions contains the optional parameters for the Volume.List method.
type VolumeListOptions struct {
	// placeholder for future optional parameters
}

// VolumePropertiesClassification provides polymorphic access to related types.
// Call the interface's GetVolumeProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AzureFileShareVolumeProperties, *AzureKeyVaultVolumeProperties, *VolumeProperties
type VolumePropertiesClassification interface {
	// GetVolumeProperties returns the VolumeProperties content of the underlying type.
	GetVolumeProperties() *VolumeProperties
}

type VolumeProperties struct {
	BasicResourceProperties
	// REQUIRED; The VolumeProperties kind
	Kind *string `json:"kind,omitempty"`
}

// GetVolumeProperties implements the VolumePropertiesClassification interface for type VolumeProperties.
func (v *VolumeProperties) GetVolumeProperties() *VolumeProperties { return v }

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeProperties.
func (v *VolumeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return v.unmarshalInternal(rawMsg)
}

func (v VolumeProperties) marshalInternal(objectMap map[string]interface{}, discValue string) {
	v.BasicResourceProperties.marshalInternal(objectMap)
	v.Kind = &discValue
	objectMap["kind"] = v.Kind
}

func (v *VolumeProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, &v.Kind)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.BasicResourceProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// VolumeResource - The Volume provides an abstraction for a volume that can be mounted to a container
type VolumeResource struct {
	ProxyResource
	// REQUIRED
	Properties VolumePropertiesClassification `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VolumeResource.
func (v VolumeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.ProxyResource.marshalInternal(objectMap)
	populate(objectMap, "properties", v.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeResource.
func (v *VolumeResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				v.Properties, err = unmarshalVolumePropertiesClassification(val)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.ProxyResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}

