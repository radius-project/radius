//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package radclient

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// ApplicationCreateOrUpdatePollerResponse contains the response from method Application.CreateOrUpdate.
type ApplicationCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l ApplicationCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationCreateOrUpdateResponse, error) {
	respType := ApplicationCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ApplicationResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ApplicationCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ApplicationClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("ApplicationClient.CreateOrUpdate", token, 	client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationCreateOrUpdatePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationCreateOrUpdateResponse contains the response from method Application.CreateOrUpdate.
type ApplicationCreateOrUpdateResponse struct {
	ApplicationCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationCreateOrUpdateResult contains the result from method Application.CreateOrUpdate.
type ApplicationCreateOrUpdateResult struct {
	ApplicationResource
}

// ApplicationDeletePollerResponse contains the response from method Application.Delete.
type ApplicationDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l ApplicationDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationDeleteResponse, error) {
	respType := ApplicationDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationDeletePollerResponse from the provided client and resume token.
func (l *ApplicationDeletePollerResponse) Resume(ctx context.Context, client *ApplicationClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("ApplicationClient.Delete", token, 	client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ApplicationDeletePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationDeleteResponse contains the response from method Application.Delete.
type ApplicationDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGetResponse contains the response from method Application.Get.
type ApplicationGetResponse struct {
	ApplicationGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGetResult contains the result from method Application.Get.
type ApplicationGetResult struct {
	ApplicationResource
}

// ApplicationListResponse contains the response from method Application.List.
type ApplicationListResponse struct {
	ApplicationListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationListResult contains the result from method Application.List.
type ApplicationListResult struct {
	ApplicationList
}

// AzureComKeyVaultCreateOrUpdatePollerResponse contains the response from method AzureComKeyVault.CreateOrUpdate.
type AzureComKeyVaultCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AzureComKeyVaultCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l AzureComKeyVaultCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AzureComKeyVaultCreateOrUpdateResponse, error) {
	respType := AzureComKeyVaultCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AzureKeyVaultResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AzureComKeyVaultCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *AzureComKeyVaultCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *AzureComKeyVaultClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("AzureComKeyVaultClient.CreateOrUpdate", token, 	client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &AzureComKeyVaultCreateOrUpdatePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AzureComKeyVaultCreateOrUpdateResponse contains the response from method AzureComKeyVault.CreateOrUpdate.
type AzureComKeyVaultCreateOrUpdateResponse struct {
	AzureComKeyVaultCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureComKeyVaultCreateOrUpdateResult contains the result from method AzureComKeyVault.CreateOrUpdate.
type AzureComKeyVaultCreateOrUpdateResult struct {
	AzureKeyVaultResource
}

// AzureComKeyVaultDeletePollerResponse contains the response from method AzureComKeyVault.Delete.
type AzureComKeyVaultDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AzureComKeyVaultDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l AzureComKeyVaultDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AzureComKeyVaultDeleteResponse, error) {
	respType := AzureComKeyVaultDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AzureComKeyVaultDeletePollerResponse from the provided client and resume token.
func (l *AzureComKeyVaultDeletePollerResponse) Resume(ctx context.Context, client *AzureComKeyVaultClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("AzureComKeyVaultClient.Delete", token, 	client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &AzureComKeyVaultDeletePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AzureComKeyVaultDeleteResponse contains the response from method AzureComKeyVault.Delete.
type AzureComKeyVaultDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureComKeyVaultGetResponse contains the response from method AzureComKeyVault.Get.
type AzureComKeyVaultGetResponse struct {
	AzureComKeyVaultGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureComKeyVaultGetResult contains the result from method AzureComKeyVault.Get.
type AzureComKeyVaultGetResult struct {
	AzureKeyVaultResource
}

// AzureComKeyVaultListResponse contains the response from method AzureComKeyVault.List.
type AzureComKeyVaultListResponse struct {
	AzureComKeyVaultListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureComKeyVaultListResult contains the result from method AzureComKeyVault.List.
type AzureComKeyVaultListResult struct {
	AzureKeyVaultList
}

// AzureComServiceBusQueueCreateOrUpdatePollerResponse contains the response from method AzureComServiceBusQueue.CreateOrUpdate.
type AzureComServiceBusQueueCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AzureComServiceBusQueueCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l AzureComServiceBusQueueCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AzureComServiceBusQueueCreateOrUpdateResponse, error) {
	respType := AzureComServiceBusQueueCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AzureServiceBusResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AzureComServiceBusQueueCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *AzureComServiceBusQueueCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *AzureComServiceBusQueueClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("AzureComServiceBusQueueClient.CreateOrUpdate", token, 	client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &AzureComServiceBusQueueCreateOrUpdatePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AzureComServiceBusQueueCreateOrUpdateResponse contains the response from method AzureComServiceBusQueue.CreateOrUpdate.
type AzureComServiceBusQueueCreateOrUpdateResponse struct {
	AzureComServiceBusQueueCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureComServiceBusQueueCreateOrUpdateResult contains the result from method AzureComServiceBusQueue.CreateOrUpdate.
type AzureComServiceBusQueueCreateOrUpdateResult struct {
	AzureServiceBusResource
}

// AzureComServiceBusQueueDeletePollerResponse contains the response from method AzureComServiceBusQueue.Delete.
type AzureComServiceBusQueueDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AzureComServiceBusQueueDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l AzureComServiceBusQueueDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AzureComServiceBusQueueDeleteResponse, error) {
	respType := AzureComServiceBusQueueDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AzureComServiceBusQueueDeletePollerResponse from the provided client and resume token.
func (l *AzureComServiceBusQueueDeletePollerResponse) Resume(ctx context.Context, client *AzureComServiceBusQueueClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("AzureComServiceBusQueueClient.Delete", token, 	client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &AzureComServiceBusQueueDeletePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AzureComServiceBusQueueDeleteResponse contains the response from method AzureComServiceBusQueue.Delete.
type AzureComServiceBusQueueDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureComServiceBusQueueGetResponse contains the response from method AzureComServiceBusQueue.Get.
type AzureComServiceBusQueueGetResponse struct {
	AzureComServiceBusQueueGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureComServiceBusQueueGetResult contains the result from method AzureComServiceBusQueue.Get.
type AzureComServiceBusQueueGetResult struct {
	AzureServiceBusResource
}

// AzureComServiceBusQueueListResponse contains the response from method AzureComServiceBusQueue.List.
type AzureComServiceBusQueueListResponse struct {
	AzureComServiceBusQueueListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureComServiceBusQueueListResult contains the result from method AzureComServiceBusQueue.List.
type AzureComServiceBusQueueListResult struct {
	AzureServiceBusList
}

// ContainerCreateOrUpdatePollerResponse contains the response from method Container.CreateOrUpdate.
type ContainerCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ContainerCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l ContainerCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ContainerCreateOrUpdateResponse, error) {
	respType := ContainerCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ContainerResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ContainerCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ContainerCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ContainerClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("ContainerClient.CreateOrUpdate", token, 	client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &ContainerCreateOrUpdatePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ContainerCreateOrUpdateResponse contains the response from method Container.CreateOrUpdate.
type ContainerCreateOrUpdateResponse struct {
	ContainerCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ContainerCreateOrUpdateResult contains the result from method Container.CreateOrUpdate.
type ContainerCreateOrUpdateResult struct {
	ContainerResource
}

// ContainerDeletePollerResponse contains the response from method Container.Delete.
type ContainerDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ContainerDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l ContainerDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ContainerDeleteResponse, error) {
	respType := ContainerDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ContainerDeletePollerResponse from the provided client and resume token.
func (l *ContainerDeletePollerResponse) Resume(ctx context.Context, client *ContainerClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("ContainerClient.Delete", token, 	client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &ContainerDeletePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ContainerDeleteResponse contains the response from method Container.Delete.
type ContainerDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ContainerGetResponse contains the response from method Container.Get.
type ContainerGetResponse struct {
	ContainerGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ContainerGetResult contains the result from method Container.Get.
type ContainerGetResult struct {
	ContainerResource
}

// ContainerListResponse contains the response from method Container.List.
type ContainerListResponse struct {
	ContainerListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ContainerListResult contains the result from method Container.List.
type ContainerListResult struct {
	ContainerList
}

// DaprIoInvokeHTTPRouteCreateOrUpdatePollerResponse contains the response from method DaprIoInvokeHTTPRoute.CreateOrUpdate.
type DaprIoInvokeHTTPRouteCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DaprIoInvokeHTTPRouteCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DaprIoInvokeHTTPRouteCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DaprIoInvokeHTTPRouteCreateOrUpdateResponse, error) {
	respType := DaprIoInvokeHTTPRouteCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DaprInvokeHTTPRouteResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DaprIoInvokeHTTPRouteCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DaprIoInvokeHTTPRouteCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DaprIoInvokeHTTPRouteClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("DaprIoInvokeHTTPRouteClient.CreateOrUpdate", token, 	client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DaprIoInvokeHTTPRouteCreateOrUpdatePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DaprIoInvokeHTTPRouteCreateOrUpdateResponse contains the response from method DaprIoInvokeHTTPRoute.CreateOrUpdate.
type DaprIoInvokeHTTPRouteCreateOrUpdateResponse struct {
	DaprIoInvokeHTTPRouteCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DaprIoInvokeHTTPRouteCreateOrUpdateResult contains the result from method DaprIoInvokeHTTPRoute.CreateOrUpdate.
type DaprIoInvokeHTTPRouteCreateOrUpdateResult struct {
	DaprInvokeHTTPRouteResource
}

// DaprIoInvokeHTTPRouteDeletePollerResponse contains the response from method DaprIoInvokeHTTPRoute.Delete.
type DaprIoInvokeHTTPRouteDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DaprIoInvokeHTTPRouteDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DaprIoInvokeHTTPRouteDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DaprIoInvokeHTTPRouteDeleteResponse, error) {
	respType := DaprIoInvokeHTTPRouteDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DaprIoInvokeHTTPRouteDeletePollerResponse from the provided client and resume token.
func (l *DaprIoInvokeHTTPRouteDeletePollerResponse) Resume(ctx context.Context, client *DaprIoInvokeHTTPRouteClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("DaprIoInvokeHTTPRouteClient.Delete", token, 	client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DaprIoInvokeHTTPRouteDeletePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DaprIoInvokeHTTPRouteDeleteResponse contains the response from method DaprIoInvokeHTTPRoute.Delete.
type DaprIoInvokeHTTPRouteDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DaprIoInvokeHTTPRouteGetResponse contains the response from method DaprIoInvokeHTTPRoute.Get.
type DaprIoInvokeHTTPRouteGetResponse struct {
	DaprIoInvokeHTTPRouteGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DaprIoInvokeHTTPRouteGetResult contains the result from method DaprIoInvokeHTTPRoute.Get.
type DaprIoInvokeHTTPRouteGetResult struct {
	DaprInvokeHTTPRouteResource
}

// DaprIoInvokeHTTPRouteListResponse contains the response from method DaprIoInvokeHTTPRoute.List.
type DaprIoInvokeHTTPRouteListResponse struct {
	DaprIoInvokeHTTPRouteListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DaprIoInvokeHTTPRouteListResult contains the result from method DaprIoInvokeHTTPRoute.List.
type DaprIoInvokeHTTPRouteListResult struct {
	DaprInvokeHTTPRouteList
}

// DaprIoPubSubTopicCreateOrUpdatePollerResponse contains the response from method DaprIoPubSubTopic.CreateOrUpdate.
type DaprIoPubSubTopicCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DaprIoPubSubTopicCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DaprIoPubSubTopicCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DaprIoPubSubTopicCreateOrUpdateResponse, error) {
	respType := DaprIoPubSubTopicCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DaprPubSubTopicResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DaprIoPubSubTopicCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DaprIoPubSubTopicCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DaprIoPubSubTopicClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("DaprIoPubSubTopicClient.CreateOrUpdate", token, 	client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DaprIoPubSubTopicCreateOrUpdatePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DaprIoPubSubTopicCreateOrUpdateResponse contains the response from method DaprIoPubSubTopic.CreateOrUpdate.
type DaprIoPubSubTopicCreateOrUpdateResponse struct {
	DaprIoPubSubTopicCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DaprIoPubSubTopicCreateOrUpdateResult contains the result from method DaprIoPubSubTopic.CreateOrUpdate.
type DaprIoPubSubTopicCreateOrUpdateResult struct {
	DaprPubSubTopicResource
}

// DaprIoPubSubTopicDeletePollerResponse contains the response from method DaprIoPubSubTopic.Delete.
type DaprIoPubSubTopicDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DaprIoPubSubTopicDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DaprIoPubSubTopicDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DaprIoPubSubTopicDeleteResponse, error) {
	respType := DaprIoPubSubTopicDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DaprIoPubSubTopicDeletePollerResponse from the provided client and resume token.
func (l *DaprIoPubSubTopicDeletePollerResponse) Resume(ctx context.Context, client *DaprIoPubSubTopicClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("DaprIoPubSubTopicClient.Delete", token, 	client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DaprIoPubSubTopicDeletePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DaprIoPubSubTopicDeleteResponse contains the response from method DaprIoPubSubTopic.Delete.
type DaprIoPubSubTopicDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DaprIoPubSubTopicGetResponse contains the response from method DaprIoPubSubTopic.Get.
type DaprIoPubSubTopicGetResponse struct {
	DaprIoPubSubTopicGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DaprIoPubSubTopicGetResult contains the result from method DaprIoPubSubTopic.Get.
type DaprIoPubSubTopicGetResult struct {
	DaprPubSubTopicResource
}

// DaprIoPubSubTopicListResponse contains the response from method DaprIoPubSubTopic.List.
type DaprIoPubSubTopicListResponse struct {
	DaprIoPubSubTopicListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DaprIoPubSubTopicListResult contains the result from method DaprIoPubSubTopic.List.
type DaprIoPubSubTopicListResult struct {
	DaprPubSubTopicList
}

// DaprIoStateStoreCreateOrUpdatePollerResponse contains the response from method DaprIoStateStore.CreateOrUpdate.
type DaprIoStateStoreCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DaprIoStateStoreCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DaprIoStateStoreCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DaprIoStateStoreCreateOrUpdateResponse, error) {
	respType := DaprIoStateStoreCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DaprStateStoreResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DaprIoStateStoreCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DaprIoStateStoreCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DaprIoStateStoreClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("DaprIoStateStoreClient.CreateOrUpdate", token, 	client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &DaprIoStateStoreCreateOrUpdatePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DaprIoStateStoreCreateOrUpdateResponse contains the response from method DaprIoStateStore.CreateOrUpdate.
type DaprIoStateStoreCreateOrUpdateResponse struct {
	DaprIoStateStoreCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DaprIoStateStoreCreateOrUpdateResult contains the result from method DaprIoStateStore.CreateOrUpdate.
type DaprIoStateStoreCreateOrUpdateResult struct {
	DaprStateStoreResource
}

// DaprIoStateStoreDeletePollerResponse contains the response from method DaprIoStateStore.Delete.
type DaprIoStateStoreDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DaprIoStateStoreDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DaprIoStateStoreDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DaprIoStateStoreDeleteResponse, error) {
	respType := DaprIoStateStoreDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DaprIoStateStoreDeletePollerResponse from the provided client and resume token.
func (l *DaprIoStateStoreDeletePollerResponse) Resume(ctx context.Context, client *DaprIoStateStoreClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("DaprIoStateStoreClient.Delete", token, 	client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &DaprIoStateStoreDeletePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DaprIoStateStoreDeleteResponse contains the response from method DaprIoStateStore.Delete.
type DaprIoStateStoreDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DaprIoStateStoreGetResponse contains the response from method DaprIoStateStore.Get.
type DaprIoStateStoreGetResponse struct {
	DaprIoStateStoreGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DaprIoStateStoreGetResult contains the result from method DaprIoStateStore.Get.
type DaprIoStateStoreGetResult struct {
	DaprStateStoreResource
}

// DaprIoStateStoreListResponse contains the response from method DaprIoStateStore.List.
type DaprIoStateStoreListResponse struct {
	DaprIoStateStoreListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DaprIoStateStoreListResult contains the result from method DaprIoStateStore.List.
type DaprIoStateStoreListResult struct {
	DaprStateStoreList
}

// GatewayCreateOrUpdatePollerResponse contains the response from method Gateway.CreateOrUpdate.
type GatewayCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GatewayCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l GatewayCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GatewayCreateOrUpdateResponse, error) {
	respType := GatewayCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GatewayResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GatewayCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *GatewayCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *GatewayClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("GatewayClient.CreateOrUpdate", token, 	client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &GatewayCreateOrUpdatePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GatewayCreateOrUpdateResponse contains the response from method Gateway.CreateOrUpdate.
type GatewayCreateOrUpdateResponse struct {
	GatewayCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewayCreateOrUpdateResult contains the result from method Gateway.CreateOrUpdate.
type GatewayCreateOrUpdateResult struct {
	GatewayResource
}

// GatewayDeletePollerResponse contains the response from method Gateway.Delete.
type GatewayDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GatewayDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l GatewayDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GatewayDeleteResponse, error) {
	respType := GatewayDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GatewayDeletePollerResponse from the provided client and resume token.
func (l *GatewayDeletePollerResponse) Resume(ctx context.Context, client *GatewayClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("GatewayClient.Delete", token, 	client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &GatewayDeletePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GatewayDeleteResponse contains the response from method Gateway.Delete.
type GatewayDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewayGetResponse contains the response from method Gateway.Get.
type GatewayGetResponse struct {
	GatewayGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewayGetResult contains the result from method Gateway.Get.
type GatewayGetResult struct {
	GatewayResource
}

// GatewayListResponse contains the response from method Gateway.List.
type GatewayListResponse struct {
	GatewayListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GatewayListResult contains the result from method Gateway.List.
type GatewayListResult struct {
	GatewayList
}

// HTTPRouteCreateOrUpdatePollerResponse contains the response from method HTTPRoute.CreateOrUpdate.
type HTTPRouteCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *HTTPRouteCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l HTTPRouteCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (HTTPRouteCreateOrUpdateResponse, error) {
	respType := HTTPRouteCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.HTTPRouteResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a HTTPRouteCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *HTTPRouteCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *HTTPRouteClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("HTTPRouteClient.CreateOrUpdate", token, 	client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &HTTPRouteCreateOrUpdatePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// HTTPRouteCreateOrUpdateResponse contains the response from method HTTPRoute.CreateOrUpdate.
type HTTPRouteCreateOrUpdateResponse struct {
	HTTPRouteCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HTTPRouteCreateOrUpdateResult contains the result from method HTTPRoute.CreateOrUpdate.
type HTTPRouteCreateOrUpdateResult struct {
	HTTPRouteResource
}

// HTTPRouteDeletePollerResponse contains the response from method HTTPRoute.Delete.
type HTTPRouteDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *HTTPRouteDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l HTTPRouteDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (HTTPRouteDeleteResponse, error) {
	respType := HTTPRouteDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a HTTPRouteDeletePollerResponse from the provided client and resume token.
func (l *HTTPRouteDeletePollerResponse) Resume(ctx context.Context, client *HTTPRouteClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("HTTPRouteClient.Delete", token, 	client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &HTTPRouteDeletePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// HTTPRouteDeleteResponse contains the response from method HTTPRoute.Delete.
type HTTPRouteDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HTTPRouteGetResponse contains the response from method HTTPRoute.Get.
type HTTPRouteGetResponse struct {
	HTTPRouteGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HTTPRouteGetResult contains the result from method HTTPRoute.Get.
type HTTPRouteGetResult struct {
	HTTPRouteResource
}

// HTTPRouteListResponse contains the response from method HTTPRoute.List.
type HTTPRouteListResponse struct {
	HTTPRouteListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HTTPRouteListResult contains the result from method HTTPRoute.List.
type HTTPRouteListResult struct {
	HTTPRouteList
}

// MicrosoftComSQLDatabaseCreateOrUpdatePollerResponse contains the response from method MicrosoftComSQLDatabase.CreateOrUpdate.
type MicrosoftComSQLDatabaseCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MicrosoftComSQLDatabaseCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l MicrosoftComSQLDatabaseCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MicrosoftComSQLDatabaseCreateOrUpdateResponse, error) {
	respType := MicrosoftComSQLDatabaseCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MicrosoftSQLDatabaseResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MicrosoftComSQLDatabaseCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *MicrosoftComSQLDatabaseCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *MicrosoftComSQLDatabaseClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("MicrosoftComSQLDatabaseClient.CreateOrUpdate", token, 	client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &MicrosoftComSQLDatabaseCreateOrUpdatePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MicrosoftComSQLDatabaseCreateOrUpdateResponse contains the response from method MicrosoftComSQLDatabase.CreateOrUpdate.
type MicrosoftComSQLDatabaseCreateOrUpdateResponse struct {
	MicrosoftComSQLDatabaseCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MicrosoftComSQLDatabaseCreateOrUpdateResult contains the result from method MicrosoftComSQLDatabase.CreateOrUpdate.
type MicrosoftComSQLDatabaseCreateOrUpdateResult struct {
	MicrosoftSQLDatabaseResource
}

// MicrosoftComSQLDatabaseDeletePollerResponse contains the response from method MicrosoftComSQLDatabase.Delete.
type MicrosoftComSQLDatabaseDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MicrosoftComSQLDatabaseDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l MicrosoftComSQLDatabaseDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MicrosoftComSQLDatabaseDeleteResponse, error) {
	respType := MicrosoftComSQLDatabaseDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MicrosoftComSQLDatabaseDeletePollerResponse from the provided client and resume token.
func (l *MicrosoftComSQLDatabaseDeletePollerResponse) Resume(ctx context.Context, client *MicrosoftComSQLDatabaseClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("MicrosoftComSQLDatabaseClient.Delete", token, 	client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &MicrosoftComSQLDatabaseDeletePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MicrosoftComSQLDatabaseDeleteResponse contains the response from method MicrosoftComSQLDatabase.Delete.
type MicrosoftComSQLDatabaseDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MicrosoftComSQLDatabaseGetResponse contains the response from method MicrosoftComSQLDatabase.Get.
type MicrosoftComSQLDatabaseGetResponse struct {
	MicrosoftComSQLDatabaseGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MicrosoftComSQLDatabaseGetResult contains the result from method MicrosoftComSQLDatabase.Get.
type MicrosoftComSQLDatabaseGetResult struct {
	MicrosoftSQLDatabaseResource
}

// MicrosoftComSQLDatabaseListResponse contains the response from method MicrosoftComSQLDatabase.List.
type MicrosoftComSQLDatabaseListResponse struct {
	MicrosoftComSQLDatabaseListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MicrosoftComSQLDatabaseListResult contains the result from method MicrosoftComSQLDatabase.List.
type MicrosoftComSQLDatabaseListResult struct {
	MicrosoftSQLDatabaseList
}

// MongoComMongoDatabaseCreateOrUpdatePollerResponse contains the response from method MongoComMongoDatabase.CreateOrUpdate.
type MongoComMongoDatabaseCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MongoComMongoDatabaseCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l MongoComMongoDatabaseCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MongoComMongoDatabaseCreateOrUpdateResponse, error) {
	respType := MongoComMongoDatabaseCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MongoDatabaseResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MongoComMongoDatabaseCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *MongoComMongoDatabaseCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *MongoComMongoDatabaseClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("MongoComMongoDatabaseClient.CreateOrUpdate", token, 	client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &MongoComMongoDatabaseCreateOrUpdatePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MongoComMongoDatabaseCreateOrUpdateResponse contains the response from method MongoComMongoDatabase.CreateOrUpdate.
type MongoComMongoDatabaseCreateOrUpdateResponse struct {
	MongoComMongoDatabaseCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoComMongoDatabaseCreateOrUpdateResult contains the result from method MongoComMongoDatabase.CreateOrUpdate.
type MongoComMongoDatabaseCreateOrUpdateResult struct {
	MongoDatabaseResource
}

// MongoComMongoDatabaseDeletePollerResponse contains the response from method MongoComMongoDatabase.Delete.
type MongoComMongoDatabaseDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MongoComMongoDatabaseDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l MongoComMongoDatabaseDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MongoComMongoDatabaseDeleteResponse, error) {
	respType := MongoComMongoDatabaseDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a MongoComMongoDatabaseDeletePollerResponse from the provided client and resume token.
func (l *MongoComMongoDatabaseDeletePollerResponse) Resume(ctx context.Context, client *MongoComMongoDatabaseClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("MongoComMongoDatabaseClient.Delete", token, 	client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &MongoComMongoDatabaseDeletePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// MongoComMongoDatabaseDeleteResponse contains the response from method MongoComMongoDatabase.Delete.
type MongoComMongoDatabaseDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoComMongoDatabaseGetResponse contains the response from method MongoComMongoDatabase.Get.
type MongoComMongoDatabaseGetResponse struct {
	MongoComMongoDatabaseGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoComMongoDatabaseGetResult contains the result from method MongoComMongoDatabase.Get.
type MongoComMongoDatabaseGetResult struct {
	MongoDatabaseResource
}

// MongoComMongoDatabaseListResponse contains the response from method MongoComMongoDatabase.List.
type MongoComMongoDatabaseListResponse struct {
	MongoComMongoDatabaseListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// MongoComMongoDatabaseListResult contains the result from method MongoComMongoDatabase.List.
type MongoComMongoDatabaseListResult struct {
	MongoDatabaseList
}

// RabbitmqComMessageQueueCreateOrUpdatePollerResponse contains the response from method RabbitmqComMessageQueue.CreateOrUpdate.
type RabbitmqComMessageQueueCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RabbitmqComMessageQueueCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l RabbitmqComMessageQueueCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RabbitmqComMessageQueueCreateOrUpdateResponse, error) {
	respType := RabbitmqComMessageQueueCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RabbitMQMessageQueueResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RabbitmqComMessageQueueCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *RabbitmqComMessageQueueCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *RabbitmqComMessageQueueClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("RabbitmqComMessageQueueClient.CreateOrUpdate", token, 	client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &RabbitmqComMessageQueueCreateOrUpdatePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RabbitmqComMessageQueueCreateOrUpdateResponse contains the response from method RabbitmqComMessageQueue.CreateOrUpdate.
type RabbitmqComMessageQueueCreateOrUpdateResponse struct {
	RabbitmqComMessageQueueCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RabbitmqComMessageQueueCreateOrUpdateResult contains the result from method RabbitmqComMessageQueue.CreateOrUpdate.
type RabbitmqComMessageQueueCreateOrUpdateResult struct {
	RabbitMQMessageQueueResource
}

// RabbitmqComMessageQueueDeletePollerResponse contains the response from method RabbitmqComMessageQueue.Delete.
type RabbitmqComMessageQueueDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RabbitmqComMessageQueueDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l RabbitmqComMessageQueueDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RabbitmqComMessageQueueDeleteResponse, error) {
	respType := RabbitmqComMessageQueueDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RabbitmqComMessageQueueDeletePollerResponse from the provided client and resume token.
func (l *RabbitmqComMessageQueueDeletePollerResponse) Resume(ctx context.Context, client *RabbitmqComMessageQueueClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("RabbitmqComMessageQueueClient.Delete", token, 	client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &RabbitmqComMessageQueueDeletePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RabbitmqComMessageQueueDeleteResponse contains the response from method RabbitmqComMessageQueue.Delete.
type RabbitmqComMessageQueueDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RabbitmqComMessageQueueGetResponse contains the response from method RabbitmqComMessageQueue.Get.
type RabbitmqComMessageQueueGetResponse struct {
	RabbitmqComMessageQueueGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RabbitmqComMessageQueueGetResult contains the result from method RabbitmqComMessageQueue.Get.
type RabbitmqComMessageQueueGetResult struct {
	RabbitMQMessageQueueResource
}

// RabbitmqComMessageQueueListResponse contains the response from method RabbitmqComMessageQueue.List.
type RabbitmqComMessageQueueListResponse struct {
	RabbitmqComMessageQueueListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RabbitmqComMessageQueueListResult contains the result from method RabbitmqComMessageQueue.List.
type RabbitmqComMessageQueueListResult struct {
	RabbitMQMessageQueueList
}

// RadiusResourceDeletePollerResponse contains the response from method RadiusResource.Delete.
type RadiusResourceDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RadiusResourceDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l RadiusResourceDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RadiusResourceDeleteResponse, error) {
	respType := RadiusResourceDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RadiusResourceDeletePollerResponse from the provided client and resume token.
func (l *RadiusResourceDeletePollerResponse) Resume(ctx context.Context, client *RadiusResourceClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("RadiusResourceClient.Delete", token, 	client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &RadiusResourceDeletePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RadiusResourceDeleteResponse contains the response from method RadiusResource.Delete.
type RadiusResourceDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RadiusResourceGetResponse contains the response from method RadiusResource.Get.
type RadiusResourceGetResponse struct {
	RadiusResourceGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RadiusResourceGetResult contains the result from method RadiusResource.Get.
type RadiusResourceGetResult struct {
	RadiusResource
}

// RadiusResourceListResponse contains the response from method RadiusResource.List.
type RadiusResourceListResponse struct {
	RadiusResourceListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RadiusResourceListResult contains the result from method RadiusResource.List.
type RadiusResourceListResult struct {
	RadiusResourceList
}

// RedislabsComRedisCacheCreateOrUpdatePollerResponse contains the response from method RedislabsComRedisCache.CreateOrUpdate.
type RedislabsComRedisCacheCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RedislabsComRedisCacheCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l RedislabsComRedisCacheCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RedislabsComRedisCacheCreateOrUpdateResponse, error) {
	respType := RedislabsComRedisCacheCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RedisCacheResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RedislabsComRedisCacheCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *RedislabsComRedisCacheCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *RedislabsComRedisCacheClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("RedislabsComRedisCacheClient.CreateOrUpdate", token, 	client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &RedislabsComRedisCacheCreateOrUpdatePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RedislabsComRedisCacheCreateOrUpdateResponse contains the response from method RedislabsComRedisCache.CreateOrUpdate.
type RedislabsComRedisCacheCreateOrUpdateResponse struct {
	RedislabsComRedisCacheCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RedislabsComRedisCacheCreateOrUpdateResult contains the result from method RedislabsComRedisCache.CreateOrUpdate.
type RedislabsComRedisCacheCreateOrUpdateResult struct {
	RedisCacheResource
}

// RedislabsComRedisCacheDeletePollerResponse contains the response from method RedislabsComRedisCache.Delete.
type RedislabsComRedisCacheDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RedislabsComRedisCacheDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l RedislabsComRedisCacheDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RedislabsComRedisCacheDeleteResponse, error) {
	respType := RedislabsComRedisCacheDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RedislabsComRedisCacheDeletePollerResponse from the provided client and resume token.
func (l *RedislabsComRedisCacheDeletePollerResponse) Resume(ctx context.Context, client *RedislabsComRedisCacheClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("RedislabsComRedisCacheClient.Delete", token, 	client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &RedislabsComRedisCacheDeletePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RedislabsComRedisCacheDeleteResponse contains the response from method RedislabsComRedisCache.Delete.
type RedislabsComRedisCacheDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RedislabsComRedisCacheGetResponse contains the response from method RedislabsComRedisCache.Get.
type RedislabsComRedisCacheGetResponse struct {
	RedislabsComRedisCacheGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RedislabsComRedisCacheGetResult contains the result from method RedislabsComRedisCache.Get.
type RedislabsComRedisCacheGetResult struct {
	RedisCacheResource
}

// RedislabsComRedisCacheListResponse contains the response from method RedislabsComRedisCache.List.
type RedislabsComRedisCacheListResponse struct {
	RedislabsComRedisCacheListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RedislabsComRedisCacheListResult contains the result from method RedislabsComRedisCache.List.
type RedislabsComRedisCacheListResult struct {
	RedisCacheList
}

// VolumeCreateOrUpdatePollerResponse contains the response from method Volume.CreateOrUpdate.
type VolumeCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VolumeCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l VolumeCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VolumeCreateOrUpdateResponse, error) {
	respType := VolumeCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VolumeResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VolumeCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VolumeCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VolumeClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("VolumeClient.CreateOrUpdate", token, 	client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return err
	}
	poller := &VolumeCreateOrUpdatePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VolumeCreateOrUpdateResponse contains the response from method Volume.CreateOrUpdate.
type VolumeCreateOrUpdateResponse struct {
	VolumeCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumeCreateOrUpdateResult contains the result from method Volume.CreateOrUpdate.
type VolumeCreateOrUpdateResult struct {
	VolumeResource
}

// VolumeDeletePollerResponse contains the response from method Volume.Delete.
type VolumeDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VolumeDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l VolumeDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VolumeDeleteResponse, error) {
	respType := VolumeDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VolumeDeletePollerResponse from the provided client and resume token.
func (l *VolumeDeletePollerResponse) Resume(ctx context.Context, client *VolumeClient, token string) error {	pt, err := armruntime.NewPollerFromResumeToken("VolumeClient.Delete", token, 	client.pl, client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &VolumeDeletePoller {
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VolumeDeleteResponse contains the response from method Volume.Delete.
type VolumeDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumeGetResponse contains the response from method Volume.Get.
type VolumeGetResponse struct {
	VolumeGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumeGetResult contains the result from method Volume.Get.
type VolumeGetResult struct {
	VolumeResource
}

// VolumeListResponse contains the response from method Volume.List.
type VolumeListResponse struct {
	VolumeListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VolumeListResult contains the result from method Volume.List.
type VolumeListResult struct {
	VolumeList
}

