//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package v20220315privatepreview

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// DaprInvokeHTTPRoutesListByRootScopePager provides operations for iterating over paged responses.
type DaprInvokeHTTPRoutesListByRootScopePager struct {
	client *DaprInvokeHTTPRoutesClient
	current DaprInvokeHTTPRoutesListByRootScopeResponse
	err error
	requester func(context.Context) (*policy.Request, error)
	advancer func(context.Context, DaprInvokeHTTPRoutesListByRootScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DaprInvokeHTTPRoutesListByRootScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DaprInvokeHTTPRoutesListByRootScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DaprInvokeHTTPRouteList.NextLink == nil || len(*p.current.DaprInvokeHTTPRouteList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.	client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByRootScopeHandleError(resp)
		return false
	}
	result, err := p.client.listByRootScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DaprInvokeHTTPRoutesListByRootScopeResponse page.
func (p *DaprInvokeHTTPRoutesListByRootScopePager) PageResponse() DaprInvokeHTTPRoutesListByRootScopeResponse {
	return p.current
}

// DaprPubSubBrokersListByRootScopePager provides operations for iterating over paged responses.
type DaprPubSubBrokersListByRootScopePager struct {
	client *DaprPubSubBrokersClient
	current DaprPubSubBrokersListByRootScopeResponse
	err error
	requester func(context.Context) (*policy.Request, error)
	advancer func(context.Context, DaprPubSubBrokersListByRootScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DaprPubSubBrokersListByRootScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DaprPubSubBrokersListByRootScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DaprPubSubBrokerList.NextLink == nil || len(*p.current.DaprPubSubBrokerList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.	client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByRootScopeHandleError(resp)
		return false
	}
	result, err := p.client.listByRootScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DaprPubSubBrokersListByRootScopeResponse page.
func (p *DaprPubSubBrokersListByRootScopePager) PageResponse() DaprPubSubBrokersListByRootScopeResponse {
	return p.current
}

// DaprSecretStoresListByRootScopePager provides operations for iterating over paged responses.
type DaprSecretStoresListByRootScopePager struct {
	client *DaprSecretStoresClient
	current DaprSecretStoresListByRootScopeResponse
	err error
	requester func(context.Context) (*policy.Request, error)
	advancer func(context.Context, DaprSecretStoresListByRootScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DaprSecretStoresListByRootScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DaprSecretStoresListByRootScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DaprSecretStoreList.NextLink == nil || len(*p.current.DaprSecretStoreList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.	client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByRootScopeHandleError(resp)
		return false
	}
	result, err := p.client.listByRootScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DaprSecretStoresListByRootScopeResponse page.
func (p *DaprSecretStoresListByRootScopePager) PageResponse() DaprSecretStoresListByRootScopeResponse {
	return p.current
}

// DaprStateStoresListByRootScopePager provides operations for iterating over paged responses.
type DaprStateStoresListByRootScopePager struct {
	client *DaprStateStoresClient
	current DaprStateStoresListByRootScopeResponse
	err error
	requester func(context.Context) (*policy.Request, error)
	advancer func(context.Context, DaprStateStoresListByRootScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DaprStateStoresListByRootScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DaprStateStoresListByRootScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DaprStateStoreList.NextLink == nil || len(*p.current.DaprStateStoreList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.	client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByRootScopeHandleError(resp)
		return false
	}
	result, err := p.client.listByRootScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DaprStateStoresListByRootScopeResponse page.
func (p *DaprStateStoresListByRootScopePager) PageResponse() DaprStateStoresListByRootScopeResponse {
	return p.current
}

// ExtendersListByRootScopePager provides operations for iterating over paged responses.
type ExtendersListByRootScopePager struct {
	client *ExtendersClient
	current ExtendersListByRootScopeResponse
	err error
	requester func(context.Context) (*policy.Request, error)
	advancer func(context.Context, ExtendersListByRootScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ExtendersListByRootScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ExtendersListByRootScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExtenderList.NextLink == nil || len(*p.current.ExtenderList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.	client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByRootScopeHandleError(resp)
		return false
	}
	result, err := p.client.listByRootScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ExtendersListByRootScopeResponse page.
func (p *ExtendersListByRootScopePager) PageResponse() ExtendersListByRootScopeResponse {
	return p.current
}

// MongoDatabasesListByRootScopePager provides operations for iterating over paged responses.
type MongoDatabasesListByRootScopePager struct {
	client *MongoDatabasesClient
	current MongoDatabasesListByRootScopeResponse
	err error
	requester func(context.Context) (*policy.Request, error)
	advancer func(context.Context, MongoDatabasesListByRootScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *MongoDatabasesListByRootScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *MongoDatabasesListByRootScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.MongoDatabaseList.NextLink == nil || len(*p.current.MongoDatabaseList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.	client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByRootScopeHandleError(resp)
		return false
	}
	result, err := p.client.listByRootScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current MongoDatabasesListByRootScopeResponse page.
func (p *MongoDatabasesListByRootScopePager) PageResponse() MongoDatabasesListByRootScopeResponse {
	return p.current
}

// RabbitMQMessageQueuesListByRootScopePager provides operations for iterating over paged responses.
type RabbitMQMessageQueuesListByRootScopePager struct {
	client *RabbitMQMessageQueuesClient
	current RabbitMQMessageQueuesListByRootScopeResponse
	err error
	requester func(context.Context) (*policy.Request, error)
	advancer func(context.Context, RabbitMQMessageQueuesListByRootScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RabbitMQMessageQueuesListByRootScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RabbitMQMessageQueuesListByRootScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RabbitMQMessageQueueList.NextLink == nil || len(*p.current.RabbitMQMessageQueueList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.	client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByRootScopeHandleError(resp)
		return false
	}
	result, err := p.client.listByRootScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RabbitMQMessageQueuesListByRootScopeResponse page.
func (p *RabbitMQMessageQueuesListByRootScopePager) PageResponse() RabbitMQMessageQueuesListByRootScopeResponse {
	return p.current
}

// RedisCachesListByRootScopePager provides operations for iterating over paged responses.
type RedisCachesListByRootScopePager struct {
	client *RedisCachesClient
	current RedisCachesListByRootScopeResponse
	err error
	requester func(context.Context) (*policy.Request, error)
	advancer func(context.Context, RedisCachesListByRootScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *RedisCachesListByRootScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *RedisCachesListByRootScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RedisCacheList.NextLink == nil || len(*p.current.RedisCacheList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.	client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByRootScopeHandleError(resp)
		return false
	}
	result, err := p.client.listByRootScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current RedisCachesListByRootScopeResponse page.
func (p *RedisCachesListByRootScopePager) PageResponse() RedisCachesListByRootScopeResponse {
	return p.current
}

// SQLDatabasesListByRootScopePager provides operations for iterating over paged responses.
type SQLDatabasesListByRootScopePager struct {
	client *SQLDatabasesClient
	current SQLDatabasesListByRootScopeResponse
	err error
	requester func(context.Context) (*policy.Request, error)
	advancer func(context.Context, SQLDatabasesListByRootScopeResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SQLDatabasesListByRootScopePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SQLDatabasesListByRootScopePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLDatabaseList.NextLink == nil || len(*p.current.SQLDatabaseList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.	client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByRootScopeHandleError(resp)
		return false
	}
	result, err := p.client.listByRootScopeHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SQLDatabasesListByRootScopeResponse page.
func (p *SQLDatabasesListByRootScopePager) PageResponse() SQLDatabasesListByRootScopeResponse {
	return p.current
}

