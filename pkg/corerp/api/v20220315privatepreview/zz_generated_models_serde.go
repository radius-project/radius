//go:build go1.18
// +build go1.18

// Licensed under the Apache License, Version 2.0 . See LICENSE in the repository root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package v20220315privatepreview

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type ApplicationExtension.
func (a ApplicationExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = "ApplicationExtension"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationExtension.
func (a *ApplicationExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &a.Kind)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationKubernetesMetadataExtension.
func (a ApplicationKubernetesMetadataExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", a.Annotations)
	objectMap["kind"] = "kubernetesMetadata"
	populate(objectMap, "labels", a.Labels)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationKubernetesMetadataExtension.
func (a *ApplicationKubernetesMetadataExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
				err = unpopulate(val, "Annotations", &a.Annotations)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &a.Kind)
				delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &a.Labels)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationKubernetesNamespaceExtension.
func (a ApplicationKubernetesNamespaceExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = "kubernetesNamespace"
	populate(objectMap, "namespace", a.Namespace)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationKubernetesNamespaceExtension.
func (a *ApplicationKubernetesNamespaceExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &a.Kind)
				delete(rawMsg, key)
		case "namespace":
				err = unpopulate(val, "Namespace", &a.Namespace)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationProperties.
func (a ApplicationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "environment", a.Environment)
	populate(objectMap, "extensions", a.Extensions)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationProperties.
func (a *ApplicationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "environment":
				err = unpopulate(val, "Environment", &a.Environment)
				delete(rawMsg, key)
		case "extensions":
				a.Extensions, err = unmarshalApplicationExtensionClassificationArray(val)
				delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &a.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationResource.
func (a ApplicationResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationResource.
func (a *ApplicationResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &a.ID)
				delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &a.Location)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &a.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &a.Properties)
				delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &a.SystemData)
				delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &a.Tags)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &a.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationResourceList.
func (a ApplicationResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationResourceList.
func (a *ApplicationResourceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &a.NextLink)
				delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &a.Value)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureKeyVaultVolumeProperties.
func (a AzureKeyVaultVolumeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "application", a.Application)
	populate(objectMap, "certificates", a.Certificates)
	populate(objectMap, "environment", a.Environment)
	populate(objectMap, "keys", a.Keys)
	objectMap["kind"] = "azure.com.keyvault"
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "resource", a.Resource)
	populate(objectMap, "secrets", a.Secrets)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureKeyVaultVolumeProperties.
func (a *AzureKeyVaultVolumeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &a.Application)
				delete(rawMsg, key)
		case "certificates":
				err = unpopulate(val, "Certificates", &a.Certificates)
				delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &a.Environment)
				delete(rawMsg, key)
		case "keys":
				err = unpopulate(val, "Keys", &a.Keys)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &a.Kind)
				delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
				delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, "Resource", &a.Resource)
				delete(rawMsg, key)
		case "secrets":
				err = unpopulate(val, "Secrets", &a.Secrets)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &a.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BasicResourceProperties.
func (b BasicResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "application", b.Application)
	populate(objectMap, "environment", b.Environment)
	populate(objectMap, "status", b.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BasicResourceProperties.
func (b *BasicResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &b.Application)
				delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &b.Environment)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &b.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CertificateObjectProperties.
func (c CertificateObjectProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alias", c.Alias)
	populate(objectMap, "certType", c.CertType)
	populate(objectMap, "encoding", c.Encoding)
	populate(objectMap, "format", c.Format)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "version", c.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertificateObjectProperties.
func (c *CertificateObjectProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alias":
				err = unpopulate(val, "Alias", &c.Alias)
				delete(rawMsg, key)
		case "certType":
				err = unpopulate(val, "CertType", &c.CertType)
				delete(rawMsg, key)
		case "encoding":
				err = unpopulate(val, "Encoding", &c.Encoding)
				delete(rawMsg, key)
		case "format":
				err = unpopulate(val, "Format", &c.Format)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
				delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &c.Version)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionProperties.
func (c ConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disableDefaultEnvVars", c.DisableDefaultEnvVars)
	populate(objectMap, "iam", c.Iam)
	populate(objectMap, "source", c.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionProperties.
func (c *ConnectionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableDefaultEnvVars":
				err = unpopulate(val, "DisableDefaultEnvVars", &c.DisableDefaultEnvVars)
				delete(rawMsg, key)
		case "iam":
				err = unpopulate(val, "Iam", &c.Iam)
				delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &c.Source)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Container.
func (c Container) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "args", c.Args)
	populate(objectMap, "command", c.Command)
	populate(objectMap, "env", c.Env)
	populate(objectMap, "image", c.Image)
	populate(objectMap, "livenessProbe", c.LivenessProbe)
	populate(objectMap, "ports", c.Ports)
	populate(objectMap, "readinessProbe", c.ReadinessProbe)
	populate(objectMap, "volumes", c.Volumes)
	populate(objectMap, "workingDir", c.WorkingDir)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Container.
func (c *Container) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "args":
				err = unpopulate(val, "Args", &c.Args)
				delete(rawMsg, key)
		case "command":
				err = unpopulate(val, "Command", &c.Command)
				delete(rawMsg, key)
		case "env":
				err = unpopulate(val, "Env", &c.Env)
				delete(rawMsg, key)
		case "image":
				err = unpopulate(val, "Image", &c.Image)
				delete(rawMsg, key)
		case "livenessProbe":
				c.LivenessProbe, err = unmarshalHealthProbePropertiesClassification(val)
				delete(rawMsg, key)
		case "ports":
				err = unpopulate(val, "Ports", &c.Ports)
				delete(rawMsg, key)
		case "readinessProbe":
				c.ReadinessProbe, err = unmarshalHealthProbePropertiesClassification(val)
				delete(rawMsg, key)
		case "volumes":
				c.Volumes, err = unmarshalVolumeClassificationMap(val)
				delete(rawMsg, key)
		case "workingDir":
				err = unpopulate(val, "WorkingDir", &c.WorkingDir)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerExtension.
func (c ContainerExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = "ContainerExtension"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerExtension.
func (c *ContainerExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &c.Kind)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerKubernetesMetadataExtension.
func (c ContainerKubernetesMetadataExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", c.Annotations)
	objectMap["kind"] = "kubernetesMetadata"
	populate(objectMap, "labels", c.Labels)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerKubernetesMetadataExtension.
func (c *ContainerKubernetesMetadataExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
				err = unpopulate(val, "Annotations", &c.Annotations)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &c.Kind)
				delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &c.Labels)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerPort.
func (c ContainerPort) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "containerPort", c.ContainerPort)
	populate(objectMap, "protocol", c.Protocol)
	populate(objectMap, "provides", c.Provides)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerPort.
func (c *ContainerPort) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerPort":
				err = unpopulate(val, "ContainerPort", &c.ContainerPort)
				delete(rawMsg, key)
		case "protocol":
				err = unpopulate(val, "Protocol", &c.Protocol)
				delete(rawMsg, key)
		case "provides":
				err = unpopulate(val, "Provides", &c.Provides)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerProperties.
func (c ContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "application", c.Application)
	populate(objectMap, "connections", c.Connections)
	populate(objectMap, "container", c.Container)
	populate(objectMap, "environment", c.Environment)
	populate(objectMap, "extensions", c.Extensions)
	populate(objectMap, "identity", c.Identity)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "status", c.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerProperties.
func (c *ContainerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &c.Application)
				delete(rawMsg, key)
		case "connections":
				err = unpopulate(val, "Connections", &c.Connections)
				delete(rawMsg, key)
		case "container":
				err = unpopulate(val, "Container", &c.Container)
				delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &c.Environment)
				delete(rawMsg, key)
		case "extensions":
				c.Extensions, err = unmarshalContainerExtensionClassificationArray(val)
				delete(rawMsg, key)
		case "identity":
				err = unpopulate(val, "Identity", &c.Identity)
				delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &c.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerResource.
func (c ContainerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", c.ID)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerResource.
func (c *ContainerResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &c.ID)
				delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &c.Location)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &c.Properties)
				delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &c.SystemData)
				delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &c.Tags)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &c.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerResourceList.
func (c ContainerResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerResourceList.
func (c *ContainerResourceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &c.NextLink)
				delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &c.Value)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DaprSidecarExtension.
func (d DaprSidecarExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appId", d.AppID)
	populate(objectMap, "appPort", d.AppPort)
	populate(objectMap, "config", d.Config)
	objectMap["kind"] = "daprSidecar"
	populate(objectMap, "protocol", d.Protocol)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DaprSidecarExtension.
func (d *DaprSidecarExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appId":
				err = unpopulate(val, "AppID", &d.AppID)
				delete(rawMsg, key)
		case "appPort":
				err = unpopulate(val, "AppPort", &d.AppPort)
				delete(rawMsg, key)
		case "config":
				err = unpopulate(val, "Config", &d.Config)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &d.Kind)
				delete(rawMsg, key)
		case "protocol":
				err = unpopulate(val, "Protocol", &d.Protocol)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentCompute.
func (e EnvironmentCompute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", e.Identity)
	objectMap["kind"] = e.Kind
	populate(objectMap, "resourceId", e.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentCompute.
func (e *EnvironmentCompute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
				err = unpopulate(val, "Identity", &e.Identity)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &e.Kind)
				delete(rawMsg, key)
		case "resourceId":
				err = unpopulate(val, "ResourceID", &e.ResourceID)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentExtension.
func (e EnvironmentExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = "EnvironmentExtension"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentExtension.
func (e *EnvironmentExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &e.Kind)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentKubernetesMetadataExtension.
func (e EnvironmentKubernetesMetadataExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "annotations", e.Annotations)
	objectMap["kind"] = "kubernetesMetadata"
	populate(objectMap, "labels", e.Labels)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentKubernetesMetadataExtension.
func (e *EnvironmentKubernetesMetadataExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
				err = unpopulate(val, "Annotations", &e.Annotations)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &e.Kind)
				delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &e.Labels)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentProperties.
func (e EnvironmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compute", e.Compute)
	populate(objectMap, "extensions", e.Extensions)
	populate(objectMap, "providers", e.Providers)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "recipes", e.Recipes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentProperties.
func (e *EnvironmentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compute":
				e.Compute, err = unmarshalEnvironmentComputeClassification(val)
				delete(rawMsg, key)
		case "extensions":
				e.Extensions, err = unmarshalEnvironmentExtensionClassificationArray(val)
				delete(rawMsg, key)
		case "providers":
				err = unpopulate(val, "Providers", &e.Providers)
				delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
				delete(rawMsg, key)
		case "recipes":
				err = unpopulate(val, "Recipes", &e.Recipes)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentRecipeProperties.
func (e EnvironmentRecipeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "parameters", e.Parameters)
	populate(objectMap, "templateKind", e.TemplateKind)
	populate(objectMap, "templatePath", e.TemplatePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentRecipeProperties.
func (e *EnvironmentRecipeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
				err = unpopulate(val, "Parameters", &e.Parameters)
				delete(rawMsg, key)
		case "templateKind":
				err = unpopulate(val, "TemplateKind", &e.TemplateKind)
				delete(rawMsg, key)
		case "templatePath":
				err = unpopulate(val, "TemplatePath", &e.TemplatePath)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentResource.
func (e EnvironmentResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", e.ID)
	populate(objectMap, "location", e.Location)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "tags", e.Tags)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentResource.
func (e *EnvironmentResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &e.ID)
				delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &e.Location)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &e.Properties)
				delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &e.SystemData)
				delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &e.Tags)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &e.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentResourceList.
func (e EnvironmentResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentResourceList.
func (e *EnvironmentResourceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &e.NextLink)
				delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &e.Value)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EphemeralVolume.
func (e EphemeralVolume) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = "ephemeral"
	populate(objectMap, "managedStore", e.ManagedStore)
	populate(objectMap, "mountPath", e.MountPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EphemeralVolume.
func (e *EphemeralVolume) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &e.Kind)
				delete(rawMsg, key)
		case "managedStore":
				err = unpopulate(val, "ManagedStore", &e.ManagedStore)
				delete(rawMsg, key)
		case "mountPath":
				err = unpopulate(val, "MountPath", &e.MountPath)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorAdditionalInfo.
func (e ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "info", e.Info)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorAdditionalInfo.
func (e *ErrorAdditionalInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "info":
				err = unpopulate(val, "Info", &e.Info)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &e.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorDetail.
func (e *ErrorDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalInfo":
				err = unpopulate(val, "AdditionalInfo", &e.AdditionalInfo)
				delete(rawMsg, key)
		case "code":
				err = unpopulate(val, "Code", &e.Code)
				delete(rawMsg, key)
		case "details":
				err = unpopulate(val, "Details", &e.Details)
				delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &e.Message)
				delete(rawMsg, key)
		case "target":
				err = unpopulate(val, "Target", &e.Target)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponse.
func (e ErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", e.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorResponse.
func (e *ErrorResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &e.Error)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExecHealthProbeProperties.
func (e ExecHealthProbeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "command", e.Command)
	populate(objectMap, "failureThreshold", e.FailureThreshold)
	populate(objectMap, "initialDelaySeconds", e.InitialDelaySeconds)
	objectMap["kind"] = "exec"
	populate(objectMap, "periodSeconds", e.PeriodSeconds)
	populate(objectMap, "timeoutSeconds", e.TimeoutSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecHealthProbeProperties.
func (e *ExecHealthProbeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "command":
				err = unpopulate(val, "Command", &e.Command)
				delete(rawMsg, key)
		case "failureThreshold":
				err = unpopulate(val, "FailureThreshold", &e.FailureThreshold)
				delete(rawMsg, key)
		case "initialDelaySeconds":
				err = unpopulate(val, "InitialDelaySeconds", &e.InitialDelaySeconds)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &e.Kind)
				delete(rawMsg, key)
		case "periodSeconds":
				err = unpopulate(val, "PeriodSeconds", &e.PeriodSeconds)
				delete(rawMsg, key)
		case "timeoutSeconds":
				err = unpopulate(val, "TimeoutSeconds", &e.TimeoutSeconds)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtenderList.
func (e ExtenderList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtenderList.
func (e *ExtenderList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &e.NextLink)
				delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &e.Value)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtenderProperties.
func (e ExtenderProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "application", e.Application)
	populate(objectMap, "environment", e.Environment)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "secrets", e.Secrets)
	populate(objectMap, "status", e.Status)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtenderProperties.
func (e *ExtenderProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &e.Application)
				delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &e.Environment)
				delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
				delete(rawMsg, key)
		case "secrets":
				err = unpopulate(val, "Secrets", &e.Secrets)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &e.Status)
				delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtenderResource.
func (e ExtenderResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", e.ID)
	populate(objectMap, "location", e.Location)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "tags", e.Tags)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtenderResource.
func (e *ExtenderResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &e.ID)
				delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &e.Location)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &e.Properties)
				delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &e.SystemData)
				delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &e.Tags)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &e.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtenderResponseProperties.
func (e ExtenderResponseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "application", e.Application)
	populate(objectMap, "environment", e.Environment)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "status", e.Status)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtenderResponseProperties.
func (e *ExtenderResponseProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &e.Application)
				delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &e.Environment)
				delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &e.Status)
				delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtenderResponseResource.
func (e ExtenderResponseResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", e.ID)
	populate(objectMap, "location", e.Location)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "tags", e.Tags)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtenderResponseResource.
func (e *ExtenderResponseResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &e.ID)
				delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &e.Location)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &e.Properties)
				delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &e.Tags)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &e.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Extension.
func (e Extension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = e.Kind
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Extension.
func (e *Extension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &e.Kind)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayProperties.
func (g GatewayProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "application", g.Application)
	populate(objectMap, "environment", g.Environment)
	populate(objectMap, "hostname", g.Hostname)
	populate(objectMap, "internal", g.Internal)
	populate(objectMap, "provisioningState", g.ProvisioningState)
	populate(objectMap, "routes", g.Routes)
	populate(objectMap, "status", g.Status)
	populate(objectMap, "tls", g.TLS)
	populate(objectMap, "url", g.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayProperties.
func (g *GatewayProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &g.Application)
				delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &g.Environment)
				delete(rawMsg, key)
		case "hostname":
				err = unpopulate(val, "Hostname", &g.Hostname)
				delete(rawMsg, key)
		case "internal":
				err = unpopulate(val, "Internal", &g.Internal)
				delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &g.ProvisioningState)
				delete(rawMsg, key)
		case "routes":
				err = unpopulate(val, "Routes", &g.Routes)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &g.Status)
				delete(rawMsg, key)
		case "tls":
				err = unpopulate(val, "TLS", &g.TLS)
				delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &g.URL)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayPropertiesHostname.
func (g GatewayPropertiesHostname) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fullyQualifiedHostname", g.FullyQualifiedHostname)
	populate(objectMap, "prefix", g.Prefix)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayPropertiesHostname.
func (g *GatewayPropertiesHostname) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fullyQualifiedHostname":
				err = unpopulate(val, "FullyQualifiedHostname", &g.FullyQualifiedHostname)
				delete(rawMsg, key)
		case "prefix":
				err = unpopulate(val, "Prefix", &g.Prefix)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayPropertiesTLS.
func (g GatewayPropertiesTLS) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "certificateFrom", g.CertificateFrom)
	populate(objectMap, "hostname", g.Hostname)
	populate(objectMap, "minimumProtocolVersion", g.MinimumProtocolVersion)
	populate(objectMap, "sslPassthrough", g.SSLPassthrough)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayPropertiesTLS.
func (g *GatewayPropertiesTLS) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "certificateFrom":
				err = unpopulate(val, "CertificateFrom", &g.CertificateFrom)
				delete(rawMsg, key)
		case "hostname":
				err = unpopulate(val, "Hostname", &g.Hostname)
				delete(rawMsg, key)
		case "minimumProtocolVersion":
				err = unpopulate(val, "MinimumProtocolVersion", &g.MinimumProtocolVersion)
				delete(rawMsg, key)
		case "sslPassthrough":
				err = unpopulate(val, "SSLPassthrough", &g.SSLPassthrough)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayResource.
func (g GatewayResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", g.ID)
	populate(objectMap, "location", g.Location)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "properties", g.Properties)
	populate(objectMap, "systemData", g.SystemData)
	populate(objectMap, "tags", g.Tags)
	populate(objectMap, "type", g.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayResource.
func (g *GatewayResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &g.ID)
				delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &g.Location)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &g.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &g.Properties)
				delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &g.SystemData)
				delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &g.Tags)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &g.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayResourceList.
func (g GatewayResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", g.NextLink)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayResourceList.
func (g *GatewayResourceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &g.NextLink)
				delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &g.Value)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayRoute.
func (g GatewayRoute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "destination", g.Destination)
	populate(objectMap, "path", g.Path)
	populate(objectMap, "replacePrefix", g.ReplacePrefix)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayRoute.
func (g *GatewayRoute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "destination":
				err = unpopulate(val, "Destination", &g.Destination)
				delete(rawMsg, key)
		case "path":
				err = unpopulate(val, "Path", &g.Path)
				delete(rawMsg, key)
		case "replacePrefix":
				err = unpopulate(val, "ReplacePrefix", &g.ReplacePrefix)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPGetHealthProbeProperties.
func (h HTTPGetHealthProbeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "containerPort", h.ContainerPort)
	populate(objectMap, "failureThreshold", h.FailureThreshold)
	populate(objectMap, "headers", h.Headers)
	populate(objectMap, "initialDelaySeconds", h.InitialDelaySeconds)
	objectMap["kind"] = "httpGet"
	populate(objectMap, "path", h.Path)
	populate(objectMap, "periodSeconds", h.PeriodSeconds)
	populate(objectMap, "timeoutSeconds", h.TimeoutSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPGetHealthProbeProperties.
func (h *HTTPGetHealthProbeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerPort":
				err = unpopulate(val, "ContainerPort", &h.ContainerPort)
				delete(rawMsg, key)
		case "failureThreshold":
				err = unpopulate(val, "FailureThreshold", &h.FailureThreshold)
				delete(rawMsg, key)
		case "headers":
				err = unpopulate(val, "Headers", &h.Headers)
				delete(rawMsg, key)
		case "initialDelaySeconds":
				err = unpopulate(val, "InitialDelaySeconds", &h.InitialDelaySeconds)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &h.Kind)
				delete(rawMsg, key)
		case "path":
				err = unpopulate(val, "Path", &h.Path)
				delete(rawMsg, key)
		case "periodSeconds":
				err = unpopulate(val, "PeriodSeconds", &h.PeriodSeconds)
				delete(rawMsg, key)
		case "timeoutSeconds":
				err = unpopulate(val, "TimeoutSeconds", &h.TimeoutSeconds)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPRouteProperties.
func (h HTTPRouteProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "application", h.Application)
	populate(objectMap, "environment", h.Environment)
	populate(objectMap, "hostname", h.Hostname)
	populate(objectMap, "port", h.Port)
	populate(objectMap, "provisioningState", h.ProvisioningState)
	populate(objectMap, "scheme", h.Scheme)
	populate(objectMap, "status", h.Status)
	populate(objectMap, "url", h.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPRouteProperties.
func (h *HTTPRouteProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &h.Application)
				delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &h.Environment)
				delete(rawMsg, key)
		case "hostname":
				err = unpopulate(val, "Hostname", &h.Hostname)
				delete(rawMsg, key)
		case "port":
				err = unpopulate(val, "Port", &h.Port)
				delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &h.ProvisioningState)
				delete(rawMsg, key)
		case "scheme":
				err = unpopulate(val, "Scheme", &h.Scheme)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &h.Status)
				delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &h.URL)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPRouteResource.
func (h HTTPRouteResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", h.ID)
	populate(objectMap, "location", h.Location)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "systemData", h.SystemData)
	populate(objectMap, "tags", h.Tags)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPRouteResource.
func (h *HTTPRouteResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &h.ID)
				delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &h.Location)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &h.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &h.Properties)
				delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &h.SystemData)
				delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &h.Tags)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &h.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPRouteResourceList.
func (h HTTPRouteResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPRouteResourceList.
func (h *HTTPRouteResourceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &h.NextLink)
				delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &h.Value)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HealthProbeProperties.
func (h HealthProbeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "failureThreshold", h.FailureThreshold)
	populate(objectMap, "initialDelaySeconds", h.InitialDelaySeconds)
	objectMap["kind"] = h.Kind
	populate(objectMap, "periodSeconds", h.PeriodSeconds)
	populate(objectMap, "timeoutSeconds", h.TimeoutSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HealthProbeProperties.
func (h *HealthProbeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "failureThreshold":
				err = unpopulate(val, "FailureThreshold", &h.FailureThreshold)
				delete(rawMsg, key)
		case "initialDelaySeconds":
				err = unpopulate(val, "InitialDelaySeconds", &h.InitialDelaySeconds)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &h.Kind)
				delete(rawMsg, key)
		case "periodSeconds":
				err = unpopulate(val, "PeriodSeconds", &h.PeriodSeconds)
				delete(rawMsg, key)
		case "timeoutSeconds":
				err = unpopulate(val, "TimeoutSeconds", &h.TimeoutSeconds)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IamProperties.
func (i IamProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "kind", i.Kind)
	populate(objectMap, "roles", i.Roles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IamProperties.
func (i *IamProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &i.Kind)
				delete(rawMsg, key)
		case "roles":
				err = unpopulate(val, "Roles", &i.Roles)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IdentitySettings.
func (i IdentitySettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "kind", i.Kind)
	populate(objectMap, "oidcIssuer", i.OidcIssuer)
	populate(objectMap, "resource", i.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IdentitySettings.
func (i *IdentitySettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &i.Kind)
				delete(rawMsg, key)
		case "oidcIssuer":
				err = unpopulate(val, "OidcIssuer", &i.OidcIssuer)
				delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, "Resource", &i.Resource)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KeyObjectProperties.
func (k KeyObjectProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alias", k.Alias)
	populate(objectMap, "name", k.Name)
	populate(objectMap, "version", k.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyObjectProperties.
func (k *KeyObjectProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alias":
				err = unpopulate(val, "Alias", &k.Alias)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &k.Name)
				delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &k.Version)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesCompute.
func (k KubernetesCompute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", k.Identity)
	objectMap["kind"] = "kubernetes"
	populate(objectMap, "namespace", k.Namespace)
	populate(objectMap, "resourceId", k.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesCompute.
func (k *KubernetesCompute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
				err = unpopulate(val, "Identity", &k.Identity)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &k.Kind)
				delete(rawMsg, key)
		case "namespace":
				err = unpopulate(val, "Namespace", &k.Namespace)
				delete(rawMsg, key)
		case "resourceId":
				err = unpopulate(val, "ResourceID", &k.ResourceID)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManualScalingExtension.
func (m ManualScalingExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = "manualScaling"
	populate(objectMap, "replicas", m.Replicas)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManualScalingExtension.
func (m *ManualScalingExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &m.Kind)
				delete(rawMsg, key)
		case "replicas":
				err = unpopulate(val, "Replicas", &m.Replicas)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PersistentVolume.
func (p PersistentVolume) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = "persistent"
	populate(objectMap, "mountPath", p.MountPath)
	populate(objectMap, "permission", p.Permission)
	populate(objectMap, "source", p.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PersistentVolume.
func (p *PersistentVolume) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &p.Kind)
				delete(rawMsg, key)
		case "mountPath":
				err = unpopulate(val, "MountPath", &p.MountPath)
				delete(rawMsg, key)
		case "permission":
				err = unpopulate(val, "Permission", &p.Permission)
				delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &p.Source)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Providers.
func (p Providers) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aws", p.Aws)
	populate(objectMap, "azure", p.Azure)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Providers.
func (p *Providers) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aws":
				err = unpopulate(val, "Aws", &p.Aws)
				delete(rawMsg, key)
		case "azure":
				err = unpopulate(val, "Azure", &p.Azure)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProvidersAws.
func (p ProvidersAws) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "scope", p.Scope)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProvidersAws.
func (p *ProvidersAws) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "scope":
				err = unpopulate(val, "Scope", &p.Scope)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProvidersAzure.
func (p ProvidersAzure) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "scope", p.Scope)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProvidersAzure.
func (p *ProvidersAzure) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "scope":
				err = unpopulate(val, "Scope", &p.Scope)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Recipe.
func (r Recipe) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "linkType", r.LinkType)
	populate(objectMap, "name", r.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Recipe.
func (r *Recipe) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkType":
				err = unpopulate(val, "LinkType", &r.LinkType)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &r.Name)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Resource.
func (r *Resource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &r.ID)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &r.Name)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &r.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceStatus.
func (r ResourceStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compute", r.Compute)
	populate(objectMap, "outputResources", r.OutputResources)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceStatus.
func (r *ResourceStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compute":
				r.Compute, err = unmarshalEnvironmentComputeClassification(val)
				delete(rawMsg, key)
		case "outputResources":
				err = unpopulate(val, "OutputResources", &r.OutputResources)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretObjectProperties.
func (s SecretObjectProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alias", s.Alias)
	populate(objectMap, "encoding", s.Encoding)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretObjectProperties.
func (s *SecretObjectProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alias":
				err = unpopulate(val, "Alias", &s.Alias)
				delete(rawMsg, key)
		case "encoding":
				err = unpopulate(val, "Encoding", &s.Encoding)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
				delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &s.Version)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretStoreListSecretsResult.
func (s SecretStoreListSecretsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "data", s.Data)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretStoreListSecretsResult.
func (s *SecretStoreListSecretsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "data":
				err = unpopulate(val, "Data", &s.Data)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &s.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretStoreProperties.
func (s SecretStoreProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "application", s.Application)
	populate(objectMap, "data", s.Data)
	populate(objectMap, "environment", s.Environment)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "resource", s.Resource)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretStoreProperties.
func (s *SecretStoreProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &s.Application)
				delete(rawMsg, key)
		case "data":
				err = unpopulate(val, "Data", &s.Data)
				delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &s.Environment)
				delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &s.ProvisioningState)
				delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, "Resource", &s.Resource)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &s.Status)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &s.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretStoreResource.
func (s SecretStoreResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretStoreResource.
func (s *SecretStoreResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &s.ID)
				delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &s.Location)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &s.Properties)
				delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &s.SystemData)
				delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &s.Tags)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &s.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretStoreResourceList.
func (s SecretStoreResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretStoreResourceList.
func (s *SecretStoreResourceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &s.NextLink)
				delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &s.Value)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretValueProperties.
func (s SecretValueProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encoding", s.Encoding)
	populate(objectMap, "value", s.Value)
	populate(objectMap, "valueFrom", s.ValueFrom)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretValueProperties.
func (s *SecretValueProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encoding":
				err = unpopulate(val, "Encoding", &s.Encoding)
				delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &s.Value)
				delete(rawMsg, key)
		case "valueFrom":
				err = unpopulate(val, "ValueFrom", &s.ValueFrom)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
				err = unpopulateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
				delete(rawMsg, key)
		case "createdBy":
				err = unpopulate(val, "CreatedBy", &s.CreatedBy)
				delete(rawMsg, key)
		case "createdByType":
				err = unpopulate(val, "CreatedByType", &s.CreatedByType)
				delete(rawMsg, key)
		case "lastModifiedAt":
				err = unpopulateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
				delete(rawMsg, key)
		case "lastModifiedBy":
				err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
				delete(rawMsg, key)
		case "lastModifiedByType":
				err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TCPHealthProbeProperties.
func (t TCPHealthProbeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "containerPort", t.ContainerPort)
	populate(objectMap, "failureThreshold", t.FailureThreshold)
	populate(objectMap, "initialDelaySeconds", t.InitialDelaySeconds)
	objectMap["kind"] = "tcp"
	populate(objectMap, "periodSeconds", t.PeriodSeconds)
	populate(objectMap, "timeoutSeconds", t.TimeoutSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TCPHealthProbeProperties.
func (t *TCPHealthProbeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerPort":
				err = unpopulate(val, "ContainerPort", &t.ContainerPort)
				delete(rawMsg, key)
		case "failureThreshold":
				err = unpopulate(val, "FailureThreshold", &t.FailureThreshold)
				delete(rawMsg, key)
		case "initialDelaySeconds":
				err = unpopulate(val, "InitialDelaySeconds", &t.InitialDelaySeconds)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &t.Kind)
				delete(rawMsg, key)
		case "periodSeconds":
				err = unpopulate(val, "PeriodSeconds", &t.PeriodSeconds)
				delete(rawMsg, key)
		case "timeoutSeconds":
				err = unpopulate(val, "TimeoutSeconds", &t.TimeoutSeconds)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TrackedResource.
func (t *TrackedResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &t.ID)
				delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &t.Location)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &t.Name)
				delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &t.Tags)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &t.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValueFromProperties.
func (v ValueFromProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", v.Name)
	populate(objectMap, "version", v.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValueFromProperties.
func (v *ValueFromProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &v.Name)
				delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &v.Version)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Volume.
func (v Volume) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = v.Kind
	populate(objectMap, "mountPath", v.MountPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Volume.
func (v *Volume) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &v.Kind)
				delete(rawMsg, key)
		case "mountPath":
				err = unpopulate(val, "MountPath", &v.MountPath)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VolumeProperties.
func (v VolumeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "application", v.Application)
	populate(objectMap, "environment", v.Environment)
	objectMap["kind"] = v.Kind
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "status", v.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeProperties.
func (v *VolumeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &v.Application)
				delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &v.Environment)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &v.Kind)
				delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &v.ProvisioningState)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &v.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VolumeResource.
func (v VolumeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", v.ID)
	populate(objectMap, "location", v.Location)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "tags", v.Tags)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeResource.
func (v *VolumeResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &v.ID)
				delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &v.Location)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &v.Name)
				delete(rawMsg, key)
		case "properties":
				v.Properties, err = unmarshalVolumePropertiesClassification(val)
				delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &v.SystemData)
				delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &v.Tags)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &v.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VolumeResourceList.
func (v VolumeResourceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeResourceList.
func (v *VolumeResourceList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &v.NextLink)
				delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &v.Value)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v interface{}) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

