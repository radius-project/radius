//go:build go1.18
// +build go1.18

// Licensed under the Apache License, Version 2.0 . See LICENSE in the repository root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package v20231001preview

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type ApplicationGraphConnection.
func (a ApplicationGraphConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "direction", a.Direction)
	populate(objectMap, "id", a.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationGraphConnection.
func (a *ApplicationGraphConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "direction":
				err = unpopulate(val, "Direction", &a.Direction)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationGraphOutputResource.
func (a ApplicationGraphOutputResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationGraphOutputResource.
func (a *ApplicationGraphOutputResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationGraphResource.
func (a ApplicationGraphResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "connections", a.Connections)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "outputResources", a.OutputResources)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationGraphResource.
func (a *ApplicationGraphResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connections":
				err = unpopulate(val, "Connections", &a.Connections)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "outputResources":
				err = unpopulate(val, "OutputResources", &a.OutputResources)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationGraphResponse.
func (a ApplicationGraphResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "resources", a.Resources)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationGraphResponse.
func (a *ApplicationGraphResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resources":
				err = unpopulate(val, "Resources", &a.Resources)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationProperties.
func (a ApplicationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "environment", a.Environment)
	populate(objectMap, "extensions", a.Extensions)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationProperties.
func (a *ApplicationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "environment":
				err = unpopulate(val, "Environment", &a.Environment)
			delete(rawMsg, key)
		case "extensions":
			a.Extensions, err = unmarshalExtensionClassificationArray(val)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationResource.
func (a ApplicationResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationResource.
func (a *ApplicationResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationResourceListResult.
func (a ApplicationResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationResourceListResult.
func (a *ApplicationResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationResourceUpdate.
func (a ApplicationResourceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "tags", a.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationResourceUpdate.
func (a *ApplicationResourceUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationResourceUpdateProperties.
func (a ApplicationResourceUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "environment", a.Environment)
	populate(objectMap, "extensions", a.Extensions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ApplicationResourceUpdateProperties.
func (a *ApplicationResourceUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "environment":
				err = unpopulate(val, "Environment", &a.Environment)
			delete(rawMsg, key)
		case "extensions":
			a.Extensions, err = unmarshalExtensionClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AuthConfig.
func (a AuthConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "git", a.Git)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AuthConfig.
func (a *AuthConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "git":
				err = unpopulate(val, "Git", &a.Git)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureKeyVaultVolumeProperties.
func (a AzureKeyVaultVolumeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "application", a.Application)
	populate(objectMap, "certificates", a.Certificates)
	populate(objectMap, "environment", a.Environment)
	populate(objectMap, "keys", a.Keys)
	objectMap["kind"] = "azure.com.keyvault"
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "resource", a.Resource)
	populate(objectMap, "secrets", a.Secrets)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureKeyVaultVolumeProperties.
func (a *AzureKeyVaultVolumeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &a.Application)
			delete(rawMsg, key)
		case "certificates":
				err = unpopulate(val, "Certificates", &a.Certificates)
			delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &a.Environment)
			delete(rawMsg, key)
		case "keys":
				err = unpopulate(val, "Keys", &a.Keys)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &a.Kind)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, "Resource", &a.Resource)
			delete(rawMsg, key)
		case "secrets":
				err = unpopulate(val, "Secrets", &a.Secrets)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &a.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BicepRecipeProperties.
func (b BicepRecipeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", b.Parameters)
	populate(objectMap, "plainHttp", b.PlainHTTP)
	objectMap["templateKind"] = "bicep"
	populate(objectMap, "templatePath", b.TemplatePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BicepRecipeProperties.
func (b *BicepRecipeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
				err = unpopulate(val, "Parameters", &b.Parameters)
			delete(rawMsg, key)
		case "plainHttp":
				err = unpopulate(val, "PlainHTTP", &b.PlainHTTP)
			delete(rawMsg, key)
		case "templateKind":
				err = unpopulate(val, "TemplateKind", &b.TemplateKind)
			delete(rawMsg, key)
		case "templatePath":
				err = unpopulate(val, "TemplatePath", &b.TemplatePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BicepRecipePropertiesUpdate.
func (b BicepRecipePropertiesUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", b.Parameters)
	populate(objectMap, "plainHttp", b.PlainHTTP)
	objectMap["templateKind"] = "bicep"
	populate(objectMap, "templatePath", b.TemplatePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BicepRecipePropertiesUpdate.
func (b *BicepRecipePropertiesUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
				err = unpopulate(val, "Parameters", &b.Parameters)
			delete(rawMsg, key)
		case "plainHttp":
				err = unpopulate(val, "PlainHTTP", &b.PlainHTTP)
			delete(rawMsg, key)
		case "templateKind":
				err = unpopulate(val, "TemplateKind", &b.TemplateKind)
			delete(rawMsg, key)
		case "templatePath":
				err = unpopulate(val, "TemplatePath", &b.TemplatePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CertificateObjectProperties.
func (c CertificateObjectProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alias", c.Alias)
	populate(objectMap, "certType", c.CertType)
	populate(objectMap, "encoding", c.Encoding)
	populate(objectMap, "format", c.Format)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "version", c.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertificateObjectProperties.
func (c *CertificateObjectProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alias":
				err = unpopulate(val, "Alias", &c.Alias)
			delete(rawMsg, key)
		case "certType":
				err = unpopulate(val, "CertType", &c.CertType)
			delete(rawMsg, key)
		case "encoding":
				err = unpopulate(val, "Encoding", &c.Encoding)
			delete(rawMsg, key)
		case "format":
				err = unpopulate(val, "Format", &c.Format)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &c.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionProperties.
func (c ConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "disableDefaultEnvVars", c.DisableDefaultEnvVars)
	populate(objectMap, "iam", c.Iam)
	populate(objectMap, "source", c.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionProperties.
func (c *ConnectionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableDefaultEnvVars":
				err = unpopulate(val, "DisableDefaultEnvVars", &c.DisableDefaultEnvVars)
			delete(rawMsg, key)
		case "iam":
				err = unpopulate(val, "Iam", &c.Iam)
			delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &c.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionPropertiesUpdate.
func (c ConnectionPropertiesUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "disableDefaultEnvVars", c.DisableDefaultEnvVars)
	populate(objectMap, "iam", c.Iam)
	populate(objectMap, "source", c.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionPropertiesUpdate.
func (c *ConnectionPropertiesUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableDefaultEnvVars":
				err = unpopulate(val, "DisableDefaultEnvVars", &c.DisableDefaultEnvVars)
			delete(rawMsg, key)
		case "iam":
				err = unpopulate(val, "Iam", &c.Iam)
			delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &c.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Container.
func (c Container) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "args", c.Args)
	populate(objectMap, "command", c.Command)
	populate(objectMap, "env", c.Env)
	populate(objectMap, "image", c.Image)
	populate(objectMap, "imagePullPolicy", c.ImagePullPolicy)
	populate(objectMap, "livenessProbe", c.LivenessProbe)
	populate(objectMap, "ports", c.Ports)
	populate(objectMap, "readinessProbe", c.ReadinessProbe)
	populate(objectMap, "volumes", c.Volumes)
	populate(objectMap, "workingDir", c.WorkingDir)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Container.
func (c *Container) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "args":
				err = unpopulate(val, "Args", &c.Args)
			delete(rawMsg, key)
		case "command":
				err = unpopulate(val, "Command", &c.Command)
			delete(rawMsg, key)
		case "env":
				err = unpopulate(val, "Env", &c.Env)
			delete(rawMsg, key)
		case "image":
				err = unpopulate(val, "Image", &c.Image)
			delete(rawMsg, key)
		case "imagePullPolicy":
				err = unpopulate(val, "ImagePullPolicy", &c.ImagePullPolicy)
			delete(rawMsg, key)
		case "livenessProbe":
			c.LivenessProbe, err = unmarshalHealthProbePropertiesClassification(val)
			delete(rawMsg, key)
		case "ports":
				err = unpopulate(val, "Ports", &c.Ports)
			delete(rawMsg, key)
		case "readinessProbe":
			c.ReadinessProbe, err = unmarshalHealthProbePropertiesClassification(val)
			delete(rawMsg, key)
		case "volumes":
			c.Volumes, err = unmarshalVolumeClassificationMap(val)
			delete(rawMsg, key)
		case "workingDir":
				err = unpopulate(val, "WorkingDir", &c.WorkingDir)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerPortProperties.
func (c ContainerPortProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerPort", c.ContainerPort)
	populate(objectMap, "port", c.Port)
	populate(objectMap, "protocol", c.Protocol)
	populate(objectMap, "scheme", c.Scheme)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerPortProperties.
func (c *ContainerPortProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerPort":
				err = unpopulate(val, "ContainerPort", &c.ContainerPort)
			delete(rawMsg, key)
		case "port":
				err = unpopulate(val, "Port", &c.Port)
			delete(rawMsg, key)
		case "protocol":
				err = unpopulate(val, "Protocol", &c.Protocol)
			delete(rawMsg, key)
		case "scheme":
				err = unpopulate(val, "Scheme", &c.Scheme)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerPortPropertiesUpdate.
func (c ContainerPortPropertiesUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerPort", c.ContainerPort)
	populate(objectMap, "port", c.Port)
	populate(objectMap, "protocol", c.Protocol)
	populate(objectMap, "scheme", c.Scheme)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerPortPropertiesUpdate.
func (c *ContainerPortPropertiesUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerPort":
				err = unpopulate(val, "ContainerPort", &c.ContainerPort)
			delete(rawMsg, key)
		case "port":
				err = unpopulate(val, "Port", &c.Port)
			delete(rawMsg, key)
		case "protocol":
				err = unpopulate(val, "Protocol", &c.Protocol)
			delete(rawMsg, key)
		case "scheme":
				err = unpopulate(val, "Scheme", &c.Scheme)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerProperties.
func (c ContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "application", c.Application)
	populate(objectMap, "connections", c.Connections)
	populate(objectMap, "container", c.Container)
	populate(objectMap, "environment", c.Environment)
	populate(objectMap, "extensions", c.Extensions)
	populate(objectMap, "identity", c.Identity)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "resourceProvisioning", c.ResourceProvisioning)
	populate(objectMap, "resources", c.Resources)
	populate(objectMap, "restartPolicy", c.RestartPolicy)
	populate(objectMap, "runtimes", c.Runtimes)
	populate(objectMap, "status", c.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerProperties.
func (c *ContainerProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &c.Application)
			delete(rawMsg, key)
		case "connections":
				err = unpopulate(val, "Connections", &c.Connections)
			delete(rawMsg, key)
		case "container":
				err = unpopulate(val, "Container", &c.Container)
			delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &c.Environment)
			delete(rawMsg, key)
		case "extensions":
			c.Extensions, err = unmarshalExtensionClassificationArray(val)
			delete(rawMsg, key)
		case "identity":
				err = unpopulate(val, "Identity", &c.Identity)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &c.ProvisioningState)
			delete(rawMsg, key)
		case "resourceProvisioning":
				err = unpopulate(val, "ResourceProvisioning", &c.ResourceProvisioning)
			delete(rawMsg, key)
		case "resources":
				err = unpopulate(val, "Resources", &c.Resources)
			delete(rawMsg, key)
		case "restartPolicy":
				err = unpopulate(val, "RestartPolicy", &c.RestartPolicy)
			delete(rawMsg, key)
		case "runtimes":
				err = unpopulate(val, "Runtimes", &c.Runtimes)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &c.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerResource.
func (c ContainerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerResource.
func (c *ContainerResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerResourceListResult.
func (c ContainerResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerResourceListResult.
func (c *ContainerResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &c.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &c.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerResourceUpdate.
func (c ContainerResourceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerResourceUpdate.
func (c *ContainerResourceUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerResourceUpdateProperties.
func (c ContainerResourceUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "application", c.Application)
	populate(objectMap, "connections", c.Connections)
	populate(objectMap, "container", c.Container)
	populate(objectMap, "environment", c.Environment)
	populate(objectMap, "extensions", c.Extensions)
	populate(objectMap, "identity", c.Identity)
	populate(objectMap, "resourceProvisioning", c.ResourceProvisioning)
	populate(objectMap, "resources", c.Resources)
	populate(objectMap, "restartPolicy", c.RestartPolicy)
	populate(objectMap, "runtimes", c.Runtimes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerResourceUpdateProperties.
func (c *ContainerResourceUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &c.Application)
			delete(rawMsg, key)
		case "connections":
				err = unpopulate(val, "Connections", &c.Connections)
			delete(rawMsg, key)
		case "container":
				err = unpopulate(val, "Container", &c.Container)
			delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &c.Environment)
			delete(rawMsg, key)
		case "extensions":
			c.Extensions, err = unmarshalExtensionClassificationArray(val)
			delete(rawMsg, key)
		case "identity":
				err = unpopulate(val, "Identity", &c.Identity)
			delete(rawMsg, key)
		case "resourceProvisioning":
				err = unpopulate(val, "ResourceProvisioning", &c.ResourceProvisioning)
			delete(rawMsg, key)
		case "resources":
				err = unpopulate(val, "Resources", &c.Resources)
			delete(rawMsg, key)
		case "restartPolicy":
				err = unpopulate(val, "RestartPolicy", &c.RestartPolicy)
			delete(rawMsg, key)
		case "runtimes":
				err = unpopulate(val, "Runtimes", &c.Runtimes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerUpdate.
func (c ContainerUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "args", c.Args)
	populate(objectMap, "command", c.Command)
	populate(objectMap, "env", c.Env)
	populate(objectMap, "image", c.Image)
	populate(objectMap, "imagePullPolicy", c.ImagePullPolicy)
	populate(objectMap, "livenessProbe", c.LivenessProbe)
	populate(objectMap, "ports", c.Ports)
	populate(objectMap, "readinessProbe", c.ReadinessProbe)
	populate(objectMap, "volumes", c.Volumes)
	populate(objectMap, "workingDir", c.WorkingDir)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerUpdate.
func (c *ContainerUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "args":
				err = unpopulate(val, "Args", &c.Args)
			delete(rawMsg, key)
		case "command":
				err = unpopulate(val, "Command", &c.Command)
			delete(rawMsg, key)
		case "env":
				err = unpopulate(val, "Env", &c.Env)
			delete(rawMsg, key)
		case "image":
				err = unpopulate(val, "Image", &c.Image)
			delete(rawMsg, key)
		case "imagePullPolicy":
				err = unpopulate(val, "ImagePullPolicy", &c.ImagePullPolicy)
			delete(rawMsg, key)
		case "livenessProbe":
			c.LivenessProbe, err = unmarshalHealthProbePropertiesClassification(val)
			delete(rawMsg, key)
		case "ports":
				err = unpopulate(val, "Ports", &c.Ports)
			delete(rawMsg, key)
		case "readinessProbe":
			c.ReadinessProbe, err = unmarshalHealthProbePropertiesClassification(val)
			delete(rawMsg, key)
		case "volumes":
			c.Volumes, err = unmarshalVolumeClassificationMap(val)
			delete(rawMsg, key)
		case "workingDir":
				err = unpopulate(val, "WorkingDir", &c.WorkingDir)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DaprSidecarExtension.
func (d DaprSidecarExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "appId", d.AppID)
	populate(objectMap, "appPort", d.AppPort)
	populate(objectMap, "config", d.Config)
	objectMap["kind"] = "daprSidecar"
	populate(objectMap, "protocol", d.Protocol)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DaprSidecarExtension.
func (d *DaprSidecarExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appId":
				err = unpopulate(val, "AppID", &d.AppID)
			delete(rawMsg, key)
		case "appPort":
				err = unpopulate(val, "AppPort", &d.AppPort)
			delete(rawMsg, key)
		case "config":
				err = unpopulate(val, "Config", &d.Config)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &d.Kind)
			delete(rawMsg, key)
		case "protocol":
				err = unpopulate(val, "Protocol", &d.Protocol)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentCompute.
func (e EnvironmentCompute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", e.Identity)
	objectMap["kind"] = e.Kind
	populate(objectMap, "resourceId", e.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentCompute.
func (e *EnvironmentCompute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
				err = unpopulate(val, "Identity", &e.Identity)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &e.Kind)
			delete(rawMsg, key)
		case "resourceId":
				err = unpopulate(val, "ResourceID", &e.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentComputeUpdate.
func (e EnvironmentComputeUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", e.Identity)
	objectMap["kind"] = e.Kind
	populate(objectMap, "resourceId", e.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentComputeUpdate.
func (e *EnvironmentComputeUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
				err = unpopulate(val, "Identity", &e.Identity)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &e.Kind)
			delete(rawMsg, key)
		case "resourceId":
				err = unpopulate(val, "ResourceID", &e.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentProperties.
func (e EnvironmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compute", e.Compute)
	populate(objectMap, "extensions", e.Extensions)
	populate(objectMap, "providers", e.Providers)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "recipeConfig", e.RecipeConfig)
	populate(objectMap, "recipes", e.Recipes)
	populate(objectMap, "simulated", e.Simulated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentProperties.
func (e *EnvironmentProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compute":
			e.Compute, err = unmarshalEnvironmentComputeClassification(val)
			delete(rawMsg, key)
		case "extensions":
			e.Extensions, err = unmarshalExtensionClassificationArray(val)
			delete(rawMsg, key)
		case "providers":
				err = unpopulate(val, "Providers", &e.Providers)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
			delete(rawMsg, key)
		case "recipeConfig":
				err = unpopulate(val, "RecipeConfig", &e.RecipeConfig)
			delete(rawMsg, key)
		case "recipes":
			var recipesRaw map[string]json.RawMessage
			if err = json.Unmarshal(val, &recipesRaw); err != nil {
				return err
			}
			recipes := map[string]map[string]RecipePropertiesClassification{}
			for k1, v1 := range recipesRaw {
				recipes[k1], err = unmarshalRecipePropertiesClassificationMap(v1)
				if err != nil {
					return fmt.Errorf("unmarshalling type %T: %v", e, err)
				}
			}
			e.Recipes = recipes
			delete(rawMsg, key)
		case "simulated":
				err = unpopulate(val, "Simulated", &e.Simulated)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentResource.
func (e EnvironmentResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "location", e.Location)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "tags", e.Tags)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentResource.
func (e *EnvironmentResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &e.Location)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &e.Tags)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentResourceListResult.
func (e EnvironmentResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentResourceListResult.
func (e *EnvironmentResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentResourceUpdate.
func (e EnvironmentResourceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "tags", e.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentResourceUpdate.
func (e *EnvironmentResourceUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &e.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentResourceUpdateProperties.
func (e EnvironmentResourceUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compute", e.Compute)
	populate(objectMap, "extensions", e.Extensions)
	populate(objectMap, "providers", e.Providers)
	populate(objectMap, "recipeConfig", e.RecipeConfig)
	populate(objectMap, "recipes", e.Recipes)
	populate(objectMap, "simulated", e.Simulated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentResourceUpdateProperties.
func (e *EnvironmentResourceUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compute":
			e.Compute, err = unmarshalEnvironmentComputeUpdateClassification(val)
			delete(rawMsg, key)
		case "extensions":
			e.Extensions, err = unmarshalExtensionClassificationArray(val)
			delete(rawMsg, key)
		case "providers":
				err = unpopulate(val, "Providers", &e.Providers)
			delete(rawMsg, key)
		case "recipeConfig":
				err = unpopulate(val, "RecipeConfig", &e.RecipeConfig)
			delete(rawMsg, key)
		case "recipes":
			var recipesRaw map[string]json.RawMessage
			if err = json.Unmarshal(val, &recipesRaw); err != nil {
				return err
			}
			recipes := map[string]map[string]RecipePropertiesUpdateClassification{}
			for k1, v1 := range recipesRaw {
				recipes[k1], err = unmarshalRecipePropertiesUpdateClassificationMap(v1)
				if err != nil {
					return fmt.Errorf("unmarshalling type %T: %v", e, err)
				}
			}
			e.Recipes = recipes
			delete(rawMsg, key)
		case "simulated":
				err = unpopulate(val, "Simulated", &e.Simulated)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentVariable.
func (e EnvironmentVariable) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", e.Value)
	populate(objectMap, "valueFrom", e.ValueFrom)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentVariable.
func (e *EnvironmentVariable) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
				err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		case "valueFrom":
				err = unpopulate(val, "ValueFrom", &e.ValueFrom)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentVariableReference.
func (e EnvironmentVariableReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secretRef", e.SecretRef)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentVariableReference.
func (e *EnvironmentVariableReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secretRef":
				err = unpopulate(val, "SecretRef", &e.SecretRef)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentVariableReferenceUpdate.
func (e EnvironmentVariableReferenceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secretRef", e.SecretRef)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentVariableReferenceUpdate.
func (e *EnvironmentVariableReferenceUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secretRef":
				err = unpopulate(val, "SecretRef", &e.SecretRef)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentVariableUpdate.
func (e EnvironmentVariableUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", e.Value)
	populate(objectMap, "valueFrom", e.ValueFrom)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentVariableUpdate.
func (e *EnvironmentVariableUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
				err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		case "valueFrom":
				err = unpopulate(val, "ValueFrom", &e.ValueFrom)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EphemeralVolume.
func (e EphemeralVolume) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = "ephemeral"
	populate(objectMap, "managedStore", e.ManagedStore)
	populate(objectMap, "mountPath", e.MountPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EphemeralVolume.
func (e *EphemeralVolume) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &e.Kind)
			delete(rawMsg, key)
		case "managedStore":
				err = unpopulate(val, "ManagedStore", &e.ManagedStore)
			delete(rawMsg, key)
		case "mountPath":
				err = unpopulate(val, "MountPath", &e.MountPath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorAdditionalInfo.
func (e ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "info", e.Info)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorAdditionalInfo.
func (e *ErrorAdditionalInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "info":
				err = unpopulate(val, "Info", &e.Info)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorDetail.
func (e *ErrorDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalInfo":
				err = unpopulate(val, "AdditionalInfo", &e.AdditionalInfo)
			delete(rawMsg, key)
		case "code":
				err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "details":
				err = unpopulate(val, "Details", &e.Details)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "target":
				err = unpopulate(val, "Target", &e.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponse.
func (e ErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", e.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorResponse.
func (e *ErrorResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &e.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExecHealthProbeProperties.
func (e ExecHealthProbeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "command", e.Command)
	populate(objectMap, "failureThreshold", e.FailureThreshold)
	populate(objectMap, "initialDelaySeconds", e.InitialDelaySeconds)
	objectMap["kind"] = "exec"
	populate(objectMap, "periodSeconds", e.PeriodSeconds)
	populate(objectMap, "timeoutSeconds", e.TimeoutSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecHealthProbeProperties.
func (e *ExecHealthProbeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "command":
				err = unpopulate(val, "Command", &e.Command)
			delete(rawMsg, key)
		case "failureThreshold":
				err = unpopulate(val, "FailureThreshold", &e.FailureThreshold)
			delete(rawMsg, key)
		case "initialDelaySeconds":
				err = unpopulate(val, "InitialDelaySeconds", &e.InitialDelaySeconds)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &e.Kind)
			delete(rawMsg, key)
		case "periodSeconds":
				err = unpopulate(val, "PeriodSeconds", &e.PeriodSeconds)
			delete(rawMsg, key)
		case "timeoutSeconds":
				err = unpopulate(val, "TimeoutSeconds", &e.TimeoutSeconds)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtenderProperties.
func (e ExtenderProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "application", e.Application)
	populate(objectMap, "environment", e.Environment)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "recipe", e.Recipe)
	populate(objectMap, "resourceProvisioning", e.ResourceProvisioning)
	populate(objectMap, "secrets", e.Secrets)
	populate(objectMap, "status", e.Status)
	if e.AdditionalProperties != nil {
		for key, val := range e.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtenderProperties.
func (e *ExtenderProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &e.Application)
			delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &e.Environment)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &e.ProvisioningState)
			delete(rawMsg, key)
		case "recipe":
				err = unpopulate(val, "Recipe", &e.Recipe)
			delete(rawMsg, key)
		case "resourceProvisioning":
				err = unpopulate(val, "ResourceProvisioning", &e.ResourceProvisioning)
			delete(rawMsg, key)
		case "secrets":
				err = unpopulate(val, "Secrets", &e.Secrets)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &e.Status)
			delete(rawMsg, key)
		default:
			if e.AdditionalProperties == nil {
				e.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				e.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtenderResource.
func (e ExtenderResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "location", e.Location)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "systemData", e.SystemData)
	populate(objectMap, "tags", e.Tags)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtenderResource.
func (e *ExtenderResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &e.Location)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &e.SystemData)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &e.Tags)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtenderResourceListResult.
func (e ExtenderResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtenderResourceListResult.
func (e *ExtenderResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &e.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtenderResourceUpdate.
func (e ExtenderResourceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "tags", e.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtenderResourceUpdate.
func (e *ExtenderResourceUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, "Properties", &e.Properties)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &e.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtenderResourceUpdateProperties.
func (e ExtenderResourceUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "application", e.Application)
	populate(objectMap, "environment", e.Environment)
	populate(objectMap, "recipe", e.Recipe)
	populate(objectMap, "resourceProvisioning", e.ResourceProvisioning)
	populate(objectMap, "secrets", e.Secrets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtenderResourceUpdateProperties.
func (e *ExtenderResourceUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &e.Application)
			delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &e.Environment)
			delete(rawMsg, key)
		case "recipe":
				err = unpopulate(val, "Recipe", &e.Recipe)
			delete(rawMsg, key)
		case "resourceProvisioning":
				err = unpopulate(val, "ResourceProvisioning", &e.ResourceProvisioning)
			delete(rawMsg, key)
		case "secrets":
				err = unpopulate(val, "Secrets", &e.Secrets)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Extension.
func (e Extension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = e.Kind
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Extension.
func (e *Extension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &e.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayHostname.
func (g GatewayHostname) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "fullyQualifiedHostname", g.FullyQualifiedHostname)
	populate(objectMap, "prefix", g.Prefix)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayHostname.
func (g *GatewayHostname) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fullyQualifiedHostname":
				err = unpopulate(val, "FullyQualifiedHostname", &g.FullyQualifiedHostname)
			delete(rawMsg, key)
		case "prefix":
				err = unpopulate(val, "Prefix", &g.Prefix)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayProperties.
func (g GatewayProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "application", g.Application)
	populate(objectMap, "environment", g.Environment)
	populate(objectMap, "hostname", g.Hostname)
	populate(objectMap, "internal", g.Internal)
	populate(objectMap, "provisioningState", g.ProvisioningState)
	populate(objectMap, "routes", g.Routes)
	populate(objectMap, "status", g.Status)
	populate(objectMap, "tls", g.TLS)
	populate(objectMap, "url", g.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayProperties.
func (g *GatewayProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &g.Application)
			delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &g.Environment)
			delete(rawMsg, key)
		case "hostname":
				err = unpopulate(val, "Hostname", &g.Hostname)
			delete(rawMsg, key)
		case "internal":
				err = unpopulate(val, "Internal", &g.Internal)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &g.ProvisioningState)
			delete(rawMsg, key)
		case "routes":
				err = unpopulate(val, "Routes", &g.Routes)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &g.Status)
			delete(rawMsg, key)
		case "tls":
				err = unpopulate(val, "TLS", &g.TLS)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &g.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayResource.
func (g GatewayResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "location", g.Location)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "properties", g.Properties)
	populate(objectMap, "systemData", g.SystemData)
	populate(objectMap, "tags", g.Tags)
	populate(objectMap, "type", g.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayResource.
func (g *GatewayResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &g.ID)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &g.Location)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &g.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &g.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &g.SystemData)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &g.Tags)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &g.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayResourceListResult.
func (g GatewayResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", g.NextLink)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayResourceListResult.
func (g *GatewayResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &g.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &g.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayResourceUpdate.
func (g GatewayResourceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", g.Properties)
	populate(objectMap, "tags", g.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayResourceUpdate.
func (g *GatewayResourceUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, "Properties", &g.Properties)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &g.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayResourceUpdateProperties.
func (g GatewayResourceUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "application", g.Application)
	populate(objectMap, "environment", g.Environment)
	populate(objectMap, "hostname", g.Hostname)
	populate(objectMap, "internal", g.Internal)
	populate(objectMap, "routes", g.Routes)
	populate(objectMap, "tls", g.TLS)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayResourceUpdateProperties.
func (g *GatewayResourceUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &g.Application)
			delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &g.Environment)
			delete(rawMsg, key)
		case "hostname":
				err = unpopulate(val, "Hostname", &g.Hostname)
			delete(rawMsg, key)
		case "internal":
				err = unpopulate(val, "Internal", &g.Internal)
			delete(rawMsg, key)
		case "routes":
				err = unpopulate(val, "Routes", &g.Routes)
			delete(rawMsg, key)
		case "tls":
				err = unpopulate(val, "TLS", &g.TLS)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayRoute.
func (g GatewayRoute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "destination", g.Destination)
	populate(objectMap, "enableWebsockets", g.EnableWebsockets)
	populate(objectMap, "path", g.Path)
	populate(objectMap, "replacePrefix", g.ReplacePrefix)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayRoute.
func (g *GatewayRoute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "destination":
				err = unpopulate(val, "Destination", &g.Destination)
			delete(rawMsg, key)
		case "enableWebsockets":
				err = unpopulate(val, "EnableWebsockets", &g.EnableWebsockets)
			delete(rawMsg, key)
		case "path":
				err = unpopulate(val, "Path", &g.Path)
			delete(rawMsg, key)
		case "replacePrefix":
				err = unpopulate(val, "ReplacePrefix", &g.ReplacePrefix)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GatewayTLS.
func (g GatewayTLS) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "certificateFrom", g.CertificateFrom)
	populate(objectMap, "minimumProtocolVersion", g.MinimumProtocolVersion)
	populate(objectMap, "sslPassthrough", g.SSLPassthrough)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GatewayTLS.
func (g *GatewayTLS) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "certificateFrom":
				err = unpopulate(val, "CertificateFrom", &g.CertificateFrom)
			delete(rawMsg, key)
		case "minimumProtocolVersion":
				err = unpopulate(val, "MinimumProtocolVersion", &g.MinimumProtocolVersion)
			delete(rawMsg, key)
		case "sslPassthrough":
				err = unpopulate(val, "SSLPassthrough", &g.SSLPassthrough)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GitAuthConfig.
func (g GitAuthConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "pat", g.Pat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GitAuthConfig.
func (g *GitAuthConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", g, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "pat":
				err = unpopulate(val, "Pat", &g.Pat)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", g, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPGetHealthProbeProperties.
func (h HTTPGetHealthProbeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerPort", h.ContainerPort)
	populate(objectMap, "failureThreshold", h.FailureThreshold)
	populate(objectMap, "headers", h.Headers)
	populate(objectMap, "initialDelaySeconds", h.InitialDelaySeconds)
	objectMap["kind"] = "httpGet"
	populate(objectMap, "path", h.Path)
	populate(objectMap, "periodSeconds", h.PeriodSeconds)
	populate(objectMap, "timeoutSeconds", h.TimeoutSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPGetHealthProbeProperties.
func (h *HTTPGetHealthProbeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerPort":
				err = unpopulate(val, "ContainerPort", &h.ContainerPort)
			delete(rawMsg, key)
		case "failureThreshold":
				err = unpopulate(val, "FailureThreshold", &h.FailureThreshold)
			delete(rawMsg, key)
		case "headers":
				err = unpopulate(val, "Headers", &h.Headers)
			delete(rawMsg, key)
		case "initialDelaySeconds":
				err = unpopulate(val, "InitialDelaySeconds", &h.InitialDelaySeconds)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &h.Kind)
			delete(rawMsg, key)
		case "path":
				err = unpopulate(val, "Path", &h.Path)
			delete(rawMsg, key)
		case "periodSeconds":
				err = unpopulate(val, "PeriodSeconds", &h.PeriodSeconds)
			delete(rawMsg, key)
		case "timeoutSeconds":
				err = unpopulate(val, "TimeoutSeconds", &h.TimeoutSeconds)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HealthProbeProperties.
func (h HealthProbeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "failureThreshold", h.FailureThreshold)
	populate(objectMap, "initialDelaySeconds", h.InitialDelaySeconds)
	objectMap["kind"] = h.Kind
	populate(objectMap, "periodSeconds", h.PeriodSeconds)
	populate(objectMap, "timeoutSeconds", h.TimeoutSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HealthProbeProperties.
func (h *HealthProbeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "failureThreshold":
				err = unpopulate(val, "FailureThreshold", &h.FailureThreshold)
			delete(rawMsg, key)
		case "initialDelaySeconds":
				err = unpopulate(val, "InitialDelaySeconds", &h.InitialDelaySeconds)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &h.Kind)
			delete(rawMsg, key)
		case "periodSeconds":
				err = unpopulate(val, "PeriodSeconds", &h.PeriodSeconds)
			delete(rawMsg, key)
		case "timeoutSeconds":
				err = unpopulate(val, "TimeoutSeconds", &h.TimeoutSeconds)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IamProperties.
func (i IamProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kind", i.Kind)
	populate(objectMap, "roles", i.Roles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IamProperties.
func (i *IamProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &i.Kind)
			delete(rawMsg, key)
		case "roles":
				err = unpopulate(val, "Roles", &i.Roles)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IamPropertiesUpdate.
func (i IamPropertiesUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kind", i.Kind)
	populate(objectMap, "roles", i.Roles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IamPropertiesUpdate.
func (i *IamPropertiesUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &i.Kind)
			delete(rawMsg, key)
		case "roles":
				err = unpopulate(val, "Roles", &i.Roles)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IdentitySettings.
func (i IdentitySettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kind", i.Kind)
	populate(objectMap, "oidcIssuer", i.OidcIssuer)
	populate(objectMap, "resource", i.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IdentitySettings.
func (i *IdentitySettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &i.Kind)
			delete(rawMsg, key)
		case "oidcIssuer":
				err = unpopulate(val, "OidcIssuer", &i.OidcIssuer)
			delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, "Resource", &i.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IdentitySettingsUpdate.
func (i IdentitySettingsUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kind", i.Kind)
	populate(objectMap, "oidcIssuer", i.OidcIssuer)
	populate(objectMap, "resource", i.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IdentitySettingsUpdate.
func (i *IdentitySettingsUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &i.Kind)
			delete(rawMsg, key)
		case "oidcIssuer":
				err = unpopulate(val, "OidcIssuer", &i.OidcIssuer)
			delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, "Resource", &i.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KeyObjectProperties.
func (k KeyObjectProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alias", k.Alias)
	populate(objectMap, "name", k.Name)
	populate(objectMap, "version", k.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyObjectProperties.
func (k *KeyObjectProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alias":
				err = unpopulate(val, "Alias", &k.Alias)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &k.Name)
			delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &k.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesCompute.
func (k KubernetesCompute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", k.Identity)
	objectMap["kind"] = "kubernetes"
	populate(objectMap, "namespace", k.Namespace)
	populate(objectMap, "resourceId", k.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesCompute.
func (k *KubernetesCompute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
				err = unpopulate(val, "Identity", &k.Identity)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &k.Kind)
			delete(rawMsg, key)
		case "namespace":
				err = unpopulate(val, "Namespace", &k.Namespace)
			delete(rawMsg, key)
		case "resourceId":
				err = unpopulate(val, "ResourceID", &k.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesComputeUpdate.
func (k KubernetesComputeUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", k.Identity)
	objectMap["kind"] = "kubernetes"
	populate(objectMap, "namespace", k.Namespace)
	populate(objectMap, "resourceId", k.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesComputeUpdate.
func (k *KubernetesComputeUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
				err = unpopulate(val, "Identity", &k.Identity)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &k.Kind)
			delete(rawMsg, key)
		case "namespace":
				err = unpopulate(val, "Namespace", &k.Namespace)
			delete(rawMsg, key)
		case "resourceId":
				err = unpopulate(val, "ResourceID", &k.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesMetadataExtension.
func (k KubernetesMetadataExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "annotations", k.Annotations)
	objectMap["kind"] = "kubernetesMetadata"
	populate(objectMap, "labels", k.Labels)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesMetadataExtension.
func (k *KubernetesMetadataExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
				err = unpopulate(val, "Annotations", &k.Annotations)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &k.Kind)
			delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &k.Labels)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesNamespaceExtension.
func (k KubernetesNamespaceExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = "kubernetesNamespace"
	populate(objectMap, "namespace", k.Namespace)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesNamespaceExtension.
func (k *KubernetesNamespaceExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &k.Kind)
			delete(rawMsg, key)
		case "namespace":
				err = unpopulate(val, "Namespace", &k.Namespace)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesRuntimeProperties.
func (k KubernetesRuntimeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "base", k.Base)
	populate(objectMap, "pod", k.Pod)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesRuntimeProperties.
func (k *KubernetesRuntimeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "base":
				err = unpopulate(val, "Base", &k.Base)
			delete(rawMsg, key)
		case "pod":
				err = unpopulate(val, "Pod", &k.Pod)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManualScalingExtension.
func (m ManualScalingExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = "manualScaling"
	populate(objectMap, "replicas", m.Replicas)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManualScalingExtension.
func (m *ManualScalingExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &m.Kind)
			delete(rawMsg, key)
		case "replicas":
				err = unpopulate(val, "Replicas", &m.Replicas)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
				err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
				err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
				err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
				err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
				err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
				err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
				err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OutputResource.
func (o OutputResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "localId", o.LocalID)
	populate(objectMap, "radiusManaged", o.RadiusManaged)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OutputResource.
func (o *OutputResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &o.ID)
			delete(rawMsg, key)
		case "localId":
				err = unpopulate(val, "LocalID", &o.LocalID)
			delete(rawMsg, key)
		case "radiusManaged":
				err = unpopulate(val, "RadiusManaged", &o.RadiusManaged)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PersistentVolume.
func (p PersistentVolume) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = "persistent"
	populate(objectMap, "mountPath", p.MountPath)
	populate(objectMap, "permission", p.Permission)
	populate(objectMap, "source", p.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PersistentVolume.
func (p *PersistentVolume) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &p.Kind)
			delete(rawMsg, key)
		case "mountPath":
				err = unpopulate(val, "MountPath", &p.MountPath)
			delete(rawMsg, key)
		case "permission":
				err = unpopulate(val, "Permission", &p.Permission)
			delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &p.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProviderConfigProperties.
func (p ProviderConfigProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secrets", p.Secrets)
	if p.AdditionalProperties != nil {
		for key, val := range p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProviderConfigProperties.
func (p *ProviderConfigProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secrets":
				err = unpopulate(val, "Secrets", &p.Secrets)
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = map[string]any{}
			}
			if val != nil {
				var aux any
				err = json.Unmarshal(val, &aux)
				p.AdditionalProperties[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Providers.
func (p Providers) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "aws", p.Aws)
	populate(objectMap, "azure", p.Azure)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Providers.
func (p *Providers) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aws":
				err = unpopulate(val, "Aws", &p.Aws)
			delete(rawMsg, key)
		case "azure":
				err = unpopulate(val, "Azure", &p.Azure)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProvidersAws.
func (p ProvidersAws) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "scope", p.Scope)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProvidersAws.
func (p *ProvidersAws) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "scope":
				err = unpopulate(val, "Scope", &p.Scope)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProvidersAwsUpdate.
func (p ProvidersAwsUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "scope", p.Scope)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProvidersAwsUpdate.
func (p *ProvidersAwsUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "scope":
				err = unpopulate(val, "Scope", &p.Scope)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProvidersAzure.
func (p ProvidersAzure) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "scope", p.Scope)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProvidersAzure.
func (p *ProvidersAzure) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "scope":
				err = unpopulate(val, "Scope", &p.Scope)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProvidersAzureUpdate.
func (p ProvidersAzureUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "scope", p.Scope)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProvidersAzureUpdate.
func (p *ProvidersAzureUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "scope":
				err = unpopulate(val, "Scope", &p.Scope)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProvidersUpdate.
func (p ProvidersUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "aws", p.Aws)
	populate(objectMap, "azure", p.Azure)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProvidersUpdate.
func (p *ProvidersUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aws":
				err = unpopulate(val, "Aws", &p.Aws)
			delete(rawMsg, key)
		case "azure":
				err = unpopulate(val, "Azure", &p.Azure)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Recipe.
func (r Recipe) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "parameters", r.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Recipe.
func (r *Recipe) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "parameters":
				err = unpopulate(val, "Parameters", &r.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecipeConfigProperties.
func (r RecipeConfigProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "env", r.Env)
	populate(objectMap, "envSecrets", r.EnvSecrets)
	populate(objectMap, "terraform", r.Terraform)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecipeConfigProperties.
func (r *RecipeConfigProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "env":
				err = unpopulate(val, "Env", &r.Env)
			delete(rawMsg, key)
		case "envSecrets":
				err = unpopulate(val, "EnvSecrets", &r.EnvSecrets)
			delete(rawMsg, key)
		case "terraform":
				err = unpopulate(val, "Terraform", &r.Terraform)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecipeGetMetadata.
func (r RecipeGetMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "resourceType", r.ResourceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecipeGetMetadata.
func (r *RecipeGetMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "resourceType":
				err = unpopulate(val, "ResourceType", &r.ResourceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecipeGetMetadataResponse.
func (r RecipeGetMetadataResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", r.Parameters)
	populate(objectMap, "plainHttp", r.PlainHTTP)
	populate(objectMap, "templateKind", r.TemplateKind)
	populate(objectMap, "templatePath", r.TemplatePath)
	populate(objectMap, "templateVersion", r.TemplateVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecipeGetMetadataResponse.
func (r *RecipeGetMetadataResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
				err = unpopulate(val, "Parameters", &r.Parameters)
			delete(rawMsg, key)
		case "plainHttp":
				err = unpopulate(val, "PlainHTTP", &r.PlainHTTP)
			delete(rawMsg, key)
		case "templateKind":
				err = unpopulate(val, "TemplateKind", &r.TemplateKind)
			delete(rawMsg, key)
		case "templatePath":
				err = unpopulate(val, "TemplatePath", &r.TemplatePath)
			delete(rawMsg, key)
		case "templateVersion":
				err = unpopulate(val, "TemplateVersion", &r.TemplateVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecipeProperties.
func (r RecipeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", r.Parameters)
	objectMap["templateKind"] = r.TemplateKind
	populate(objectMap, "templatePath", r.TemplatePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecipeProperties.
func (r *RecipeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
				err = unpopulate(val, "Parameters", &r.Parameters)
			delete(rawMsg, key)
		case "templateKind":
				err = unpopulate(val, "TemplateKind", &r.TemplateKind)
			delete(rawMsg, key)
		case "templatePath":
				err = unpopulate(val, "TemplatePath", &r.TemplatePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecipePropertiesUpdate.
func (r RecipePropertiesUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", r.Parameters)
	objectMap["templateKind"] = r.TemplateKind
	populate(objectMap, "templatePath", r.TemplatePath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecipePropertiesUpdate.
func (r *RecipePropertiesUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
				err = unpopulate(val, "Parameters", &r.Parameters)
			delete(rawMsg, key)
		case "templateKind":
				err = unpopulate(val, "TemplateKind", &r.TemplateKind)
			delete(rawMsg, key)
		case "templatePath":
				err = unpopulate(val, "TemplatePath", &r.TemplatePath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecipeStatus.
func (r RecipeStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "templateKind", r.TemplateKind)
	populate(objectMap, "templatePath", r.TemplatePath)
	populate(objectMap, "templateVersion", r.TemplateVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecipeStatus.
func (r *RecipeStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "templateKind":
				err = unpopulate(val, "TemplateKind", &r.TemplateKind)
			delete(rawMsg, key)
		case "templatePath":
				err = unpopulate(val, "TemplatePath", &r.TemplatePath)
			delete(rawMsg, key)
		case "templateVersion":
				err = unpopulate(val, "TemplateVersion", &r.TemplateVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecipeUpdate.
func (r RecipeUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "parameters", r.Parameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecipeUpdate.
func (r *RecipeUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "parameters":
				err = unpopulate(val, "Parameters", &r.Parameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Resource.
func (r *Resource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &r.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceReference.
func (r ResourceReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", r.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceReference.
func (r *ResourceReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceStatus.
func (r ResourceStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compute", r.Compute)
	populate(objectMap, "outputResources", r.OutputResources)
	populate(objectMap, "recipe", r.Recipe)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceStatus.
func (r *ResourceStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compute":
			r.Compute, err = unmarshalEnvironmentComputeClassification(val)
			delete(rawMsg, key)
		case "outputResources":
				err = unpopulate(val, "OutputResources", &r.OutputResources)
			delete(rawMsg, key)
		case "recipe":
				err = unpopulate(val, "Recipe", &r.Recipe)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RuntimesProperties.
func (r RuntimesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kubernetes", r.Kubernetes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuntimesProperties.
func (r *RuntimesProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kubernetes":
				err = unpopulate(val, "Kubernetes", &r.Kubernetes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretConfig.
func (s SecretConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secret", s.Secret)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretConfig.
func (s *SecretConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secret":
				err = unpopulate(val, "Secret", &s.Secret)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretObjectProperties.
func (s SecretObjectProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "alias", s.Alias)
	populate(objectMap, "encoding", s.Encoding)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "version", s.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretObjectProperties.
func (s *SecretObjectProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alias":
				err = unpopulate(val, "Alias", &s.Alias)
			delete(rawMsg, key)
		case "encoding":
				err = unpopulate(val, "Encoding", &s.Encoding)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &s.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretReference.
func (s SecretReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "key", s.Key)
	populate(objectMap, "source", s.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretReference.
func (s *SecretReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
				err = unpopulate(val, "Key", &s.Key)
			delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &s.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretReferenceUpdate.
func (s SecretReferenceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "key", s.Key)
	populate(objectMap, "source", s.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretReferenceUpdate.
func (s *SecretReferenceUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
				err = unpopulate(val, "Key", &s.Key)
			delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &s.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretStoreListSecretsResult.
func (s SecretStoreListSecretsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "data", s.Data)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretStoreListSecretsResult.
func (s *SecretStoreListSecretsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "data":
				err = unpopulate(val, "Data", &s.Data)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretStoreProperties.
func (s SecretStoreProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "application", s.Application)
	populate(objectMap, "data", s.Data)
	populate(objectMap, "environment", s.Environment)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "resource", s.Resource)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretStoreProperties.
func (s *SecretStoreProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &s.Application)
			delete(rawMsg, key)
		case "data":
				err = unpopulate(val, "Data", &s.Data)
			delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &s.Environment)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &s.ProvisioningState)
			delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, "Resource", &s.Resource)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &s.Status)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretStoreResource.
func (s SecretStoreResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretStoreResource.
func (s *SecretStoreResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &s.Location)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &s.SystemData)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &s.Tags)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretStoreResourceListResult.
func (s SecretStoreResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretStoreResourceListResult.
func (s *SecretStoreResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &s.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretStoreResourceUpdate.
func (s SecretStoreResourceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretStoreResourceUpdate.
func (s *SecretStoreResourceUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, "Properties", &s.Properties)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &s.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretStoreResourceUpdateProperties.
func (s SecretStoreResourceUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "application", s.Application)
	populate(objectMap, "data", s.Data)
	populate(objectMap, "environment", s.Environment)
	populate(objectMap, "resource", s.Resource)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretStoreResourceUpdateProperties.
func (s *SecretStoreResourceUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &s.Application)
			delete(rawMsg, key)
		case "data":
				err = unpopulate(val, "Data", &s.Data)
			delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &s.Environment)
			delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, "Resource", &s.Resource)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecretValueProperties.
func (s SecretValueProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encoding", s.Encoding)
	populate(objectMap, "value", s.Value)
	populate(objectMap, "valueFrom", s.ValueFrom)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretValueProperties.
func (s *SecretValueProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encoding":
				err = unpopulate(val, "Encoding", &s.Encoding)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		case "valueFrom":
				err = unpopulate(val, "ValueFrom", &s.ValueFrom)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
				err = unpopulateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
				err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
				err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
				err = unpopulateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
				err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
				err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TCPHealthProbeProperties.
func (t TCPHealthProbeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerPort", t.ContainerPort)
	populate(objectMap, "failureThreshold", t.FailureThreshold)
	populate(objectMap, "initialDelaySeconds", t.InitialDelaySeconds)
	objectMap["kind"] = "tcp"
	populate(objectMap, "periodSeconds", t.PeriodSeconds)
	populate(objectMap, "timeoutSeconds", t.TimeoutSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TCPHealthProbeProperties.
func (t *TCPHealthProbeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerPort":
				err = unpopulate(val, "ContainerPort", &t.ContainerPort)
			delete(rawMsg, key)
		case "failureThreshold":
				err = unpopulate(val, "FailureThreshold", &t.FailureThreshold)
			delete(rawMsg, key)
		case "initialDelaySeconds":
				err = unpopulate(val, "InitialDelaySeconds", &t.InitialDelaySeconds)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &t.Kind)
			delete(rawMsg, key)
		case "periodSeconds":
				err = unpopulate(val, "PeriodSeconds", &t.PeriodSeconds)
			delete(rawMsg, key)
		case "timeoutSeconds":
				err = unpopulate(val, "TimeoutSeconds", &t.TimeoutSeconds)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TerraformConfigProperties.
func (t TerraformConfigProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authentication", t.Authentication)
	populate(objectMap, "providers", t.Providers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TerraformConfigProperties.
func (t *TerraformConfigProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authentication":
				err = unpopulate(val, "Authentication", &t.Authentication)
			delete(rawMsg, key)
		case "providers":
				err = unpopulate(val, "Providers", &t.Providers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TerraformRecipeProperties.
func (t TerraformRecipeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", t.Parameters)
	objectMap["templateKind"] = "terraform"
	populate(objectMap, "templatePath", t.TemplatePath)
	populate(objectMap, "templateVersion", t.TemplateVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TerraformRecipeProperties.
func (t *TerraformRecipeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
				err = unpopulate(val, "Parameters", &t.Parameters)
			delete(rawMsg, key)
		case "templateKind":
				err = unpopulate(val, "TemplateKind", &t.TemplateKind)
			delete(rawMsg, key)
		case "templatePath":
				err = unpopulate(val, "TemplatePath", &t.TemplatePath)
			delete(rawMsg, key)
		case "templateVersion":
				err = unpopulate(val, "TemplateVersion", &t.TemplateVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TerraformRecipePropertiesUpdate.
func (t TerraformRecipePropertiesUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "parameters", t.Parameters)
	objectMap["templateKind"] = "terraform"
	populate(objectMap, "templatePath", t.TemplatePath)
	populate(objectMap, "templateVersion", t.TemplateVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TerraformRecipePropertiesUpdate.
func (t *TerraformRecipePropertiesUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "parameters":
				err = unpopulate(val, "Parameters", &t.Parameters)
			delete(rawMsg, key)
		case "templateKind":
				err = unpopulate(val, "TemplateKind", &t.TemplateKind)
			delete(rawMsg, key)
		case "templatePath":
				err = unpopulate(val, "TemplatePath", &t.TemplatePath)
			delete(rawMsg, key)
		case "templateVersion":
				err = unpopulate(val, "TemplateVersion", &t.TemplateVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TrackedResource.
func (t *TrackedResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &t.ID)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &t.Location)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &t.SystemData)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &t.Tags)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValueFromProperties.
func (v ValueFromProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "version", v.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValueFromProperties.
func (v *ValueFromProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &v.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Volume.
func (v Volume) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = v.Kind
	populate(objectMap, "mountPath", v.MountPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Volume.
func (v *Volume) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &v.Kind)
			delete(rawMsg, key)
		case "mountPath":
				err = unpopulate(val, "MountPath", &v.MountPath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VolumeProperties.
func (v VolumeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "application", v.Application)
	populate(objectMap, "environment", v.Environment)
	objectMap["kind"] = v.Kind
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "status", v.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeProperties.
func (v *VolumeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &v.Application)
			delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &v.Environment)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &v.Kind)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &v.ProvisioningState)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &v.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VolumeResource.
func (v VolumeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "location", v.Location)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "tags", v.Tags)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeResource.
func (v *VolumeResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &v.Location)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			v.Properties, err = unmarshalVolumePropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &v.SystemData)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &v.Tags)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VolumeResourceListResult.
func (v VolumeResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeResourceListResult.
func (v *VolumeResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &v.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &v.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VolumeResourceUpdate.
func (v VolumeResourceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "tags", v.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeResourceUpdate.
func (v *VolumeResourceUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
				err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &v.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VolumeResourceUpdateProperties.
func (v VolumeResourceUpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "application", v.Application)
	populate(objectMap, "environment", v.Environment)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeResourceUpdateProperties.
func (v *VolumeResourceUpdateProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "application":
				err = unpopulate(val, "Application", &v.Application)
			delete(rawMsg, key)
		case "environment":
				err = unpopulate(val, "Environment", &v.Environment)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

