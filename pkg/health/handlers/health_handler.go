// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package handlers

import (
	"context"
	"encoding/json"
	"time"

	"github.com/project-radius/radius/pkg/healthcontract"
)

// HealthHandler interface defines the health check methods that every resource kind will implement
//go:generate mockgen -destination=./mock_healthhandler.go -package=handlers -self_package github.com/project-radius/radius/pkg/health/handlers github.com/project-radius/radius/pkg/health/handlers HealthHandler

type HealthHandler interface {
	GetHealthState(ctx context.Context, registration HealthRegistration, options Options) HealthState
}

// HealthState is an update to the health of a resource. Can be used as either a push or pull model.
type HealthState struct {
	Registration            HealthRegistration
	HealthState             string
	HealthStateErrorDetails string
}

// HealthRegistration represents the internal contract of the health system for communicating with a handler.
type HealthRegistration struct {
	healthcontract.HealthResource

	// Token is an opaque string generated by the health system for internal tracking.
	Token string
}

// Possible values for HealthHandlerMode
// Kubernetes supports Push mode where K8s notifies the health service upon changes to the resource
// Azure supports Pull mode where the health service needs to actively poll for the health of the resource
const (
	HealthHandlerModePush = "Push"
	HealthHandlerModePull = "Pull"
)

type Options struct {
	// Poll interval as specified by the resource
	Interval time.Duration
	// Interval after which health state notification is sent out even if there are no state changes
	ForcedUpdateInterval time.Duration
	// Channel to communicate detected changes by the push mode watcher on to the health service
	WatchHealthChangesChannel chan<- HealthState
}

// NewHealthRegistration creates a HealthRegistration from a HealthResource
func NewHealthRegistration(resource healthcontract.HealthResource) (HealthRegistration, error) {
	// Next we'll create a registration - this is the type we'll use to communicate with the health handler that processes
	// this resource type.
	//
	// We use the JSON representation as a unique token. This gives us something to use as a key for lookups.
	b, err := json.Marshal(&resource)
	if err != nil {
		return HealthRegistration{}, nil
	}

	registration := HealthRegistration{
		HealthResource: resource,
		Token:          string(b),
	}

	return registration, nil
}
