//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package generated



import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"regexp"
	"strings"
	"time"
)



const (
	utcLayoutJSON = `"2006-01-02T15:04:05.999999999"`
	utcLayout     = "2006-01-02T15:04:05.999999999"
	rfc3339JSON   = `"` + time.RFC3339Nano + `"`
)

// Azure reports time in UTC but it doesn't include the 'Z' time zone suffix in some cases.
var tzOffsetRegex = regexp.MustCompile(`(Z|z|\+|-)(\d+:\d+)*"*$`)

type timeRFC3339 time.Time

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is converting a timeRFC3339 type into a JSON format. It does this by taking the timeRFC3339 type and 
//	converting it into a time.Time type, then using the MarshalJSON() function to convert it into a JSON format.
//
// </AiDoc: End of OpenAI comments>
func (t timeRFC3339) MarshalJSON() (json []byte, err error) {
	tt := time.Time(t)
	return tt.MarshalJSON()
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is converting a timeRFC3339 type into a byte array. It does this by using the time.Time type's 
//	MarshalText() function.
//
// </AiDoc: End of OpenAI comments>
func (t timeRFC3339) MarshalText() (text []byte, err error) {
	tt := time.Time(t)
	return tt.MarshalText()
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is used to unmarshal a JSON string into a timeRFC3339 object. It checks if the JSON string contains a 
//	timezone offset, and if it does, it uses the rfc3339JSON layout to parse the string. Otherwise, it uses the 
//	utcLayoutJSON layout.
//
// </AiDoc: End of OpenAI comments>
func (t *timeRFC3339) UnmarshalJSON(data []byte) error {
	layout := utcLayoutJSON
	if tzOffsetRegex.Match(data) {
		layout = rfc3339JSON
	}
	return t.Parse(layout, string(data))
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is used to unmarshal text into a timeRFC3339 type. It checks if the data contains a timezone offset, and 
//	if it does, it uses the time.RFC3339Nano layout to parse the data. Otherwise, it uses the utcLayout to parse the data.
//
// </AiDoc: End of OpenAI comments>
func (t *timeRFC3339) UnmarshalText(data []byte) (err error) {
	layout := utcLayout
	if tzOffsetRegex.Match(data) {
		layout = time.RFC3339Nano
	}
	return t.Parse(layout, string(data))
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	
 
//	This function takes a layout and a value as parameters and attempts to parse the value according to the layout. If 
//	successful, the parsed time is stored in the timeRFC3339 type and an error is returned.
//
// </AiDoc: End of OpenAI comments>
func (t *timeRFC3339) Parse(layout, value string) error {
	p, err := time.Parse(layout, strings.ToUpper(value))
	*t = timeRFC3339(p)
	return err
}


//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is populating a map with a key and a time value in RFC3339 format. It checks if the time value is nil, a 
//	null value, or a reflect value of nil, and if so, it sets the value in the map to nil. Otherwise, it sets the value in 
//	the map to the time value in RFC3339 format.
//
// </AiDoc: End of OpenAI comments>
func populateTimeRFC3339(m map[string]interface{}, k string, t *time.Time) {
	if t == nil {
		return
	} else if azcore.IsNullValue(t) {
		m[k] = nil
		return
	} else if reflect.ValueOf(t).IsNil() {
		return
	}
	m[k] = (*timeRFC3339)(t)
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The previous function is taking in a json.RawMessage, a string, and a pointer to a time.Time as parameters. It is then 
//	checking if the json.RawMessage is nil or equal to "null". If it is, it returns nil. Otherwise, it creates a timeRFC3339
//	 variable and attempts to unmarshal the json.RawMessage into it. If it is successful, it sets the pointer to the 
//	time.Time to the timeRFC3339 variable. If it is unsuccessful, it returns an error.
//
// </AiDoc: End of OpenAI comments>
func unpopulateTimeRFC3339(data json.RawMessage, fn string, t **time.Time) error {
	if data == nil || strings.EqualFold(string(data), "null") {
		return nil
	}
	var aux timeRFC3339
	if err := json.Unmarshal(data, &aux); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	*t = (*time.Time)(&aux)
	return nil
}
