// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package framework

import (
	"context"
	"strings"

	"github.com/project-radius/radius/pkg/cli"
	aws "github.com/project-radius/radius/pkg/cli/aws"
	"github.com/project-radius/radius/pkg/cli/azure"
	"github.com/project-radius/radius/pkg/cli/config"
	"github.com/project-radius/radius/pkg/cli/workspaces"
	"github.com/spf13/viper"
)

type ConfigHolder struct {
	ConfigFilePath  string
	Config          *viper.Viper
	DirectoryConfig *config.DirectoryConfig
}

type contextKey string

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function creates a new context key with a given purpose. The context key is a string that is prefixed with "radius 
//	context" and followed by the given purpose.
//
// </AiDoc: End of OpenAI comments>
func NewContextKey(purpose string) contextKey {
	return contextKey("radius context " + purpose)
}

// Fetches radius config from the viper context
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is retrieving a configuration object from a given context. It looks for a value associated with a specific
//	 key in the context, and if it finds it, it returns the configuration object associated with that key.
//
// </AiDoc: End of OpenAI comments>
func ConfigFromContext(ctx context.Context) *viper.Viper {
	holder := ctx.Value(NewContextKey("config")).(*ConfigHolder)
	if holder == nil {
		return nil
	}

	return holder.Config
}

//go:generate mockgen -destination=./mock_config.go -package=framework -self_package github.com/project-radius/radius/pkg/cli/framework github.com/project-radius/radius/pkg/cli/framework ConfigFileInterface

type ConfigFileInterface interface {
	ConfigFromContext(ctx context.Context) *viper.Viper
	SetDefaultWorkspace(ctx context.Context, config *viper.Viper, name string) error
	DeleteWorkspace(ctx context.Context, config *viper.Viper, name string) error
	EditWorkspaces(ctx context.Context, config *viper.Viper, workspace *workspaces.Workspace, providersList []any) error
}

var _ ConfigFileInterface = (*ConfigFileInterfaceImpl)(nil)

type ConfigFileInterfaceImpl struct {
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is used to set the default workspace in a configuration file. It takes in a context, a configuration file,
//	 and the name of the workspace to be set as the default. It then edits the workspace section of the configuration file 
//	to set the default workspace to the given name.
//
// </AiDoc: End of OpenAI comments>
func (i *ConfigFileInterfaceImpl) SetDefaultWorkspace(ctx context.Context, config *viper.Viper, name string) error {
	return cli.EditWorkspaces(ctx, config, func(section *cli.WorkspaceSection) error {
		section.Default = name
		return nil
	})
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	
 
//	This function deletes a workspace from a configuration file. It takes in a context, a configuration file, and the name 
//	of the workspace to be deleted. It then edits the workspace section of the configuration file, deleting the workspace 
//	with the given name and setting the default workspace to an empty string if the deleted workspace was the default.
//
// </AiDoc: End of OpenAI comments>
func (i *ConfigFileInterfaceImpl) DeleteWorkspace(ctx context.Context, config *viper.Viper, name string) error {
	return cli.EditWorkspaces(ctx, config, func(section *cli.WorkspaceSection) error {
		delete(section.Items, strings.ToLower(name))
		if strings.EqualFold(section.Default, name) {
			section.Default = ""
		}

		return nil
	})
}

// Edits and updates the rad config file with the specified sections to edit
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is used to edit the workspaces in a configuration file. It takes in a context, a viper configuration, a 
//	workspace, and a list of providers as parameters. It then checks for duplicate workspace names and appends a random 
//	number if necessary. It then sets the default workspace to the name of the workspace and adds the workspace to the items
//	 in the configuration file. Finally, it returns an error if one occurs.
//
// </AiDoc: End of OpenAI comments>
func (i *ConfigFileInterfaceImpl) EditWorkspaces(ctx context.Context, config *viper.Viper, workspace *workspaces.Workspace, providersList []any) error {
	err := cli.EditWorkspaces(ctx, config, func(section *cli.WorkspaceSection) error {
		// TODO: Add checks for duplicate workspace names and append random number mechanisms
		workspace := workspace

		populateProvidersToWorkspace(workspace, providersList)

		name := strings.ToLower(workspace.Name)
		section.Default = name
		section.Items[name] = *workspace

		return nil
	})
	if err != nil {
		return err
	}
	return nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The function is looping through a list of providers and adding the relevant information to a workspace object. For each 
//	provider, it checks the type and then adds the appropriate information to the workspace object. For example, if the 
//	provider is an Azure provider, it adds the SubscriptionID and ResourceGroup to the workspace object. If the provider is 
//	an AWS provider, it adds the Region and AccountId to the workspace object.
//
// </AiDoc: End of OpenAI comments>
func populateProvidersToWorkspace(workspace *workspaces.Workspace, providersList []any) {
	for _, provider := range providersList {
		switch p := provider.(type) {
		case *azure.Provider:
			if p != nil {
				workspace.ProviderConfig.Azure = &workspaces.AzureProvider{
					SubscriptionID: p.SubscriptionID,
					ResourceGroup:  p.ResourceGroup,
				}
			}
		case *aws.Provider:
			if p != nil {
				workspace.ProviderConfig.AWS = &workspaces.AWSProvider{
					Region:    p.TargetRegion,
					AccountId: p.AccountId,
				}
			}
		}
	}
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is retrieving a configuration file from a given context and returning it as a viper object.
//
// </AiDoc: End of OpenAI comments>
func (i *ConfigFileInterfaceImpl) ConfigFromContext(ctx context.Context) *viper.Viper {
	return ConfigFromContext(ctx)
}
