// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package cli

import (
	"context"
	"errors"
	"fmt"
	"os"
	"path"
	"strings"
	"time"

	"github.com/go-playground/locales/en"
	ut "github.com/go-playground/universal-translator"
	validator "github.com/go-playground/validator/v10"
	en_translations "github.com/go-playground/validator/v10/translations/en"
	"github.com/gofrs/flock"
	"github.com/mitchellh/go-homedir"
	"github.com/spf13/viper"
	"golang.org/x/text/cases"

	"github.com/project-radius/radius/pkg/cli/output"
	"github.com/project-radius/radius/pkg/cli/workspaces"
)

// EnvironmentKey is the key used for the environment section
const (
	ApplicationKey string = "application"
	WorkspacesKey  string = "workspaces"
)

type WorkspaceSection struct {
	Default string                          `json:"default" mapstructure:"default" yaml:"default"`
	Items   map[string]workspaces.Workspace `json:"items" mapstructure:"items" yaml:"items" validate:"dive"`
}

// HasWorkspace returns true if the specified workspace already exists. This function ignores the default workspace.
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function checks if a workspace with a given name exists in the WorkspaceSection. It does this by checking if the 
//	name is present in the Items map of the WorkspaceSection. It returns a boolean value indicating if the workspace exists 
//	or not.
//
// </AiDoc: End of OpenAI comments>
func (ws WorkspaceSection) HasWorkspace(name string) bool {
	_, ok := ws.Items[cases.Fold().String(name)]
	return ok
}

// GetWorkspace returns the specified workspace or the default workspace if 'name' is empty.
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is getting a workspace from a workspace section, given a name. If no name is provided, it will use the 
//	default workspace. If the workspace exists, it will return the workspace, otherwise it will return an error.
//
// </AiDoc: End of OpenAI comments>
func (ws WorkspaceSection) GetWorkspace(name string) (*workspaces.Workspace, error) {
	if name == "" && ws.Default == "" {
		return nil, nil
	} else if name == "" {
		name = ws.Default
	}

	result, ok := ws.Items[cases.Fold().String(name)]
	if !ok {
		return nil, fmt.Errorf("the workspace '%v' does not exist. use `rad init` or `rad workspace create` and try again", name)
	}

	return &result, nil
}

// ReadWorkspaceSection reads the WorkspaceSection from radius config.
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is reading a WorkspaceSection from a Viper configuration file. It checks if the WorkspacesKey is present 
//	in the configuration file, and if it is, it unmarshals the exact data into the WorkspaceSection. If the WorkspacesKey is
//	 not present, it checks if the key was set directly to one of the structs, and if it was, it reads that data into the 
//	WorkspaceSection. It then checks if the Items field is present, and if it is not, it sets it to an empty map. Finally, 
//	it sets the Name and Source fields for each Workspace in the Items map, and validates the WorkspaceSection.
//
// </AiDoc: End of OpenAI comments>
func ReadWorkspaceSection(v *viper.Viper) (WorkspaceSection, error) {
	section := WorkspaceSection{}
	s := v.Sub(WorkspacesKey)
	if s == nil {
		// This may happen if the key was set directly to one of our structs, so let's try reading
		// that.
		obj := v.Get(WorkspacesKey)
		if obj == nil {
			// OK really nil, return a blank config.
			return WorkspaceSection{Items: map[string]workspaces.Workspace{}}, nil
		}

		s, ok := obj.(WorkspaceSection)
		if !ok {
			return WorkspaceSection{}, fmt.Errorf("failed to read the config file: %s", v.ConfigFileUsed())
		}

		section = s
	} else {
		err := s.UnmarshalExact(&section)
		if err != nil {
			return WorkspaceSection{}, err
		}
	}

	// if items is not present it will be nil
	if section.Items == nil {
		section.Items = map[string]workspaces.Workspace{}
	}

	for name, ws := range section.Items {
		copy := ws

		// The names of the workspace aren't serialized to the configuration in the same
		// way, so set the field here.
		copy.Name = name

		// We also want to make it clear these workspaces came from the per-user (config.yaml)
		// file.
		copy.Source = workspaces.SourceUserConfig

		section.Items[name] = copy
	}

	err := validate(section)
	if err != nil {
		return WorkspaceSection{}, err
	}

	return section, nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is updating a section of a viper configuration with a new workspace section.
//
// </AiDoc: End of OpenAI comments>
func UpdateWorkspaceSection(v *viper.Viper, section WorkspaceSection) {
	v.Set(WorkspacesKey, section)
}

// HasWorkspace returns true if the specified workspace already exists. This function ignores the default workspace.
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function checks if a workspace with a given name exists in a viper configuration. It reads the workspace section of
//	 the viper configuration and then checks if the workspace exists in that section.
//
// </AiDoc: End of OpenAI comments>
func HasWorkspace(v *viper.Viper, name string) (bool, error) {
	section, err := ReadWorkspaceSection(v)
	if err != nil {
		return false, err
	}

	return section.HasWorkspace(name), nil
}

// GetWorkspace returns the specified workspace or the default workspace in configuration if 'name' is empty.
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is retrieving a workspace from a viper configuration file, given the name of the workspace. It first reads
//	 the workspace section of the configuration file, and then uses that to get the workspace with the given name.
//
// </AiDoc: End of OpenAI comments>
func GetWorkspace(v *viper.Viper, name string) (*workspaces.Workspace, error) {
	section, err := ReadWorkspaceSection(v)
	if err != nil {
		return nil, err
	}

	return section.GetWorkspace(name)
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is creating a new Viper configuration object and setting the configuration file path. If no configuration 
//	file path is provided, it will use the home directory and look for a file named "config" in the ".rad" folder. 
//	Otherwise, it will use the provided configuration file path.
//
// </AiDoc: End of OpenAI comments>
func getConfig(configFilePath string) *viper.Viper {
	config := viper.New()

	if configFilePath == "" {
		// Set config file using the HOME directory.
		home, err := homedir.Dir()
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}

		rad := path.Join(home, ".rad")
		config.AddConfigPath(rad)
		config.SetConfigName("config")
	} else {
		config.SetConfigFile(configFilePath)
	}
	return config
}

// Create a config if its not present
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is creating a configuration file at the specified path. It first checks if the directory of the specified 
//	path exists, and if it does not, it creates the directory. If the directory does exist, it checks if there are any 
//	errors. If there are no errors, the function will return nil.
//
// </AiDoc: End of OpenAI comments>
func createConfigFile(configFilePath string) error {
	dir := path.Dir(configFilePath)
	_, err := os.Stat(dir)
	if os.IsNotExist(err) {
		err := os.MkdirAll(dir, os.ModeDir|0755)
		if err != nil {
			return fmt.Errorf("failed to create directory '%s': %w", dir, err)
		}
	} else if err != nil {
		return fmt.Errorf("failed to find directory '%s': %w", dir, err)
	}
	return nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is loading a configuration file from the given file path. It first checks if the config file exists, and 
//	if not, it creates one. It then reads the config file and returns the configuration. If there is an error, it is 
//	returned.
//
// </AiDoc: End of OpenAI comments>
func LoadConfigNoLock(configFilePath string) (*viper.Viper, error) {
	config := getConfig(configFilePath)
	configFile := GetConfigFilePath(config)
	// On Ubuntu OS,  getConfig() function doesnt create a config file if its not present.
	err := createConfigFile(configFile)
	if err != nil {
		return nil, err
	}
	err = config.ReadInConfig()
	if _, ok := err.(viper.ConfigFileNotFoundError); ok {
		// It's ok the config file is not found, this could be the first time the CLI
		// is running. Commands that require configuration will check for the data they need.
	} else if os.IsNotExist(err) {
		// It's ok the config file is not found, this could be the first time the CLI
		// is running. Commands that require configuration will check for the data they need.
	} else if err != nil {
		return nil, err
	}

	return config, nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is loading a configuration file from a given path. It first checks if the file exists, and if not, it 
//	creates it. It then acquires a shared lock on the file, and reads in the configuration. If the file does not exist, it 
//	is ok, as commands that require configuration will check for the data they need. Finally, it returns the configuration 
//	and any errors that may have occurred.
//
// </AiDoc: End of OpenAI comments>
func LoadConfig(configFilePath string) (*viper.Viper, error) {
	config := getConfig(configFilePath)
	configFile := GetConfigFilePath(config)

	// On Ubuntu OS,  getConfig() function doesnt create a config file if its not present.
	err := createConfigFile(configFile)
	if err != nil {
		return nil, err
	}
	// Acquire shared lock on the config.yaml.lock file.
	// Retry it every second for 5 times if other goroutine is holding the lock i.e other cmd is writing to the config file.
	// created a new file config.yaml.lock as windows os doesnt let us acuire lock on a file i.e config.yaml and write to it.
	fileLock := flock.New(configFile + ".lock")
	lockCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	_, err = fileLock.TryRLockContext(lockCtx, 1*time.Second)
	if err != nil {
		return nil, fmt.Errorf("failed to acquire lock on '%s': %w", configFile, err)
	}

	defer func() {
		err = fileLock.Unlock()
		if err != nil {
			output.LogInfo("failed to release lock on the config file : %s", configFile)
		}
	}()

	err = config.ReadInConfig()
	if _, ok := err.(viper.ConfigFileNotFoundError); ok {
		// It's ok the config file is not found, this could be the first time the CLI
		// is running. Commands that require configuration will check for the data they need.
	} else if os.IsNotExist(err) {
		// It's ok the config file is not found, this could be the first time the CLI
		// is running. Commands that require configuration will check for the data they need.
	} else if err != nil {
		return nil, err
	}

	return config, nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is getting the path of the configuration file used by the Viper library. If the configuration file is not 
//	set, it will set the configuration file path to the home directory of the user.
//
// </AiDoc: End of OpenAI comments>
func GetConfigFilePath(v *viper.Viper) string {
	configFilePath := v.ConfigFileUsed()
	if configFilePath == "" {
		// Set config file using the HOME directory.
		home, err := homedir.Dir()
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}

		configFilePath = path.Join(home, ".rad", "config.yaml")
	}
	return configFilePath
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The function is updating the Azure provider configuration for a workspace section. It takes in a workspace section, an 
//	Azure provider, and a context name as parameters. It then iterates through the items in the workspace section and checks
//	 if the item has the same Kubernetes context as the context name provided. If it does, it updates the workspace item's 
//	provider configuration with the Azure provider provided.
//
// </AiDoc: End of OpenAI comments>
func UpdateAzProvider(section *WorkspaceSection, provider workspaces.AzureProvider, contextName string) {
	for _, workspaceItem := range section.Items {
		if workspaceItem.IsSameKubernetesContext(contextName) {
			workspaceName := workspaceItem.Name
			workspaceItem.ProviderConfig.Azure = &workspaces.AzureProvider{
				ResourceGroup:  provider.ResourceGroup,
				SubscriptionID: provider.SubscriptionID,
			}
			section.Items[workspaceName] = workspaceItem
		}
	}
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The function is updating the AWSProvider for a given workspace section. It takes in a WorkspaceSection, an AWSProvider, 
//	and a context name as parameters. It then iterates through the items in the WorkspaceSection and checks if the item has 
//	the same Kubernetes context as the one provided. If it does, it updates the AWSProvider for that item with the one 
//	provided as a parameter.
//
// </AiDoc: End of OpenAI comments>
func UpdateAWSProvider(section *WorkspaceSection, provider workspaces.AWSProvider, contextName string) {
	for _, workspaceItem := range section.Items {
		if workspaceItem.IsSameKubernetesContext(contextName) {
			workspaceName := workspaceItem.Name
			workspaceItem.ProviderConfig.AWS = &workspaces.AWSProvider{
				AccountId: provider.AccountId,
				Region:    provider.Region,
			}
			section.Items[workspaceName] = workspaceItem
		}
	}
}

// Required to be called while holding the exclusive lock on config.yaml.lock file.
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function allows the user to edit the workspaces section of a configuration file. It takes in a context, a 
//	configuration file, and a function that will be used to edit the workspaces section. It then checks for any duplicate 
//	workspaces with different casings, and if none are found, it updates the workspaces section with the new changes.
//
// </AiDoc: End of OpenAI comments>
func EditWorkspaces(ctx context.Context, config *viper.Viper, editor func(section *WorkspaceSection) error) error {
	return SaveConfigOnLock(ctx, config, func(v *viper.Viper) error {
		section, err := ReadWorkspaceSection(v)
		if err != nil {
			return err
		}

		err = editor(&section)
		if err != nil {
			return err
		}

		// We need to check the workspaces for case-invariance. Viper stores everything as lowercase but it's
		// possible for us to introduce bugs by creating duplicates. This section is only here so that we can easily identify a bug
		// in the code that's calling EditWorkspaces.
		names := map[string]bool{}
		for name := range section.Items {
			name = strings.ToLower(name)
			_, ok := names[name]
			if ok {
				return fmt.Errorf("usage of name %q with different casings found. This is a bug in rad, the caller needs to lowercase the name before storage", name)
			}

			names[name] = true
		}

		UpdateWorkspaceSection(v, section)
		return nil
	})
}

// Save Config with exclusive lock on the config file
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is used to save a configuration file while acquiring an exclusive lock on it. It will try to acquire the 
//	lock for 5 seconds, and if it is unable to do so, it will return an error. If it is able to acquire the lock, it will 
//	call the updateConfig function to update the configuration, and then save the configuration file. Finally, it will 
//	release the lock.
//
// </AiDoc: End of OpenAI comments>
func SaveConfigOnLock(ctx context.Context, config *viper.Viper, updateConfig func(*viper.Viper) error) error {
	// Acquire exclusive lock on the config.yaml.lock file.
	// Retry it every second for 5 times if other goroutine is holding the lock i.e other cmd is writing to the config file.
	configFilePath := GetConfigFilePath(config)
	fileLock := flock.New(configFilePath + ".lock")
	lockCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()
	_, err := fileLock.TryLockContext(lockCtx, 1*time.Second)
	if err != nil {
		return fmt.Errorf("failed to acquire lock on '%s': %w", configFilePath, err)
	}

	defer func() {
		err = fileLock.Unlock()
		if err != nil {
			output.LogInfo("failed to release lock on the config file : %s", configFilePath)
		}
	}()
	err = updateConfig(config)
	if err != nil {
		return err
	}
	err = SaveConfig(config)
	if err != nil {
		return err
	}
	return nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is saving the configuration settings stored in a Viper object to a file. It first gets the path of the 
//	file to save the configuration to, then writes the configuration to the file and prints a success message.
//
// </AiDoc: End of OpenAI comments>
func SaveConfig(v *viper.Viper) error {
	configFilePath := GetConfigFilePath(v)

	err := v.WriteConfigAs(configFilePath)
	if err != nil {
		return fmt.Errorf("failed to write config to '%s': %w", configFilePath, err)
	}

	fmt.Printf("Successfully wrote configuration to %v\n", configFilePath)

	return nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is validating a given value. It is using a validator library to check if the value is valid according to 
//	certain criteria. It is also using a translator library to translate any errors that may occur during the validation 
//	process.
//
// </AiDoc: End of OpenAI comments>
func validate(value any) error {
	english := en.New()
	uni := ut.New(english, english)
	trans, _ := uni.GetTranslator("en")

	val := validator.New()
	err := en_translations.RegisterDefaultTranslations(val, trans)
	if err != nil {
		return err
	}

	err = val.Struct(value)
	if err != nil {
		return translateError(err, trans)
	}

	return nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	
 
//	The function is taking an error and a translator as parameters and returning an error. It is looping through the 
//	validation errors and translating them using the translator. It then joins the translated messages together and returns 
//	a new error with the joined messages.
//
// </AiDoc: End of OpenAI comments>
func translateError(err error, trans ut.Translator) error {
	if err == nil {
		return nil
	}

	messages := []string{}
	for _, e := range err.(validator.ValidationErrors) {
		translated := e.Translate(trans)
		messages = append(messages, translated)
	}

	return errors.New(strings.Join(messages, ", "))
}
