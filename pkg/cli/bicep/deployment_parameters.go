// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package bicep

import (
	"encoding/json"
	"fmt"
	"io/fs"
	"os"
	"strings"

	"github.com/project-radius/radius/pkg/cli/clients"
)

// ParameterParser is used to parse the parameters as part of the `rad deploy` command. See the docs for `rad deploy` for examples
// of what we need to support here.
type ParameterParser struct {
	FileSystem fs.FS
}

type OSFileSystem struct {
}

type ParameterFile struct {
	Parameters clients.DeploymentParameters `json:"parameters"`
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is opening a file with the given name using the operating system's file system. It returns a file object 
//	and an error if there is one.
//
// </AiDoc: End of OpenAI comments>
func (OSFileSystem) Open(name string) (fs.File, error) {
	return os.Open(name)
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function takes in a map of strings and any type as an input and returns a DeploymentParameters object and an error.
//	 It first marshals the input into a JSON object, then it unmarshals the parameters into the output object. If there is 
//	an error, it will be returned.
//
// </AiDoc: End of OpenAI comments>
func (pp ParameterParser) ParseFileContents(input map[string]any) (clients.DeploymentParameters, error) {
	output := clients.DeploymentParameters{}

	b, err := json.Marshal(input)
	if err != nil {
		return nil, err
	}

	err = pp.unmarshalParameters(b, output)
	if err != nil {
		return nil, err
	}

	return output, err
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The function is taking in a list of strings as inputs and returning a DeploymentParameters object. It is looping through
//	 the list of strings and merging the parameters with the later ones taking precedence. It is also handling any errors 
//	that may occur while processing the parameters.
//
// </AiDoc: End of OpenAI comments>
func (pp ParameterParser) Parse(inputs ...string) (clients.DeploymentParameters, error) {
	output := clients.DeploymentParameters{}
	for _, input := range inputs {
		// Parameters get merged with the later ones taking precendence. ParseSingleParameter handles
		// this logic.
		err := pp.parseSingle(input, output)
		if err != nil {
			return nil, fmt.Errorf("failed to process parameter %q: %w", input, err)
		}
	}

	return output, nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The previous function is parsing a single parameter from a string. It checks if the parameter is a file that declares 
//	multiple parameters, a file that declares a single parameter, or an inline string. If the parameter is a file, it reads 
//	the file and unmarshals the parameters. If the parameter is an inline string, it merges the single parameter with the 
//	output.
//
// </AiDoc: End of OpenAI comments>
func (pp ParameterParser) parseSingle(input string, output clients.DeploymentParameters) error {
	// Parameters come in one of three forms:
	//
	// --parameter @foo.json - declares multiple parameters
	// --parameter foo=@bar.json - declares a single parameter as JSON
	// --parameter foo=bar - declares a single parameter with a string value

	if strings.HasPrefix(input, "@") {
		// input is a file that declares multiple parameters
		filePath := strings.TrimPrefix(input, "@")
		b, err := fs.ReadFile(pp.FileSystem, filePath)
		if err != nil {
			return err
		}

		return pp.unmarshalParameters(b, output)
	}

	// If we get here the parameter needs to have a prefix. We'll split the parameter on the first =. This
	// we we avoid quoting issues.
	parts := strings.SplitN(input, "=", 2)
	if len(parts) != 2 {
		return fmt.Errorf("cannot parse parameter %q", input)
	}

	parameterName := parts[0]
	parameterValue := parts[1]

	if strings.HasPrefix(parameterValue, "@") {
		// input is a file that declares a single parameter
		filePath := strings.TrimPrefix(parameterValue, "@")
		b, err := fs.ReadFile(pp.FileSystem, filePath)
		if err != nil {
			return err
		}

		var data any
		err = json.Unmarshal(b, &data)
		if err != nil {
			return err
		}

		pp.mergeSingleParameter(output, parameterName, data)
		return nil
	}

	// input is an inline string
	pp.mergeSingleParameter(output, parameterName, parameterValue)
	return nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	
 
//	This function is taking in a byte array and a deployment parameters object, and using the JSON unmarshal function to 
//	convert the byte array into a parameter file object. It then uses the mergeParameters function to combine the parameters
//	 from the parameter file object with the deployment parameters object, and returns any errors that occur.
//
// </AiDoc: End of OpenAI comments>
func (pp ParameterParser) unmarshalParameters(b []byte, output clients.DeploymentParameters) error {

	data := ParameterFile{}
	err := json.Unmarshal(b, &data)
	if err != nil {
		return err
	}

	pp.mergeParameters(output, data.Parameters)
	return nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The previous function is taking two sets of deployment parameters and merging them together. It is overwriting any 
//	duplicate parameters with the values from the second set of parameters.
//
// </AiDoc: End of OpenAI comments>
func (pp ParameterParser) mergeParameters(output clients.DeploymentParameters, input clients.DeploymentParameters) {
	// We intentionally overwrite duplicates.
	for k, v := range input {
		output[k] = v
	}
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function takes in a DeploymentParameters object, a parameter name, and an input value of any type. It then adds the
//	 parameter name and the input value to the DeploymentParameters object, overwriting any existing values with the same 
//	parameter name.
//
// </AiDoc: End of OpenAI comments>
func (pp ParameterParser) mergeSingleParameter(output clients.DeploymentParameters, name string, input any) {
	// We intentionally overwrite duplicates.
	output[name] = NewParameter(input)
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The function is creating a new map with a single key-value pair. The key is "value" and the value is the parameter 
//	passed into the function.
//
// </AiDoc: End of OpenAI comments>
func NewParameter(value any) map[string]any {
	return map[string]any{
		"value": value,
	}
}
