// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package bicep

import (
	"fmt"
	"os"
	"path"
	"strings"

	"github.com/project-radius/radius/pkg/cli/output"
	"github.com/project-radius/radius/pkg/version"
)

// Interface is the interface for preparing Bicep or ARM-JSON templates for deployment. This interface
// is designed to be called from the CLI and will print output to the console.
type Interface interface {
	PrepareTemplate(filePath string) (map[string]any, error)
}

var _ Interface = (*Impl)(nil)

//go:generate mockgen -destination=./mock_bicep.go -package=bicep -self_package github.com/project-radius/radius/pkg/cli/bicep github.com/project-radius/radius/pkg/cli/bicep Interface

// Impl is the implementation of Interface.
type Impl struct {
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is checking if the file path provided is a .json or .bicep file. If it is a .bicep file, it checks if 
//	Bicep is installed and if not, it downloads it. It then checks if the file exists and if it does, it builds the 
//	template.
//
// </AiDoc: End of OpenAI comments>
func (*Impl) PrepareTemplate(filePath string) (map[string]any, error) {
	if strings.EqualFold(path.Ext(filePath), ".json") {
		return ReadARMJSON(filePath)
	} else if !strings.EqualFold(path.Ext(filePath), ".bicep") {
		return nil, fmt.Errorf("the provided file %q must be a .json or .bicep file", filePath)
	}

	ok, err := IsBicepInstalled()
	if err != nil {
		return nil, fmt.Errorf("failed to find rad-bicep: %w", err)
	}

	if !ok {
		output.LogInfo(fmt.Sprintf("Downloading Bicep for channel %s...", version.Channel()))
		err = DownloadBicep()
		if err != nil {
			return nil, fmt.Errorf("failed to download rad-bicep: %w", err)
		}
	}

	// Check the file manually so we can control the error message.
	_, err = os.Stat(filePath)
	if err != nil {
		return nil, fmt.Errorf("could not find file: %w", err)
	}

	step := output.BeginStep("Building %s...", filePath)
	template, err := Build(filePath)
	if err != nil {
		return nil, err
	}

	output.CompleteStep(step)
	return template, nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The function is taking in a map of strings to maps of strings to any type, and returning a map of strings to any type. 
//	It is doing this by looping through the input map and adding the value of each inner map to the output map, using the 
//	key of the inner map as the key for the output map.
//
// </AiDoc: End of OpenAI comments>
func ConvertToMapStringInterface(in map[string]map[string]any) map[string]any {
	result := make(map[string]any)
	for k, v := range in {
		result[k] = v["value"]
	}
	return result
}
