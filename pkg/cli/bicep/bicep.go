// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package bicep

import (
	"fmt"
	"net/http"
	"os"

	"github.com/project-radius/radius/pkg/cli/tools"
)

const radBicepEnvVar = "RAD_BICEP"
const binaryName = "rad-bicep"

// IsBicepInstalled returns true if our local copy of bicep is installed
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is checking if the Bicep binary is installed on the local machine. It does this by checking the 
//	environment variable for the local filepath of the binary, and then checking if the file exists in that location. If the
//	 file exists, it returns true, otherwise it returns false.
//
// </AiDoc: End of OpenAI comments>
func IsBicepInstalled() (bool, error) {
	filepath, err := tools.GetLocalFilepath(radBicepEnvVar, binaryName)
	if err != nil {
		return false, err
	}

	_, err = os.Stat(filepath)
	if err != nil && os.IsNotExist(err) {
		return false, nil
	} else if err != nil {
		return false, fmt.Errorf("error checking for %s: %v", filepath, err)
	}

	return true, nil
}

// DeleteBicep cleans our local copy of bicep
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is attempting to delete a file located at a filepath that is retrieved from an environment variable. If 
//	the file is successfully deleted, the function will return no error. If the file cannot be deleted, an error will be 
//	returned.
//
// </AiDoc: End of OpenAI comments>
func DeleteBicep() error {
	filepath, err := tools.GetLocalFilepath(radBicepEnvVar, binaryName)
	if err != nil {
		return err
	}

	err = os.Remove(filepath)
	if err != nil {
		return fmt.Errorf("failed to delete %s: %v", filepath, err)
	}

	return nil
}

// DownloadBicep updates our local copy of bicep
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is downloading the Bicep binary from a given URL and saving it to a local folder. It first builds the URL 
//	using a format string and then makes an HTTP request to the URL. It then checks the response status code and if it is 
//	successful, it downloads the binary to the local folder.
//
// </AiDoc: End of OpenAI comments>
func DownloadBicep() error {
	dirPrefix := "bicep-extensibility"
	// Placeholders are for: channel, platform, filename
	downloadURIFmt := fmt.Sprint("https://get.radapp.dev/tools/", dirPrefix, "/%s/%s/%s")

	uri, err := tools.GetDownloadURI(downloadURIFmt, binaryName)
	if err != nil {
		return err
	}

	resp, err := http.Get(uri)
	if err != nil {
		return fmt.Errorf("failed to download bicep: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("failed to download bicep from '%s'with status code: %d", uri, resp.StatusCode)
	}

	filepath, err := tools.GetLocalFilepath(radBicepEnvVar, binaryName)
	if err != nil {
		return err
	}

	return tools.DownloadToFolder(filepath, resp)
}
