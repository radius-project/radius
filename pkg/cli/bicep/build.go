// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package bicep

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"os/exec"
	"regexp"
	"strings"

	"github.com/project-radius/radius/pkg/cli/tools"
)

// Official regex for semver
// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string
const SemanticVersionRegex = `(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?`

// Run rad-bicep with the given args and return the stdout. The stderr
// is not capture but instead redirected to that of the current process.
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is checking if the rad-bicep tool is installed, and if it is, it is running the rad-bicep command with the
//	 given arguments. It is then creating a pipe to capture the output of the command and storing it in a buffer. Finally, 
//	it is reading the content of the buffer and returning it.
//
// </AiDoc: End of OpenAI comments>
func runBicepRaw(args ...string) ([]byte, error) {
	if installed, _ := IsBicepInstalled(); !installed {
		return nil, fmt.Errorf("rad-bicep not installed, run \"rad bicep download\" to install")
	}

	binPath, err := tools.GetLocalFilepath(radBicepEnvVar, binaryName)
	if err != nil {
		return nil, fmt.Errorf("failed to find rad-bicep: %w", err)
	}

	// runs 'rad-bicep'
	fullCmd := binPath + " " + strings.Join(args, " ")
	c := exec.Command(binPath, args...)
	c.Stderr = os.Stderr
	stdout, err := c.StdoutPipe()
	if err != nil {
		return nil, fmt.Errorf("failed to create pipe: %w", err)
	}

	err = c.Start()
	if err != nil {
		return nil, fmt.Errorf("failed executing %q: %w", fullCmd, err)
	}

	// asyncronously copy to our buffer, we don't really need to observe
	// errors here since it's copying into memory
	buf := bytes.Buffer{}
	go func() {
		_, _ = io.Copy(&buf, stdout)
	}()

	// Wait() will wait for us to finish draining stderr before returning the exit code
	err = c.Wait()
	if err != nil {
		return nil, fmt.Errorf("failed executing %q: %w", fullCmd, err)
	}

	// read the content
	bytes, err := io.ReadAll(&buf)
	if err != nil {
		return nil, fmt.Errorf("failed to read rad-bicep output: %w", err)
	}

	return bytes, nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is running the Bicep program with the given arguments and then parsing the output into a map of strings 
//	and any type. It then returns the map and any errors that occurred.
//
// </AiDoc: End of OpenAI comments>
func runBicepJson(args ...string) (map[string]any, error) {
	bytes, err := runBicepRaw(args...)
	if err != nil {
		return nil, err
	}

	template := map[string]any{}
	err = json.Unmarshal(bytes, &template)
	if err != nil {
		return nil, err
	}

	return template, err
}

// Build the provided `.bicep` file and returns the deployment template.
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is using the "runBicepJson" function to build a template from the file path provided. It will output the 
//	template to stdout and any compilation errors to stderr.
//
// </AiDoc: End of OpenAI comments>
func Build(filePath string) (map[string]any, error) {
	// rad-bicep is being told to output the template to stdout and we will capture it
	// rad-bicep will output compilation errors to stderr which will go to the user's console
	return runBicepJson("build", "--stdout", filePath)
}

// Return a Bicep version.
//
// In case we can't determine a version, output "unknown (<failure reason>)".
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is used to get the version of the Bicep program. It runs the Bicep program with the "--version" flag and 
//	then uses a regular expression to parse the version from the output. It then returns the version as a string.
//
// </AiDoc: End of OpenAI comments>
func Version() string {
	bytes, err := runBicepRaw("--version")
	if err != nil {
		return fmt.Sprintf("unknown (%s)", err)
	}

	version := regexp.MustCompile(SemanticVersionRegex).FindString(string(bytes))
	if version == "" {
		return fmt.Sprintf("unknown (failed to parse bicep version from %q)", string(bytes))
	}
	return version
}
