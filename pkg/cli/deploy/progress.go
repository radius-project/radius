// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package deploy

import (
	"fmt"
	"os"
	"sync"
	"time"

	"github.com/gosuri/uilive"
	"github.com/mattn/go-isatty"
	"github.com/project-radius/radius/pkg/cli/clients"
	"github.com/project-radius/radius/pkg/cli/output"
)

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function creates a new ProgressListener based on whether the output is being sent to a terminal or not. If the 
//	output is being sent to a terminal, an InteractiveListener is created, which will display a spinner to indicate 
//	progress. If the output is not being sent to a terminal, a NoOpListener is created, which will not display any progress.
//
// </AiDoc: End of OpenAI comments>
func NewProgressListener(progressChan <-chan clients.ResourceProgress) ProgressListener {
	if isatty.IsTerminal(os.Stdout.Fd()) {
		return &InteractiveListener{
			progressChan: progressChan,
			writerDone:   &sync.WaitGroup{},
			Spinner:      output.ProgressDefaultSpinner,
		}
	} else {
		return &NoOpListener{
			progressChan: progressChan,
		}
	}
}

type ProgressListener interface {
	// Run is called to print progress to the command line. This should be called from
	// a goroutine because it blocks until the progress channel is closed.
	Run()
}

type NoOpListener struct {
	progressChan <-chan clients.ResourceProgress
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is listening for updates on a progress channel and doing nothing with them except draining them.
//
// </AiDoc: End of OpenAI comments>
func (listener *NoOpListener) Run() {
	for range listener.progressChan {
		// Do nothing except drain the updates.
	}
}

type InteractiveListener struct {
	progressChan <-chan clients.ResourceProgress
	Spinner      []string
	mutex        sync.Mutex
	entries      []Entry
	spinnerIndex int
	writerDone   *sync.WaitGroup
}

type Entry struct {
	// FinalState is an optional token that will replace the spinner with static text.
	FinalState string

	// Format is the format string used to build the output line. It is expected to contain a placeholder
	// for the spinner/final-state token.
	Format string
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function adds an entry to the InteractiveListener object. It takes a string as an argument and appends it to the 
//	entries list. It then returns the index of the newly added entry.
//
// </AiDoc: End of OpenAI comments>
func (listener *InteractiveListener) addEntry(format string) int {
	listener.mutex.Lock()
	defer listener.mutex.Unlock()

	listener.entries = append(listener.entries, Entry{Format: format})
	return len(listener.entries) - 1
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is used to update an entry in the InteractiveListener struct. It takes in an index, a state, and a format 
//	as parameters. It then locks the mutex, updates the entry in the entries array at the given index with the given state 
//	and format, and then unlocks the mutex.
//
// </AiDoc: End of OpenAI comments>
func (listener *InteractiveListener) updateEntry(index int, state string, format string) {
	listener.mutex.Lock()
	defer listener.mutex.Unlock()

	listener.entries[index] = Entry{FinalState: state, Format: format}
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function runs a loop that updates a spinner position and writes output concurrently with accepting updates. It also
//	 stores resources that have already been seen in a map and processes updates to those resources. Finally, it forces a 
//	final UI update and drains any updates in progress.
//
// </AiDoc: End of OpenAI comments>
func (listener *InteractiveListener) Run() {
	ticker := time.NewTicker(500 * time.Millisecond)

	progressDone := make(chan struct{})
	writerDone := make(chan struct{})

	// Main loop that updates spinner position and writes output. This runs concurrently with accepting updates.
	go func() {
		writer := uilive.New()
		writer.Start()

		paint := func() {
			listener.mutex.Lock()

			// Advance to next spinner position
			listener.spinnerIndex = (listener.spinnerIndex + 1) % len(listener.Spinner)

			// Replay all output lines
			for _, entry := range listener.entries {
				if entry.FinalState == "" {
					fmt.Fprintf(writer.Newline(), entry.Format+"\n", listener.Spinner[listener.spinnerIndex])
				} else {
					fmt.Fprintf(writer.Newline(), entry.Format+"\n", entry.FinalState)
				}
			}
			listener.mutex.Unlock()
		}

	writer:
		for {
			select {
			case <-progressDone:
				paint() // Update UI once then terminate
				break writer
			case <-ticker.C:
				paint()
			}
		}

		writer.Stop()
		close(writerDone)
	}()

	// Storage for resources we've already 'seen'. This doesn't need to be accessed concurrently.
	resourceToLineIndexMap := map[string]int{}

	// Main loop that processes updates to resources. This runs concurrently with writing output.
	for update := range listener.progressChan {
		if !output.ShowResource(update.Resource) {
			continue
		}

		// NOTE: resources can go immediately to the Completed state without first
		// going to the started state.
		line, found := resourceToLineIndexMap[update.Resource.String()]
		if !found {
			line = listener.addEntry(output.FormatResourceForProgressDisplay(update.Resource))
			resourceToLineIndexMap[update.Resource.String()] = line
		}

		switch update.Status {
		case clients.StatusFailed:
			listener.updateEntry(line, output.ProgressFailed, output.FormatResourceForProgressDisplay(update.Resource))

		case clients.StatusCompleted:
			listener.updateEntry(line, output.ProgressCompleted, output.FormatResourceForProgressDisplay(update.Resource))
		}
	}

	// Force a final UI update and drain any updates in progress.
	ticker.Stop()
	close(progressDone)
	<-writerDone
}
