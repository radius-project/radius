// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package workspaces

import (
	"fmt"
	"net/url"
	"strings"

	"github.com/mitchellh/mapstructure"
	"github.com/project-radius/radius/pkg/cli/kubernetes"
	"github.com/project-radius/radius/pkg/sdk"
)

const KindKubernetes string = "kubernetes"

// MakeFallbackWorkspace creates an un-named workspace that will use the current KubeContext.
// This is is used in fallback cases where the user has no config.
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function creates a Workspace object with a source of "fallback" and a connection of type "Kubernetes" with an empty
//	 context.
//
// </AiDoc: End of OpenAI comments>
func MakeFallbackWorkspace() *Workspace {
	return &Workspace{
		Source: SourceFallback,
		Connection: map[string]any{
			"kind":    KindKubernetes,
			"context": "", // Default Kubernetes context
		},
	}
}

type ConnectionConfig interface {
	fmt.Stringer
	GetKind() string
	Connect() (sdk.Connection, error)
}

// FmtConnection can safely format connection info for display to users.
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The function is taking a Workspace object as an argument and returning a string. It is creating a connection 
//	configuration from the Workspace object and then formatting it into a string. If there is an error creating the 
//	connection configuration, it will return an error string.
//
// </AiDoc: End of OpenAI comments>
func (ws Workspace) FmtConnection() string {
	c, err := ws.ConnectionConfig()
	if err != nil {
		return fmt.Sprintf("err: %s", err)
	}

	return c.String()
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function takes in a Workspace object and returns a ConnectionConfig object. It checks if the Workspace object has a
//	 field called "kind" in its Connection field. If it does, it checks if the value of the "kind" field is a string. If it 
//	is, it checks the value of the "kind" field and depending on the value, it creates a KubernetesConnectionConfig object 
//	and decodes the Workspace object's Connection field into the KubernetesConnectionConfig object. If the value of the 
//	"kind" field is not supported, it returns an error.
//
// </AiDoc: End of OpenAI comments>
func (ws Workspace) ConnectionConfig() (ConnectionConfig, error) {
	obj, ok := ws.Connection["kind"]
	if !ok {
		return nil, fmt.Errorf("workspace is missing required field '$.connection.kind'")
	}

	kind, ok := obj.(string)
	if !ok {
		return nil, fmt.Errorf("workspace field '$.connection.kind' must be a string")
	}

	switch kind {
	case KindKubernetes:
		config := &KubernetesConnectionConfig{}
		decoder, err := mapstructure.NewDecoder(&mapstructure.DecoderConfig{ErrorUnused: true, Result: config})
		if err != nil {
			return nil, err
		}

		err = decoder.Decode(ws.Connection)
		if err != nil {
			return nil, err
		}

		return config, nil
	default:
		return nil, fmt.Errorf("unsupported connection kind '%s'", kind)
	}
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is attempting to establish a connection to a workspace using the connection configuration provided. It 
//	returns a connection and an error if one occurs.
//
// </AiDoc: End of OpenAI comments>
func (ws Workspace) Connect() (sdk.Connection, error) {
	connectionConfig, err := ws.ConnectionConfig()
	if err != nil {
		return nil, err
	}

	return connectionConfig.Connect()
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	
 
//	The function is comparing two ConnectionConfig objects to see if they are equal. It checks if the kind of the 
//	ConnectionConfig is Kubernetes and then checks if the Kubernetes context is the same. If both of these conditions are 
//	true, the function returns true, otherwise it returns false.
//
// </AiDoc: End of OpenAI comments>
func (ws Workspace) ConnectionConfigEquals(other ConnectionConfig) bool {
	switch other.GetKind() {
	case KindKubernetes:
		kc, ok := other.(*KubernetesConnectionConfig)
		if !ok {
			return false
		}

		return ws.Connection["kind"] == KindKubernetes && ws.IsSameKubernetesContext(kc.Context)
	default:
		return false
	}
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function checks if the workspace has a connection of type Kubernetes and if so, it returns the context of the 
//	connection as a string.
//
// </AiDoc: End of OpenAI comments>
func (ws Workspace) KubernetesContext() (string, bool) {
	if ws.Connection["kind"] != KindKubernetes {
		return "", false
	}

	obj, ok := ws.Connection["context"]
	if !ok {
		return "", false
	}

	str, ok := obj.(string)
	if !ok {
		return "", false
	}

	return str, true
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is comparing the "context" value of the "Connection" field of the Workspace struct to the given 
//	kubeContext string. It returns a boolean value indicating whether the two values are the same.
//
// </AiDoc: End of OpenAI comments>
func (ws Workspace) IsSameKubernetesContext(kubeContext string) bool {
	return ws.Connection["context"] == kubeContext
}

var _ ConnectionConfig = (*KubernetesConnectionConfig)(nil)

type KubernetesConnectionConfig struct {
	// Kind specifies the kind of connection. For KubernetesConnectionConfig this is always 'kubernetes'.
	Kind string `json:"kind" mapstructure:"kind" yaml:"kind"`

	// Context is the kubernetes kubeconfig context used to connect. The empty string is allowed as it
	// maps to the current kubeconfig context.
	Context string `json:"context" mapstructure:"context" yaml:"context"`

	// Overrides describes local overrides for testing purposes. This field is optional.
	Overrides KubernetesConnectionOverrides `json:"overrides,omitempty" mapstructure:"overrides" yaml:"overrides,omitempty"`
}

type KubernetesConnectionOverrides struct {
	// UCP describes an override for testing UCP. this field is optional.
	UCP string `json:"ucp" mapstructure:"ucp" yaml:"ucp"`
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is creating a string representation of a KubernetesConnectionConfig object. It is returning a string that 
//	includes the context of the object.
//
// </AiDoc: End of OpenAI comments>
func (c *KubernetesConnectionConfig) String() string {
	return fmt.Sprintf("Kubernetes (context=%s)", c.Context)
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	
 
//	This function returns the string "Kubernetes" which is used to identify the type of connection configuration.
//
// </AiDoc: End of OpenAI comments>
func (c *KubernetesConnectionConfig) GetKind() string {
	return KindKubernetes
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is connecting to a Kubernetes cluster. It first checks if the UCP (Universal Control Plane) is set, and if
//	 it is, it creates a direct connection to the UCP. If the UCP is not set, it gets the configuration from the Kubernetes 
//	context and creates a connection from that configuration.
//
// </AiDoc: End of OpenAI comments>
func (c *KubernetesConnectionConfig) Connect() (sdk.Connection, error) {
	if c.Overrides.UCP != "" {
		strURL := strings.TrimSuffix(c.Overrides.UCP, "/")
		strURL = strURL + "/apis/api.ucp.dev/v1alpha3"
		_, err := url.ParseRequestURI(strURL)
		if err != nil {
			return nil, err
		}
		return sdk.NewDirectConnection(strURL)
	}

	config, err := kubernetes.GetConfig(c.Context)
	if err != nil {
		return nil, err
	}

	return sdk.NewKubernetesConnectionFromConfig(config)
}
