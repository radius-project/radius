// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package portforward

import (
	"context"
	"testing"

	"github.com/project-radius/radius/pkg/kubernetes"
	"github.com/stretchr/testify/require"
	corev1 "k8s.io/api/core/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is testing the ability of a pod watcher to shut down gracefully. It creates a context, a pod, and a status
//	 channel, and then creates a new pod watcher with the given options. It then simulates success by setting the 
//	forwarderOverride to a fake forwarder. It then runs the pod watcher in a goroutine and listens for status messages on 
//	the status channel. It then cancels the context and listens for another status message. Finally, it checks that the 
//	expected messages were received and waits for the pod watcher to finish.
//
// </AiDoc: End of OpenAI comments>
func Test_podWatcher_CanShutdownGracefully(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())

	pod := &corev1.Pod{
		ObjectMeta: v1.ObjectMeta{
			Name: "test-app-test-container-abcd-efghij",
			Labels: map[string]string{
				kubernetes.LabelRadiusResource: "test-container",
			},
		},
		Status: corev1.PodStatus{
			Phase: corev1.PodRunning,
		},
		Spec: corev1.PodSpec{
			Containers: []corev1.Container{
				corev1.Container{
					Ports: []corev1.ContainerPort{
						corev1.ContainerPort{
							ContainerPort: 3000,
						},
					},
				},
			},
		},
	}

	statusChan := make(chan StatusMessage, 10)
	pw := NewPodWatcher(Options{StatusChan: statusChan}, pod, cancel)

	// Simulate success
	pw.forwarderOverride = NewFakeForwarder
	go func() { _ = pw.Run(ctx) }()

	messages := []StatusMessage{}
	messages = append(messages, <-statusChan)

	cancel()

	messages = append(messages, <-statusChan)

	expected := []StatusMessage{
		StatusMessage{
			Kind:          KindConnected,
			ContainerName: "test-container",
			ReplicaName:   "test-app-test-container-abcd-efghij",
			LocalPort:     3000,
			RemotePort:    3000,
		},
		StatusMessage{
			Kind:          KindDisconnected,
			ContainerName: "test-container",
			ReplicaName:   "test-app-test-container-abcd-efghij",
			LocalPort:     3000,
			RemotePort:    3000,
		},
	}
	require.Equal(t, expected, messages)
	pw.Wait()
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is testing the PodWatcher to ensure that it can start when the Pod is ready. It creates a context, a pod, 
//	and a status channel. It then creates a PodWatcher with the options and pod, and sets the forwarderOverride to a fake 
//	forwarder. It then sets the pod's status to running and sends the updated pod to the PodWatcher. It then reads the 
//	status messages from the status channel and checks that they match the expected messages. Finally, it cancels the 
//	context and waits for the PodWatcher to finish.
//
// </AiDoc: End of OpenAI comments>
func Test_podWatcher_CanStartWhenPodIsReady(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())

	pod := &corev1.Pod{
		ObjectMeta: v1.ObjectMeta{
			Name: "test-app-test-container-abcd-efghij",
			Labels: map[string]string{
				kubernetes.LabelRadiusResource: "test-container",
			},
		},
		Status: corev1.PodStatus{
			Phase: corev1.PodUnknown,
		},
		Spec: corev1.PodSpec{
			Containers: []corev1.Container{
				corev1.Container{
					Ports: []corev1.ContainerPort{
						corev1.ContainerPort{
							ContainerPort: 3000,
						},
					},
				},
			},
		},
	}

	statusChan := make(chan StatusMessage, 10) // Copy pod to avoid data-race
	pw := NewPodWatcher(Options{StatusChan: statusChan}, pod.DeepCopy(), cancel)

	// Simulate success
	pw.forwarderOverride = NewFakeForwarder
	go func() { _ = pw.Run(ctx) }()

	pod.Status.Phase = corev1.PodRunning
	pw.Updated <- pod.DeepCopy() // Copy to avoid data-race

	messages := []StatusMessage{}
	messages = append(messages, <-statusChan)

	cancel()

	messages = append(messages, <-statusChan)

	expected := []StatusMessage{
		StatusMessage{
			Kind:          KindConnected,
			ContainerName: "test-container",
			ReplicaName:   "test-app-test-container-abcd-efghij",
			LocalPort:     3000,
			RemotePort:    3000,
		},
		StatusMessage{
			Kind:          KindDisconnected,
			ContainerName: "test-container",
			ReplicaName:   "test-app-test-container-abcd-efghij",
			LocalPort:     3000,
			RemotePort:    3000,
		},
	}
	require.Equal(t, expected, messages)
	pw.Wait()
}
