// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------
package portforward

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	corev1 "k8s.io/api/core/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/kubernetes/fake"
	k8stest "k8s.io/client-go/testing"
)

// Unfortunately there isn't a good way to test the Run function. watchtools.NewRetryWatcher does not
// work with fake client. Instead we're writing unit tests for all of the state transitions and trying
// to keep the main event loop simple.

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is testing the DeploymentWatcher's Run function to ensure that it can be shut down correctly. It creates a
//	 fake client, a context with a cancel function, and a DeploymentWatcher with the fake client and the cancel function. It
//	 then starts the DeploymentWatcher in a goroutine and cancels it, then waits for it to finish.
//
// </AiDoc: End of OpenAI comments>
func Test_DeploymentWatcher_Run_CanShutDown(t *testing.T) {
	client, _ := createPodWatchFakes()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	dw := NewDeploymentWatcher(Options{Client: client}, map[string]string{}, map[string]bool{}, cancel)

	go func() { _ = dw.Run(ctx) }()
	cancel()
	dw.Wait()
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is testing the DeploymentWatcher's updated function. It creates a new DeploymentWatcher with some options,
//	 a map of strings and a map of booleans. It then calls the updated function with a context and a pod with the name "p1" 
//	and the resource "rs1". It then checks that the podWatcher's Pod name is equal to "p1" and then cancels the context.
//
// </AiDoc: End of OpenAI comments>
func Test_DeploymentWatcher_Updated_HandleNewDeployment(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	dw := NewDeploymentWatcher(Options{}, map[string]string{}, map[string]bool{}, cancel)
	defer stopPodWatchers(dw)

	dw.updated(ctx, createPod("p1", "rs1"))
	require.Equal(t, "p1", dw.podWatcher.Pod.Name)
	cancel()
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The previous function is testing the DeploymentWatcher's updated function. It creates a DeploymentWatcher with some 
//	options and maps, and then adds a pod with the name "p1" and replica set "rs1". It then checks that the pod watcher is 
//	not nil and that the pod watcher's pod name is "p1". It then adds another pod with the name "p2" and replica set "rs1" 
//	and checks that the same instance of the pod watcher is still being used.
//
// </AiDoc: End of OpenAI comments>
func Test_DeploymentWatcher_Updated_HandleMultipleReplicas(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	dw := NewDeploymentWatcher(Options{}, map[string]string{}, map[string]bool{}, cancel)
	defer stopPodWatchers(dw)

	// Step 1: Add a pod
	dw.updated(ctx, createPod("p1", "rs1"))
	require.NotNil(t, dw.podWatcher)
	require.Equal(t, dw.podWatcher.Pod.Name, "p1")
	existing := dw.podWatcher

	// Step 2: Add another pod - this won't start a new watcher
	dw.updated(ctx, createPod("p2", "rs1"))

	// Should be the same instance
	require.Same(t, existing, dw.podWatcher)
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is testing the DeploymentWatcher's updated function. It creates a context and a DeploymentWatcher with a 
//	stale pod. It then adds a pod to the DeploymentWatcher and checks that the podWatcher is nil. It then adds another pod 
//	and checks that the podWatcher is not nil and that the podWatcher is the same instance.
//
// </AiDoc: End of OpenAI comments>
func Test_DeploymentWatcher_Updated_HandleStalePod(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	stale := map[string]bool{
		"rs0": true,
	}

	dw := NewDeploymentWatcher(Options{}, map[string]string{}, stale, cancel)
	defer stopPodWatchers(dw)

	// Step 1: Add a pod (stale)
	dw.updated(ctx, createPod("p1", "rs0"))
	require.Nil(t, dw.podWatcher)

	// Step 2: Add another pod - this will start a watcher
	dw.updated(ctx, createPod("p2", "rs1"))

	// Should be the same instance
	require.NotNil(t, dw.podWatcher)
	require.Equal(t, "p2", dw.podWatcher.Pod.Name)
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is testing the DeploymentWatcher's updated function. It first adds a pod to the DeploymentWatcher, then 
//	updates the pod to set it as deleting. Finally, it checks that the podWatcher has been shutdown.
//
// </AiDoc: End of OpenAI comments>
func Test_DeploymentWatcher_Updated_HandleDeletingStateOfWatchedPod_NoOtherReplicas(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	dw := NewDeploymentWatcher(Options{}, map[string]string{}, map[string]bool{}, cancel)
	defer stopPodWatchers(dw)

	// Step 1: Add a pod
	dw.updated(ctx, createPod("p1", "rs1"))
	require.NotNil(t, dw.podWatcher)
	require.Equal(t, dw.podWatcher.Pod.Name, "p1")

	// Step 2: Update the pod to set it as deleting
	p1 := createPod("p1", "rs1")
	p1.DeletionTimestamp = &v1.Time{Time: time.Now()}
	dw.updated(ctx, p1)

	// Should be shutdown
	require.Nil(t, dw.podWatcher)
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is testing the DeploymentWatcher's updated function. It is testing the case where a pod is being watched 
//	and then is set to a deleting state, but there are other replicas of the pod. The function checks that the watcher is 
//	switched to the other replica and that the old watcher is stopped.
//
// </AiDoc: End of OpenAI comments>
func Test_DeploymentWatcher_Updated_HandleDeletingStateOfWatchedPod_HasOtherReplicas(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	dw := NewDeploymentWatcher(Options{}, map[string]string{}, map[string]bool{}, cancel)
	defer stopPodWatchers(dw)

	// Step 1: Add a pod
	dw.updated(ctx, createPod("p1", "rs1"))
	require.NotNil(t, dw.podWatcher)
	require.Equal(t, dw.podWatcher.Pod.Name, "p1")
	existing := dw.podWatcher

	// Step 2: Add another pod - this won't start a new watcher
	dw.updated(ctx, createPod("p2", "rs1"))

	// Should be the same instance
	require.Same(t, existing, dw.podWatcher)

	// Step 3: Update p1 to set it as deleting
	p1 := createPod("p1", "rs1")
	p1.DeletionTimestamp = &v1.Time{Time: time.Now()}
	dw.updated(ctx, p1)

	require.NotNil(t, dw.podWatcher)
	require.Equal(t, dw.podWatcher.Pod.Name, "p2")
	require.NotSame(t, existing, dw.podWatcher)

	existing.Wait()
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is testing the DeploymentWatcher's deleted function. It creates a new DeploymentWatcher, adds a pod to it,
//	 then deletes the pod. It then checks that the podWatcher has been shutdown and that the existing podWatcher has 
//	finished.
//
// </AiDoc: End of OpenAI comments>
func Test_DeploymentWatcher_Deleted_NoOtherReplicas(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	dw := NewDeploymentWatcher(Options{}, map[string]string{}, map[string]bool{}, cancel)
	defer stopPodWatchers(dw)

	// Step 1: Add a pod
	dw.updated(context.Background(), createPod("p1", "rs1"))
	require.NotNil(t, dw.podWatcher)
	require.Equal(t, dw.podWatcher.Pod.Name, "p1")
	existing := dw.podWatcher

	// Step 2: Delete the pod
	dw.deleted(ctx, createPod("p1", "rs1"))

	// Should be shutdown
	require.Nil(t, dw.podWatcher)

	existing.Wait()
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is testing the DeploymentWatcher to ensure that when a pod is deleted, the watcher is updated to the next 
//	pod if there are other replicas. It does this by first creating a pod, then adding another pod, and then deleting the 
//	first pod. It then checks that the watcher has been updated to the second pod.
//
// </AiDoc: End of OpenAI comments>
func Test_DeploymentWatcher_Deleted_HasOtherReplicas(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	dw := NewDeploymentWatcher(Options{}, map[string]string{}, map[string]bool{}, cancel)
	defer stopPodWatchers(dw)

	// Step 1: Add a pod
	dw.updated(ctx, createPod("p1", "rs1"))
	require.NotNil(t, dw.podWatcher)
	require.Equal(t, dw.podWatcher.Pod.Name, "p1")
	existing := dw.podWatcher

	// Step 2: Add another pod - this won't start a new watcher
	dw.updated(ctx, createPod("p2", "rs1"))

	// Should be the same instance
	require.Same(t, existing, dw.podWatcher)

	// Step 3: Delete the pod
	dw.deleted(ctx, createPod("p1", "rs1"))

	require.NotNil(t, dw.podWatcher)
	require.Equal(t, dw.podWatcher.Pod.Name, "p2")
	require.NotSame(t, existing, dw.podWatcher)

	existing.Wait()
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The previous function is testing the selectBestPod() function of the DeploymentWatcher. It is testing that the best pod 
//	is chosen based on the newest creation date, with name as a tiebreaker. It does this by creating three pods with 
//	different creation dates and names, and then calling the selectBestPod() function. It then checks that the pod with the 
//	newest creation date and the name "b" is chosen.
//
// </AiDoc: End of OpenAI comments>
func Test_DeploymentWatcher_SelectBestPod(t *testing.T) {
	dw := NewDeploymentWatcher(Options{}, map[string]string{}, map[string]bool{}, func() {})

	// The best pod is chosen based on the newest creation date, with name as a tiebreaker
	dw.pods = map[string]*corev1.Pod{
		"a": &corev1.Pod{ // Oldest
			ObjectMeta: v1.ObjectMeta{
				Name:              "a",
				CreationTimestamp: v1.NewTime(time.Date(2022, 1, 1, 0, 0, 0, 0, time.UTC)),
			},
		},
		"b": &corev1.Pod{ // Newest - chosen based on name
			ObjectMeta: v1.ObjectMeta{
				Name:              "b",
				CreationTimestamp: v1.NewTime(time.Date(2022, 2, 1, 0, 0, 0, 0, time.UTC)),
			},
		},
		"c": &corev1.Pod{ // Newest - not chosen based on name
			ObjectMeta: v1.ObjectMeta{
				Name:              "c",
				CreationTimestamp: v1.NewTime(time.Date(2022, 2, 1, 0, 0, 0, 0, time.UTC)),
			},
		},
	}
	actual := dw.selectBestPod()
	require.Same(t, dw.pods["b"], actual)
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is stopping a pod watcher. It checks if the pod watcher is not nil, and if it is not, it cancels the 
//	watcher and waits for it to finish.
//
// </AiDoc: End of OpenAI comments>
func stopPodWatchers(dw *deploymentWatcher) {
	if dw.podWatcher == nil {
		return
	}

	dw.podWatcher.Cancel()
	dw.podWatcher.Wait()
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The previous function is creating a Pod object with the given name and setting the owner reference to the given 
//	ReplicaSet name.
//
// </AiDoc: End of OpenAI comments>
func createPod(name string, replicaSetName string) *corev1.Pod {
	return &corev1.Pod{
		ObjectMeta: v1.ObjectMeta{
			Name: name,
			OwnerReferences: []v1.OwnerReference{
				{
					APIVersion: "v1",
					Kind:       "ReplicaSet",
					Name:       replicaSetName,
				},
			},
		},
	}
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function creates a fake clientset and a fake watcher for pods. It also adds a watch reactor to the fake clientset 
//	so that it can watch for changes in the pods.
//
// </AiDoc: End of OpenAI comments>
func createPodWatchFakes(objects ...runtime.Object) (*fake.Clientset, *watch.FakeWatcher) {
	client := fake.NewSimpleClientset(objects...)
	watcher := watch.NewFake()
	client.PrependWatchReactor("pods", k8stest.DefaultWatchReactor(watcher, nil))

	return client, watcher
}
