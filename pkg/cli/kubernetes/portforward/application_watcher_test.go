// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------
package portforward

import (
	"context"
	"testing"

	"github.com/stretchr/testify/require"
	appsv1 "k8s.io/api/apps/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/kubernetes/fake"
	k8stest "k8s.io/client-go/testing"
)

// Unfortunately there isn't a good way to test the Run function. watchtools.NewRetryWatcher does not
// work with fake client. Instead we're writing unit tests for all of the state transitions and trying
// to keep the main event loop simple.

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is testing the ApplicationWatcher's Run function to ensure that it can be shut down correctly. It creates 
//	a fake deployment watch, creates a context with a cancel function, and then creates an ApplicationWatcher with the fake 
//	client. It then starts the ApplicationWatcher in a goroutine and cancels the context, which should shut down the 
//	ApplicationWatcher. Finally, it waits for the ApplicationWatcher to finish.
//
// </AiDoc: End of OpenAI comments>
func Test_ApplicationWatcher_Run_CanShutDown(t *testing.T) {
	client, _ := createDeploymentWatchFakes()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	aw := NewApplicationWatcher(Options{ApplicationName: "test", Namespace: "default", Client: client})

	go func() { _ = aw.Run(ctx) }()
	cancel()
	aw.Wait()
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The previous function is creating a new ApplicationWatcher with a given client, and then adding a deployment watcher for
//	 a deployment with the name "test" and version "1".
//
// </AiDoc: End of OpenAI comments>
func Test_ApplicationWatcher_Updated_HandleNewDeployment(t *testing.T) {
	client, _ := createDeploymentWatchFakes()

	aw := NewApplicationWatcher(Options{Client: client})
	defer stopDeploymentWatchers(aw)

	aw.updated(context.Background(), createDeployment("test", "1"))
	require.Contains(t, aw.deploymentWatchers, "test")
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is testing the ApplicationWatcher's updated function to ensure that when a deployment is updated but the 
//	selector remains unchanged, the same instance of the deployment watcher is used.
//
// </AiDoc: End of OpenAI comments>
func Test_ApplicationWatcher_Updated_HandleUnchangedDeployment(t *testing.T) {
	client, _ := createDeploymentWatchFakes()

	aw := NewApplicationWatcher(Options{Client: client})
	defer stopDeploymentWatchers(aw)

	// Step 1: Add a deployment
	aw.updated(context.Background(), createDeployment("test", "1"))
	require.Contains(t, aw.deploymentWatchers, "test")
	existing := aw.deploymentWatchers["test"]

	// Step 2: Update the deployment but don't change the selector
	aw.updated(context.Background(), createDeployment("test", "1"))
	require.Contains(t, aw.deploymentWatchers, "test")
	updated := aw.deploymentWatchers["test"]

	// Should be the same instance
	require.Same(t, existing, updated)
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is testing the ApplicationWatcher's updated function. It creates a fake deployment and adds it to the 
//	ApplicationWatcher. It then updates the deployment and checks that the ApplicationWatcher has a new instance of the 
//	deployment watcher. It also checks that the first watcher has been canceled.
//
// </AiDoc: End of OpenAI comments>
func Test_ApplicationWatcher_Updated_HandleChangedDeployment(t *testing.T) {
	client, _ := createDeploymentWatchFakes()

	aw := NewApplicationWatcher(Options{Client: client})
	defer stopDeploymentWatchers(aw)

	// Step 1: Add a deployment
	aw.updated(context.Background(), createDeployment("test", "1"))
	require.Contains(t, aw.deploymentWatchers, "test")
	existing := aw.deploymentWatchers["test"]

	// Step 2: Update the deployment and change the selector
	aw.updated(context.Background(), createDeployment("test", "2"))

	require.Contains(t, aw.deploymentWatchers, "test")
	updated := aw.deploymentWatchers["test"]

	// Should not be the same instance
	require.NotSame(t, existing, updated)

	// first watcher should have been canceled
	existing.Wait()
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is testing the ApplicationWatcher's deleted function. It creates a fake client and a new 
//	ApplicationWatcher with the fake client. It then adds a deployment and checks that the deploymentWatchers map contains 
//	the deployment. It then deletes the deployment and checks that the deploymentWatchers map no longer contains the 
//	deployment. Finally, it checks that the watcher has been canceled.
//
// </AiDoc: End of OpenAI comments>
func Test_ApplicationWatcher_Deleted(t *testing.T) {
	client, _ := createDeploymentWatchFakes()

	aw := NewApplicationWatcher(Options{Client: client})
	defer stopDeploymentWatchers(aw)

	// Step 1: Add a deployment
	aw.updated(context.Background(), createDeployment("test", "1"))
	require.Contains(t, aw.deploymentWatchers, "test")
	existing := aw.deploymentWatchers["test"]

	// Step 2: Delete the deployment
	aw.deleted(context.Background(), createDeployment("test", "1"))
	require.NotContains(t, aw.deploymentWatchers, "test")

	// watcher should have been canceled
	existing.Wait()
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is stopping all of the deployment watchers associated with an application watcher. It is looping through 
//	all of the deployment watchers and cancelling them, then waiting for them to finish.
//
// </AiDoc: End of OpenAI comments>
func stopDeploymentWatchers(aw *applicationWatcher) {
	for _, entry := range aw.deploymentWatchers {
		entry.Cancel()
		entry.Wait()
	}
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The previous function creates a Deployment object in the Kubernetes API. It takes two parameters, a name and a value, 
//	and sets the name of the Deployment to the given name and sets the selector of the Deployment to match labels with the 
//	given value.
//
// </AiDoc: End of OpenAI comments>
func createDeployment(name string, value string) *appsv1.Deployment {
	return &appsv1.Deployment{
		ObjectMeta: v1.ObjectMeta{
			Name: name,
		},
		Spec: appsv1.DeploymentSpec{
			Selector: &v1.LabelSelector{
				MatchLabels: map[string]string{
					"a": value,
				},
			},
		},
	}
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function creates a fake Kubernetes client and a fake watcher for deployments. It also adds a watch reactor to the 
//	client so that it can watch for changes in deployments.
//
// </AiDoc: End of OpenAI comments>
func createDeploymentWatchFakes(objects ...runtime.Object) (*fake.Clientset, *watch.FakeWatcher) {
	client := fake.NewSimpleClientset(objects...)
	watcher := watch.NewFake()
	client.PrependWatchReactor("deployments", k8stest.DefaultWatchReactor(watcher, nil))

	return client, watcher
}
