// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package portforward

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net"
	"net/http"
	"strings"

	"github.com/project-radius/radius/pkg/kubernetes"
	corev1 "k8s.io/api/core/v1"
	clientgoportforward "k8s.io/client-go/tools/portforward"
	"k8s.io/client-go/transport/spdy"
)

type podWatcher struct {
	Cancel  func()
	Options Options
	Pod     *corev1.Pod
	Updated chan *corev1.Pod

	done      chan struct{}
	forwarder forwarder

	// forwarderOverride sets a test override for the port-forward instrastructure.
	// This allows us to test the rest of the functionality without testing actual network calls.
	forwarderOverride func(ports map[int32]bool) forwarder
	forwarderDone     chan error
	log               *bytes.Buffer
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function creates a new podWatcher object. It takes in options, a pod, and a cancel function as parameters. It 
//	creates a done channel, a forwarderDone channel, a log buffer, and an Updated channel. It then returns the podWatcher 
//	object.
//
// </AiDoc: End of OpenAI comments>
func NewPodWatcher(options Options, pod *corev1.Pod, cancel func()) *podWatcher {
	return &podWatcher{
		Cancel:  cancel,
		Options: options,
		Pod:     pod,

		done:          make(chan struct{}),
		forwarderDone: make(chan error),
		log:           &bytes.Buffer{},
		Updated:       make(chan *corev1.Pod),
	}
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The previous function is running a loop that watches for updates to a pod. It will bootstrap with the initial state of 
//	the pod and then handle any transitions from the pod not being ready to being ready. If the context is cancelled, the 
//	loop will end and the function will return an error.
//
// </AiDoc: End of OpenAI comments>
func (pw *podWatcher) Run(ctx context.Context) error {
	defer close(pw.done)

	// Bootstrap with initial state
	//
	// Ignore this error and keep trying if there's an issue.
	_ = pw.handleUpdate(ctx, pw.Pod)

	// Since Pods are immutable we only really need to handle one transition:
	// - The pod wasn't ready before but is ready now
	//
	// Everything else we can ignore.
	//
	// The shutdown case will be handled by cancellation of our context.
	//
	// We don't do retries for failed port-forwards.
	for {
		select {
		case <-ctx.Done():
			// Handles the case where we never started
			if pw.forwarder == nil {
				close(pw.forwarderDone)
			} else {
				<-pw.forwarderDone
			}

			return ctx.Err()

		case pod := <-pw.Updated:
			// Note: this is where we'd add retries if we wanted to.
			_ = pw.handleUpdate(ctx, pod)
		}
	}
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The previous function is handling an update to a pod. It checks if the pod is running and if it has any ports. If it 
//	does, it creates a forwarder and runs it in a goroutine.
//
// </AiDoc: End of OpenAI comments>
func (pw *podWatcher) handleUpdate(ctx context.Context, pod *corev1.Pod) error {
	// Already listening
	if pw.forwarder != nil {
		return nil
	}

	// PodRunning is used to detect whether the pod is started or not.
	if pod == nil || pod.Status.Phase != corev1.PodRunning {
		return nil
	}

	ports := map[int32]bool{}
	for _, container := range pod.Spec.Containers {
		for _, cp := range container.Ports {
			ports[cp.ContainerPort] = true
		}
	}

	// No ports == nothing to forward
	if len(ports) == 0 {
		return nil
	}

	forwarder, err := pw.createForwarder(ports, ctx.Done(), pw.log)
	if err != nil {
		return err
	}

	pw.forwarder = forwarder

	// Forwarder will run until faulted or canceled. Use a goroutine here to unblock the eventloop.
	go pw.runForwarder(ctx)
	return nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is running a forwarder which will send notifications when ports are ready. It will also send port 
//	notifications when the forwarder is connected or disconnected. Finally, it will close the forwarderDone channel when the
//	 forwarder is done running.
//
// </AiDoc: End of OpenAI comments>
func (pw *podWatcher) runForwarder(ctx context.Context) {

	// Send notifications when ports are ready
	go func() {
		<-pw.forwarder.Ready()
		pw.sendPortNotifications(pw.forwarder, KindConnected)
	}()

	err := pw.forwarder.Run(ctx)
	pw.forwarderDone <- err

	pw.sendPortNotifications(pw.forwarder, KindDisconnected)

	close(pw.forwarderDone)
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The previous function is sending notifications about the ports associated with a pod to a status channel. It first 
//	checks if the status channel is not nil, then it gets the container name and replica name from the pod's labels. If the 
//	container name is empty, it uses a heuristic to get the deployment name. It then gets the ports from the forwarder and 
//	sends a status message for each port to the status channel.
//
// </AiDoc: End of OpenAI comments>
func (pw *podWatcher) sendPortNotifications(forwarder forwarder, kind StatusKind) {
	if pw.Options.StatusChan != nil {
		// Use Radius container name if we have one.
		containerName := pw.Pod.Labels[kubernetes.LabelRadiusResource]
		replicaName := pw.Pod.Name

		// If this is not a Radius resource then use a hueristic to get the deployment name.
		if containerName == "" {
			containerName, _, _ = strings.Cut(replicaName, "-")
		}

		ports := pw.forwarder.GetPorts()

		for _, port := range ports {
			pw.Options.StatusChan <- StatusMessage{
				Kind:          kind,
				ContainerName: containerName,
				ReplicaName:   replicaName,
				LocalPort:     port.Local,
				RemotePort:    port.Remote,
			}
		}
	}
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The previous function is creating a forwarder for a pod in a Kubernetes cluster. It is setting up a connection between 
//	the pod and a localhost address, and then creating a listener for that connection. It is also setting up a dialer for 
//	the connection, and formatting the ports that will be used for the connection.
//
// </AiDoc: End of OpenAI comments>
func (pw *podWatcher) createForwarder(ports map[int32]bool, stopChan <-chan struct{}, output io.Writer) (forwarder, error) {
	if pw.forwarderOverride != nil {
		return pw.forwarderOverride(ports), nil
	}

	// Note: We don't really have a good way to test this code, besides E2E. This all interacts with real networks and ports
	// and requires a kubernetes config.

	transport, upgrader, err := spdy.RoundTripperFor(pw.Options.RESTConfig)
	if err != nil {
		return nil, err
	}

	url := pw.Options.Client.CoreV1().RESTClient().Post().
		Resource("pods").
		Namespace(pw.Pod.Namespace).
		Name(pw.Pod.Name).
		SubResource("portforward").URL()

	dialer := spdy.NewDialer(upgrader, &http.Client{Transport: transport}, "POST", url)

	formatted := []string{}
	for remotePort := range ports {
		spec := pw.selectLocalPort(remotePort)
		formatted = append(formatted, spec)
	}

	listener, err := clientgoportforward.NewOnAddresses(dialer, []string{"localhost"}, formatted, stopChan, make(chan struct{}), output, output)
	if err != nil {
		return nil, err
	}

	return &realforwarder{inner: listener}, nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The previous function is attempting to select a local port to use for a port forwarding connection. It first checks if 
//	the port is available to listen on locally, and if it is, it returns the port number as a string. If the port is not 
//	available, it returns a string with a colon followed by the port number, which will allow the portforwarder to pick a 
//	different port.
//
// </AiDoc: End of OpenAI comments>
func (pw *podWatcher) selectLocalPort(port int32) string {
	// We want to see if we can use the same port number for both local and remote because
	// this is simpler for users.
	//
	// First check if we can listen on the port locally.
	ln, err := net.Listen("tcp", fmt.Sprintf(":%d", port))

	// If there's no error we're ok!
	if err == nil {
		_ = ln.Close()
		return fmt.Sprintf("%d", port)
	}

	// If the best local port is in use then let the portforwarder pick one
	return fmt.Sprintf(":%d", port)
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	
 
//	The Wait() function is used to wait until the podWatcher is done. It will block until the done channel is closed.
//
// </AiDoc: End of OpenAI comments>
func (pw *podWatcher) Wait() {
	<-pw.done
}

type forwarder interface {
	Ready() <-chan struct{}
	Run(ctx context.Context) error
	GetPorts() []clientgoportforward.ForwardedPort
}

var _ forwarder = (*realforwarder)(nil)
var _ forwarder = (*fakeforwarder)(nil)

type realforwarder struct {
	inner *clientgoportforward.PortForwarder
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The function is returning a channel which will be used to indicate when the realforwarder is ready.
//
// </AiDoc: End of OpenAI comments>
func (f *realforwarder) Ready() <-chan struct{} {
	return f.inner.Ready
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is running a realforwarder, which is a type of forwarder that forwards ports. It is running the forwarder 
//	by calling the ForwardPorts() function of the inner forwarder.
//
// </AiDoc: End of OpenAI comments>
func (f *realforwarder) Run(ctx context.Context) error {
	return f.inner.ForwardPorts()
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is retrieving a list of ports that have been forwarded by the inner forwarder. It then returns this list 
//	of ports.
//
// </AiDoc: End of OpenAI comments>
func (f *realforwarder) GetPorts() []clientgoportforward.ForwardedPort {
	ports, err := f.inner.GetPorts()
	if err != nil {
		panic("this should not happen, we only call GetPorts after the forwarder is ready")
	}
	return ports
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function creates a new fake forwarder, which is a type of forwarder. It takes in a map of ports and adds each port 
//	to the list of ports for the fake forwarder. It also creates a channel for the fake forwarder to be ready.
//
// </AiDoc: End of OpenAI comments>
func NewFakeForwarder(ports map[int32]bool) forwarder {
	fake := &fakeforwarder{ready: make(chan struct{})}
	for port := range ports {
		fake.ports = append(fake.ports, clientgoportforward.ForwardedPort{Local: uint16(port), Remote: uint16(port)})
	}

	return fake
}

type fakeforwarder struct {
	ready chan struct{}
	ports []clientgoportforward.ForwardedPort
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The function is creating a channel that will be used to indicate when the fakeforwarder is ready.
//
// </AiDoc: End of OpenAI comments>
func (f *fakeforwarder) Ready() <-chan struct{} {
	return f.ready
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function creates a fakeforwarder and runs it in a given context. It also creates a channel called "ready" which is 
//	used to signal when the fakeforwarder is ready to be used. Finally, the function will wait until the context is done 
//	before returning.
//
// </AiDoc: End of OpenAI comments>
func (f *fakeforwarder) Run(ctx context.Context) error {
	close(f.ready)
	<-ctx.Done()
	return nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is returning a list of ports that have been forwarded by the fakeforwarder.
//
// </AiDoc: End of OpenAI comments>
func (f *fakeforwarder) GetPorts() []clientgoportforward.ForwardedPort {
	return f.ports
}
