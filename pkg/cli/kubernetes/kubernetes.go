// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package kubernetes

import (
	"context"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"time"

	contourv1 "github.com/projectcontour/contour/apis/projectcontour/v1"
	apiextv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	"k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	k8s_runtime "k8s.io/apimachinery/pkg/runtime"
	applycorev1 "k8s.io/client-go/applyconfigurations/core/v1"
	"k8s.io/client-go/discovery"
	memory "k8s.io/client-go/discovery/cached"
	"k8s.io/client-go/dynamic"
	k8s "k8s.io/client-go/kubernetes"
	clientgoscheme "k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/restmapper"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/tools/clientcmd/api"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/project-radius/radius/pkg/cli/output"
	runtime_client "sigs.k8s.io/controller-runtime/pkg/client"
)

var (
	Scheme = k8s_runtime.NewScheme()
)

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is adding all types to the client.Client scheme. This is necessary in order to add any new types to the 
//	radius.
//
// </AiDoc: End of OpenAI comments>
func init() {
	// Adds all types to the client.Client scheme
	// Any time we add a new type to to radius,
	// we need to add it here.
	// TODO centralize these calls.
	_ = apiextv1.AddToScheme(Scheme)
	_ = clientgoscheme.AddToScheme(Scheme)
	_ = contourv1.AddToScheme(Scheme)
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is attempting to read a kubeconfig file from the user's home directory. It first checks if the user has a 
//	home directory, and if so, it creates a path to the kubeconfig file. It then attempts to load the kubeconfig file from 
//	the path and returns the config and any errors that may have occurred.
//
// </AiDoc: End of OpenAI comments>
func ReadKubeConfig() (*api.Config, error) {
	var kubeConfig string
	if home := homeDir(); home != "" {
		kubeConfig = filepath.Join(home, ".kube", "config")
	} else {
		return nil, errors.New("no HOME directory, cannot find kubeconfig")
	}

	config, err := clientcmd.LoadFromFile(kubeConfig)
	if err != nil {
		return nil, err
	}

	return config, nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is creating a client for an extension. It takes in a context as an argument and then uses that context to 
//	get a configuration. It then uses that configuration to create a client for the extension.
//
// </AiDoc: End of OpenAI comments>
func CreateExtensionClient(context string) (clientset.Interface, error) {
	merged, err := GetConfig(context)
	if err != nil {
		return nil, err
	}

	client, err := clientset.NewForConfig(merged)
	if err != nil {
		return nil, err
	}

	return client, err
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is creating a dynamic client for a given context. It first retrieves the configuration for the given 
//	context, then creates a dynamic client using the configuration, and finally returns the dynamic client.
//
// </AiDoc: End of OpenAI comments>
func CreateDynamicClient(context string) (dynamic.Interface, error) {
	merged, err := GetConfig(context)
	if err != nil {
		return nil, err
	}

	client, err := dynamic.NewForConfig(merged)
	if err != nil {
		return nil, err
	}

	return client, err
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function creates a typed client for a given context. It retrieves the configuration for the context and then 
//	creates a new client using the configuration. It then returns the client and the configuration.
//
// </AiDoc: End of OpenAI comments>
func CreateTypedClient(context string) (*k8s.Clientset, *rest.Config, error) {
	merged, err := GetConfig(context)
	if err != nil {
		return nil, nil, err
	}

	client, err := k8s.NewForConfig(merged)
	if err != nil {
		return nil, nil, err
	}

	return client, merged, err
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function creates a runtime client for a given context and scheme. It first attempts to get the configuration for 
//	the given context, and if successful, it will attempt to create a new client with the configuration and scheme. If the 
//	client creation fails, it will retry twice, waiting 15 seconds between each attempt. If the client creation fails after 
//	the third attempt, it will abort and return an error.
//
// </AiDoc: End of OpenAI comments>
func CreateRuntimeClient(context string, scheme *k8s_runtime.Scheme) (client.Client, error) {
	merged, err := GetConfig(context)
	if err != nil {
		return nil, err
	}

	var c client.Client
	for i := 0; i < 2; i++ {
		c, err = client.New(merged, client.Options{Scheme: scheme})
		if err != nil {
			output.LogInfo(fmt.Errorf("failed to get a kubernetes client: %w", err).Error())
			time.Sleep(15 * time.Second)
		}
	}
	if err != nil {
		output.LogInfo("aborting runtime client creation after 3 retries")
		return nil, err
	}

	return c, nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function creates a RESTMapper for a given context. It first retrieves the configuration for the given context, then
//	 creates a DiscoveryClient using the configuration. Finally, it creates a RESTMapper using the DiscoveryClient.
//
// </AiDoc: End of OpenAI comments>
func CreateRESTMapper(context string) (meta.RESTMapper, error) {
	merged, err := GetConfig(context)
	if err != nil {
		return nil, err
	}

	d, err := discovery.NewDiscoveryClientForConfig(merged)
	if err != nil {
		return nil, err
	}

	return restmapper.NewDeferredDiscoveryRESTMapper(memory.NewMemCacheClient(d)), nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is ensuring that a namespace exists in a Kubernetes cluster. It takes in a context, a client interface, 
//	and a namespace as parameters. It then creates the namespace if it does not already exist, using the Apply method to 
//	avoid any errors if the namespace already exists.
//
// </AiDoc: End of OpenAI comments>
func EnsureNamespace(ctx context.Context, client k8s.Interface, namespace string) error {
	namespaceApply := applycorev1.Namespace(namespace)

	// Use Apply instead of Create to avoid failures on a namespace already existing.
	_, err := client.CoreV1().Namespaces().Apply(ctx, namespaceApply, metav1.ApplyOptions{FieldManager: "rad"})
	if err != nil {
		return err
	}
	return nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is getting a configuration from a Kubernetes cluster using a given context. It reads the Kubernetes 
//	configuration, creates a non-interactive client configuration, and then merges it into a single configuration. It then 
//	returns the merged configuration.
//
// </AiDoc: End of OpenAI comments>
func GetConfig(context string) (*rest.Config, error) {
	config, err := ReadKubeConfig()
	if err != nil {
		return nil, err
	}

	clientconfig := clientcmd.NewNonInteractiveClientConfig(*config, context, nil, nil)
	merged, err := clientconfig.ClientConfig()
	if err != nil {
		return nil, err
	}
	return merged, err
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	
 
//	The previous function is checking the environment variables for the user's home directory. If the environment variable 
//	"HOME" is set, it will return that value. Otherwise, it will return the value of the environment variable "USERPROFILE" 
//	which is used in Windows.
//
// </AiDoc: End of OpenAI comments>
func homeDir() string {
	if h := os.Getenv("HOME"); h != "" {
		return h
	}
	return os.Getenv("USERPROFILE") // windows
}

// Creating a Kubernetes client
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is creating Kubernetes clients using a given context name. It reads the Kubernetes configuration, checks 
//	if a context name is provided, and if not, uses the current context. It then creates a typed client and a runtime 
//	client, and returns them along with the context name.
//
// </AiDoc: End of OpenAI comments>
func CreateKubernetesClients(contextName string) (k8s.Interface, runtime_client.Client, string, error) {
	k8sConfig, err := ReadKubeConfig()
	if err != nil {
		return nil, nil, "", err
	}

	if contextName == "" && k8sConfig.CurrentContext == "" {
		return nil, nil, "", errors.New("no kubernetes context is set")
	} else if contextName == "" {
		contextName = k8sConfig.CurrentContext
	}

	context := k8sConfig.Contexts[contextName]
	if context == nil {
		return nil, nil, "", fmt.Errorf("kubernetes context '%s' could not be found", contextName)
	}

	client, _, err := CreateTypedClient(contextName)
	if err != nil {
		return nil, nil, "", err
	}

	runtimeClient, err := CreateRuntimeClient(contextName, Scheme)
	if err != nil {
		return nil, nil, "", err
	}

	return client, runtimeClient, contextName, nil
}

//go:generate mockgen -destination=./mock_kubernetes.go -package=kubernetes -self_package github.com/project-radius/radius/pkg/cli/kubernetes github.com/project-radius/radius/pkg/cli/kubernetes Interface
type Interface interface {
	GetKubeContext() (*api.Config, error)
}

type Impl struct {
}

// Fetches the kubecontext from the system
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is retrieving the configuration information for the Kubernetes cluster. It is reading the configuration 
//	from a file and returning it as an api.Config object.
//
// </AiDoc: End of OpenAI comments>
func (i *Impl) GetKubeContext() (*api.Config, error) {
	return ReadKubeConfig()
}
