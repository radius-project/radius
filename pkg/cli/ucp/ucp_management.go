// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package ucp

import (
	"context"
	"net/http"
	"strings"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"golang.org/x/sync/errgroup"

	"github.com/project-radius/radius/pkg/azure/clientv2"
	aztoken "github.com/project-radius/radius/pkg/azure/tokencredentials"
	"github.com/project-radius/radius/pkg/cli/clients"
	"github.com/project-radius/radius/pkg/cli/clients_new/generated"
	corerpv20220315 "github.com/project-radius/radius/pkg/corerp/api/v20220315privatepreview"
	"github.com/project-radius/radius/pkg/linkrp"
	ucpv20220901 "github.com/project-radius/radius/pkg/ucp/api/v20220901privatepreview"
	"github.com/project-radius/radius/pkg/ucp/resources"
)

type ARMApplicationsManagementClient struct {
	RootScope     string
	ClientOptions *arm.ClientOptions
}

var _ clients.ApplicationsManagementClient = (*ARMApplicationsManagementClient)(nil)

var (
	ResourceTypesList = []string{
		linkrp.MongoDatabasesResourceType,
		linkrp.RabbitMQMessageQueuesResourceType,
		linkrp.RedisCachesResourceType,
		linkrp.SqlDatabasesResourceType,
		linkrp.DaprStateStoresResourceType,
		linkrp.DaprSecretStoresResourceType,
		linkrp.DaprPubSubBrokersResourceType,
		linkrp.DaprInvokeHttpRoutesResourceType,
		linkrp.ExtendersResourceType,
		"Applications.Core/gateways",
		"Applications.Core/httpRoutes",
		"Applications.Core/containers",
	}
)

// ListAllResourcesByType lists the all the resources within a scope
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is creating a list of resources of a given type from the ARM Applications Management Client. It is using
//	the anonymous credential and the client options to create a new generic resources client. It then creates a pager to
//	loop through the list of resources and adds each resource to the results list. Finally, it returns the list of
//	resources.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) ListAllResourcesByType(ctx context.Context, resourceType string) ([]generated.GenericResource, error) {
	results := []generated.GenericResource{}

	client, err := generated.NewGenericResourcesClient(amc.RootScope, resourceType, &aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return results, err
	}

	pager := client.NewListByRootScopePager(&generated.GenericResourcesClientListByRootScopeOptions{})
	for pager.More() {
		nextPage, err := pager.NextPage(ctx)
		if err != nil {
			return results, err
		}
		applicationList := nextPage.GenericResourcesList.Value
		for _, application := range applicationList {
			results = append(results, *application)
		}
	}

	return results, nil
}

// ListAllResourceOfTypeInApplication lists the resources of a particular type in an application
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//

//	The previous function is looping through a list of resources of a given type and checking if each resource is associated
//	 with a given application. If the resource is associated with the application, it is added to a list of results. The
//	function then returns the list of results.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) ListAllResourcesOfTypeInApplication(ctx context.Context, applicationName string, resourceType string) ([]generated.GenericResource, error) {
	results := []generated.GenericResource{}
	resourceList, err := amc.ListAllResourcesByType(ctx, resourceType)
	if err != nil {
		return nil, err
	}
	for _, resource := range resourceList {
		isResourceWithApplication := isResourceInApplication(ctx, resource, applicationName)
		if isResourceWithApplication {
			results = append(results, resource)
		}
	}
	return results, nil
}

// ListAllResourcesByApplication lists the resources of a particular application
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is looping through a list of resource types and retrieving a list of all resources of each type for a
//	given application. It then combines all of the resources into a single list and returns it.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) ListAllResourcesByApplication(ctx context.Context, applicationName string) ([]generated.GenericResource, error) {
	results := []generated.GenericResource{}
	for _, resourceType := range ResourceTypesList {
		resourceList, err := amc.ListAllResourcesOfTypeInApplication(ctx, applicationName, resourceType)
		if err != nil {
			return nil, err
		}
		results = append(results, resourceList...)
	}

	return results, nil
}

// ListAllResourcesByEnvironment lists the all the resources of a particular environment
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is looping through a list of resource types and retrieving a list of all resources of each type in a given
//	 environment. It then combines all of the resources into a single list and returns it.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) ListAllResourcesByEnvironment(ctx context.Context, environmentName string) ([]generated.GenericResource, error) {
	results := []generated.GenericResource{}
	for _, resourceType := range ResourceTypesList {
		resourceList, err := amc.ListAllResourcesOfTypeInEnvironment(ctx, environmentName, resourceType)
		if err != nil {
			return nil, err
		}
		results = append(results, resourceList...)
	}

	return results, nil
}

// ListAllResourcesByTypeInEnvironment lists the all the resources of a particular type in an environment
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is retrieving all resources of a given type from a specific environment. It first retrieves a list of all
//	resources of the given type, then checks if each resource is in the specified environment. If it is, it adds it to the
//	results list which is then returned.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) ListAllResourcesOfTypeInEnvironment(ctx context.Context, environmentName string, resourceType string) ([]generated.GenericResource, error) {
	results := []generated.GenericResource{}
	resourceList, err := amc.ListAllResourcesByType(ctx, resourceType)
	if err != nil {
		return nil, err
	}
	for _, resource := range resourceList {
		isResourceWithApplication := isResourceInEnvironment(ctx, resource, environmentName)
		if isResourceWithApplication {
			results = append(results, resource)
		}
	}
	return results, nil
}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is creating a new client for a given resource type, and then using that client to retrieve a resource with
//	 the given name. It then returns the retrieved resource.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) ShowResource(ctx context.Context, resourceType string, resourceName string) (generated.GenericResource, error) {
	client, err := generated.NewGenericResourcesClient(amc.RootScope, resourceType, &aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return generated.GenericResource{}, err
	}

	getResponse, err := client.Get(ctx, resourceName, &generated.GenericResourcesClientGetOptions{})
	if err != nil {
		return generated.GenericResource{}, err
	}

	return getResponse.GenericResource, nil
}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is used to delete a resource of a given type with a given name. It creates a new client for the given
//	resource type, then begins the delete process for the given resource name. It polls until the delete process is
//	complete, and then returns a boolean value indicating whether the delete was successful or not.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) DeleteResource(ctx context.Context, resourceType string, resourceName string) (bool, error) {
	client, err := generated.NewGenericResourcesClient(amc.RootScope, resourceType, &aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return false, err
	}

	var respFromCtx *http.Response
	ctxWithResp := runtime.WithCaptureResponse(ctx, &respFromCtx)

	poller, err := client.BeginDelete(ctxWithResp, resourceName, nil)
	if err != nil {
		return false, err
	}

	_, err = poller.PollUntilDone(ctx, nil)
	if err != nil {
		return false, err
	}

	return respFromCtx.StatusCode != 204, nil
}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is creating a list of ApplicationResource objects from the ARM Applications Management Client. It is using
//	 the NewApplicationsClient to create a client, and then using the NewListByScopePager to create a pager. It then
//	iterates through the pages of the pager, and adds each ApplicationResource to the list of results. Finally, it returns
//	the list of results.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) ListApplications(ctx context.Context) ([]corerpv20220315.ApplicationResource, error) {
	results := []corerpv20220315.ApplicationResource{}

	client, err := corerpv20220315.NewApplicationsClient(amc.RootScope, &aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return results, err
	}

	pager := client.NewListByScopePager(&corerpv20220315.ApplicationsClientListByScopeOptions{})
	for pager.More() {
		nextPage, err := pager.NextPage(ctx)
		if err != nil {
			return results, err
		}
		applicationList := nextPage.ApplicationResourceList.Value
		for _, application := range applicationList {
			results = append(results, *application)
		}
	}

	return results, nil
}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function takes a context and an environment name as parameters and returns a list of application resources
//	associated with the given environment name. It first retrieves a list of all applications and then filters out the
//	applications that are associated with the given environment name.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) ListApplicationsByEnv(ctx context.Context, envName string) ([]corerpv20220315.ApplicationResource, error) {
	results := []corerpv20220315.ApplicationResource{}
	applicationsList, err := amc.ListApplications(ctx)
	if err != nil {
		return nil, err
	}
	envID := "/" + amc.RootScope + "/providers/applications.core/environments/" + envName
	for _, application := range applicationsList {
		if strings.EqualFold(envID, *application.Properties.Environment) {
			results = append(results, application)
		}
	}
	return results, nil
}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is creating a new client for the ARM Applications Management service and then using that client to
//	retrieve an application resource with the given name. It then returns the application resource.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) ShowApplication(ctx context.Context, applicationName string) (corerpv20220315.ApplicationResource, error) {
	client, err := corerpv20220315.NewApplicationsClient(amc.RootScope, &aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return corerpv20220315.ApplicationResource{}, err
	}

	getResponse, err := client.Get(ctx, applicationName, &corerpv20220315.ApplicationsClientGetOptions{})
	var result corerpv20220315.ApplicationResource
	if err != nil {
		return result, err
	}
	result = getResponse.ApplicationResource
	return result, nil
}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is deleting an application with the given name. It first lists all the resources associated with the
//	application, then deletes each of them. Finally, it deletes the application itself.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) DeleteApplication(ctx context.Context, applicationName string) (bool, error) {
	// This handles the case where the application doesn't exist.
	resourcesWithApplication, err := amc.ListAllResourcesByApplication(ctx, applicationName)
	if err != nil && !clientv2.Is404Error(err) {
		return false, err
	}

	g, groupCtx := errgroup.WithContext(ctx)
	for _, resource := range resourcesWithApplication {
		resource := resource
		g.Go(func() error {
			_, err := amc.DeleteResource(groupCtx, *resource.Type, *resource.Name)
			if err != nil {
				return err
			}
			return nil
		})
	}

	err = g.Wait()
	if err != nil {
		return false, err
	}

	client, err := corerpv20220315.NewApplicationsClient(amc.RootScope, &aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return false, err
	}

	var respFromCtx *http.Response
	ctxWithResp := runtime.WithCaptureResponse(ctx, &respFromCtx)

	_, err = client.Delete(ctxWithResp, applicationName, nil)
	if err != nil {
		return false, err
	}

	return respFromCtx.StatusCode != 204, nil
}

// CreateOrUpdateApplication creates or updates an application.
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function creates or updates an application with the given name and resource. It creates a new ApplicationsClient
//	and then calls the CreateOrUpdate method with the given parameters. If successful, it returns nil.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) CreateOrUpdateApplication(ctx context.Context, applicationName string, resource corerpv20220315.ApplicationResource) error {
	client, err := corerpv20220315.NewApplicationsClient(amc.RootScope, &aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return err
	}

	_, err = client.CreateOrUpdate(ctx, applicationName, resource, nil)
	if err != nil {
		return err
	}

	return nil
}

// CreateApplicationIfNotFound creates an application if it does not exist.
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function checks if an application with the given name already exists. If it does not exist, it creates the
//	application with the given resource.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) CreateApplicationIfNotFound(ctx context.Context, applicationName string, resource corerpv20220315.ApplicationResource) error {
	client, err := corerpv20220315.NewApplicationsClient(amc.RootScope, &aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return err
	}

	_, err = client.Get(ctx, applicationName, nil)
	if clients.Is404Error(err) {
		// continue
	} else if err != nil {
		return err
	} else {
		// Application already exists, nothing to do.
		return nil
	}

	_, err = client.CreateOrUpdate(ctx, applicationName, resource, nil)
	if err != nil {
		return err
	}

	return nil
}

// Creates a radius environment resource
func (amc *ARMApplicationsManagementClient) CreateEnvironment(ctx context.Context, envName string, location string, envProperties *corerpv20220315.EnvironmentProperties) (bool, error) {
	client, err := corerpv20220315.NewEnvironmentsClient(amc.RootScope, &aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return false, err
	}

	_, err = client.CreateOrUpdate(ctx, envName, corerpv20220315.EnvironmentResource{Location: &location, Properties: envProperties}, &corerpv20220315.EnvironmentsClientCreateOrUpdateOptions{})
	if err != nil {
		return false, err
	}

	return true, nil

}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	The function is checking if a given resource is associated with a given application. It does this by checking the
//	resource's properties for an "application" property, and then checking if the value of that property matches the given
//	application name. If the property is not found or the value does not match, the function returns false.
//
// </AiDoc: End of OpenAI comments>
func isResourceInApplication(ctx context.Context, resource generated.GenericResource, applicationName string) bool {
	obj, found := resource.Properties["application"]
	// A resource may not have an application associated with it.
	if !found {
		return false
	}

	associatedAppId, ok := obj.(string)
	if !ok || associatedAppId == "" {
		return false
	}

	idParsed, err := resources.ParseResource(associatedAppId)
	if err != nil {
		return false
	}

	if strings.EqualFold(idParsed.Name(), applicationName) {
		return true
	}

	return false
}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	The function is checking if a given resource is associated with a given environment. It does this by checking the
//	resource's properties for an "environment" property, and then checking if the value of that property matches the given
//	environment name. If the resource does not have an environment property, or the value of the property does not match the
//	 given environment name, the function returns false.
//
// </AiDoc: End of OpenAI comments>
func isResourceInEnvironment(ctx context.Context, resource generated.GenericResource, environmentName string) bool {
	obj, found := resource.Properties["environment"]
	// A resource may not have an environment associated with it.
	if !found {
		return false
	}

	associatedEnvId, ok := obj.(string)
	if !ok || associatedEnvId == "" {
		return false
	}

	idParsed, err := resources.ParseResource(associatedEnvId)
	if err != nil {
		return false
	}

	if strings.EqualFold(idParsed.Name(), environmentName) {
		return true
	}

	return false
}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is creating a list of environment resources from a resource group. It is using the ARM Applications
//	Management Client to create an environment client, and then using a pager to loop through the list of environment
//	resources and add them to the list. Finally, it returns the list of environment resources.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) ListEnvironmentsInResourceGroup(ctx context.Context) ([]corerpv20220315.EnvironmentResource, error) {
	envResourceList := []corerpv20220315.EnvironmentResource{}

	envClient, err := corerpv20220315.NewEnvironmentsClient(amc.RootScope, &aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return envResourceList, err
	}

	pager := envClient.NewListByScopePager(&corerpv20220315.EnvironmentsClientListByScopeOptions{})
	for pager.More() {
		nextPage, err := pager.NextPage(ctx)
		if err != nil {
			return envResourceList, err
		}
		applicationList := nextPage.EnvironmentResourceList.Value
		for _, application := range applicationList {
			envResourceList = append(envResourceList, *application)
		}
	}

	return envResourceList, nil
}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is retrieving a list of all the environment resources in a given root scope. It does this by first
//	retrieving a list of all the resource groups in the root scope, then for each resource group it retrieves a list of all
//	the environment resources in that group. All of the environment resources are then added to a list which is returned.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) ListEnvironmentsAll(ctx context.Context) ([]corerpv20220315.EnvironmentResource, error) {
	// This is inefficient, but we haven't yet implemented plane-scoped list APIs for our resources yet.

	groupClient, err := ucpv20220901.NewResourceGroupsClient(&aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return []corerpv20220315.EnvironmentResource{}, err
	}

	scope, err := resources.ParseScope("/" + amc.RootScope)
	if err != nil {
		return []corerpv20220315.EnvironmentResource{}, err
	}

	response, err := groupClient.List(ctx, "radius", scope.FindScope("radius"), nil)
	if err != nil {
		return []corerpv20220315.EnvironmentResource{}, err
	}

	envResourceList := []corerpv20220315.EnvironmentResource{}
	for _, group := range response.Value {
		// Now query environments inside each group.
		envClient, err := corerpv20220315.NewEnvironmentsClient(*group.ID, &aztoken.AnonymousCredential{}, amc.ClientOptions)
		if err != nil {
			return []corerpv20220315.EnvironmentResource{}, err
		}

		pager := envClient.NewListByScopePager(&corerpv20220315.EnvironmentsClientListByScopeOptions{})
		for pager.More() {
			nextPage, err := pager.NextPage(ctx)
			if err != nil {
				return []corerpv20220315.EnvironmentResource{}, err
			}

			applicationList := nextPage.EnvironmentResourceList.Value
			for _, application := range applicationList {
				envResourceList = append(envResourceList, *application)
			}
		}
	}

	return envResourceList, nil
}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is used to get the details of an environment with a given name. It creates an environment client and then
//	uses it to get the environment resource associated with the given name. If successful, it returns the environment
//	resource, otherwise it returns an error.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) GetEnvDetails(ctx context.Context, envName string) (corerpv20220315.EnvironmentResource, error) {
	envClient, err := corerpv20220315.NewEnvironmentsClient(amc.RootScope, &aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return corerpv20220315.EnvironmentResource{}, err
	}

	envGetResp, err := envClient.Get(ctx, envName, &corerpv20220315.EnvironmentsClientGetOptions{})
	if err == nil {
		return envGetResp.EnvironmentResource, nil
	}

	return corerpv20220315.EnvironmentResource{}, err

}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function deletes an environment with the given name. It first lists all applications associated with the
//	environment, then deletes each application one by one. Finally, it deletes the environment itself.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) DeleteEnv(ctx context.Context, envName string) (bool, error) {
	applicationsWithEnv, err := amc.ListApplicationsByEnv(ctx, envName)
	if err != nil {
		return false, err
	}

	for _, application := range applicationsWithEnv {
		_, err := amc.DeleteApplication(ctx, *application.Name)
		if err != nil {
			return false, err
		}
	}

	envClient, err := corerpv20220315.NewEnvironmentsClient(amc.RootScope, &aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return false, err
	}

	var respFromCtx *http.Response
	ctxWithResp := runtime.WithCaptureResponse(ctx, &respFromCtx)

	_, err = envClient.Delete(ctxWithResp, envName, nil)
	if err != nil {
		return false, err
	}

	return respFromCtx.StatusCode != 204, nil
}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function creates a new resource group in the specified plane type and plane name. It takes in the resource group
//	name and the resource group object as parameters. It then creates a new resource group client and uses it to create or
//	update the resource group. Finally, it returns a boolean value indicating whether the operation was successful or not.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) CreateUCPGroup(ctx context.Context, planeType string, planeName string, resourceGroupName string, resourceGroup ucpv20220901.ResourceGroupResource) (bool, error) {
	var resourceGroupOptions *ucpv20220901.ResourceGroupsClientCreateOrUpdateOptions
	resourcegroupClient, err := ucpv20220901.NewResourceGroupsClient(&aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return false, err
	}

	_, err = resourcegroupClient.CreateOrUpdate(ctx, planeType, planeName, resourceGroupName, resourceGroup, resourceGroupOptions)
	if err != nil {
		return false, err
	}

	return true, nil
}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is used to delete a UCP group from a given resource group. It takes in the plane type, plane name, and
//	resource group name as parameters and returns a boolean value and an error. It first creates a new resource group client
//	 and then attempts to delete the UCP group using the given parameters. If the delete is successful, it returns a boolean
//	 value of true, otherwise it returns false.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) DeleteUCPGroup(ctx context.Context, planeType string, planeName string, resourceGroupName string) (bool, error) {
	var resourceGroupOptions *ucpv20220901.ResourceGroupsClientDeleteOptions
	resourcegroupClient, err := ucpv20220901.NewResourceGroupsClient(&aztoken.AnonymousCredential{}, amc.ClientOptions)

	var respFromCtx *http.Response
	ctxWithResp := runtime.WithCaptureResponse(ctx, &respFromCtx)
	if err != nil {
		return false, err
	}

	_, err = resourcegroupClient.Delete(ctxWithResp, planeType, planeName, resourceGroupName, resourceGroupOptions)
	if err != nil {
		return false, err
	}

	return respFromCtx.StatusCode == 204, nil

}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is retrieving a resource group from the Azure Resource Manager using the given plane type, plane name, and
//	 resource group name. It then returns the resource group resource.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) ShowUCPGroup(ctx context.Context, planeType string, planeName string, resourceGroupName string) (ucpv20220901.ResourceGroupResource, error) {
	var resourceGroupOptions *ucpv20220901.ResourceGroupsClientGetOptions
	resourcegroupClient, err := ucpv20220901.NewResourceGroupsClient(&aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return ucpv20220901.ResourceGroupResource{}, err
	}

	resp, err := resourcegroupClient.Get(ctx, planeType, planeName, resourceGroupName, resourceGroupOptions)
	if err != nil {
		return ucpv20220901.ResourceGroupResource{}, err
	}

	return resp.ResourceGroupResource, nil
}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is used to list the resource groups in a given plane type and plane name. It creates a new resource group
//	client and then uses the list function to get a list of resource groups. The list of resource groups is then appended to
//	 a resource group resource list and returned.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) ListUCPGroup(ctx context.Context, planeType string, planeName string) ([]ucpv20220901.ResourceGroupResource, error) {
	var resourceGroupOptions *ucpv20220901.ResourceGroupsClientListOptions
	resourceGroupResources := []ucpv20220901.ResourceGroupResource{}
	resourcegroupClient, err := ucpv20220901.NewResourceGroupsClient(&aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return resourceGroupResources, err
	}

	resp, err := resourcegroupClient.List(ctx, planeType, planeName, resourceGroupOptions)
	if err != nil {
		return resourceGroupResources, err
	}

	resourceGroupList := resp.ResourceGroupResourceList.Value
	for _, resourceGroup := range resourceGroupList {
		resourceGroupResources = append(resourceGroupResources, *resourceGroup)

	}

	return resourceGroupResources, nil
}

// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//
//	This function is retrieving the metadata of a recipe from an environment. It takes in the context, environment name, and
//	 recipe name as parameters and returns the recipe properties and an error.
//
// </AiDoc: End of OpenAI comments>
func (amc *ARMApplicationsManagementClient) ShowRecipe(ctx context.Context, environmentName string, recipeName string) (corerpv20220315.EnvironmentRecipeProperties, error) {
	client, err := corerpv20220315.NewEnvironmentsClient(amc.RootScope, &aztoken.AnonymousCredential{}, amc.ClientOptions)
	if err != nil {
		return corerpv20220315.EnvironmentRecipeProperties{}, err
	}

	resp, err := client.GetRecipeMetadata(ctx, environmentName, recipeName, &corerpv20220315.EnvironmentsClientGetRecipeMetadataOptions{})
	if err != nil {
		return corerpv20220315.EnvironmentRecipeProperties{}, err
	}

	return corerpv20220315.EnvironmentRecipeProperties(resp.RecipeMetadata), nil
}
