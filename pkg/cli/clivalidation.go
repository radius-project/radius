// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package cli

import (
	"errors"
	"fmt"
	"path"
	"strings"

	"github.com/project-radius/radius/pkg/cli/config"
	"github.com/project-radius/radius/pkg/cli/ucp"
	"github.com/project-radius/radius/pkg/cli/workspaces"
	"github.com/project-radius/radius/pkg/ucp/resources"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

type AzureResource struct {
	Name           string
	ResourceType   string
	ResourceGroup  string
	SubscriptionID string
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function checks if an environment name has been provided as an argument, and if not, checks if a default 
//	environment has been set. If neither of these are true, it returns an error.
//
// </AiDoc: End of OpenAI comments>
func RequireEnvironmentNameArgs(cmd *cobra.Command, args []string, workspace workspaces.Workspace) (string, error) {
	environmentName, err := ReadEnvironmentNameArgs(cmd, args)
	if err != nil {
		return "", err
	}

	// We store the environment id in config, but most commands work with the environment name.
	if environmentName == "" && workspace.Environment != "" {
		id, err := resources.ParseResource(workspace.Environment)
		if err != nil {
			return "", err
		}

		environmentName = id.Name()
	}

	if environmentName == "" {
		return "", fmt.Errorf("no environment name provided and no default environment set, " +
			"either pass in an environment name or set a default environment by using `rad env switch`")
	}

	return environmentName, err
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is checking if an environment name has been provided, and if not, it checks if a default environment has 
//	been set. If neither of these are true, it will return an error.
//
// </AiDoc: End of OpenAI comments>
func RequireEnvironmentName(cmd *cobra.Command, args []string, workspace workspaces.Workspace) (string, error) {
	environmentName, err := cmd.Flags().GetString("environment")
	if err != nil {
		return "", err
	}

	// We store the environment id in config, but most commands work with the environment name.
	if environmentName == "" && workspace.Environment != "" {
		id, err := resources.ParseResource(workspace.Environment)
		if err != nil {
			return "", err
		}

		environmentName = id.Name()
	}

	if environmentName == "" && workspace.IsEditableWorkspace() {
		// Setting a default environment only applies to editable workspaces
		return "", fmt.Errorf("no environment name provided and no default environment set, " +
			"either pass in an environment name or set a default environment by using `rad env switch`")
	} else if environmentName == "" {
		return "", fmt.Errorf("no environment name provided, pass in an environment name")
	}

	return environmentName, err
}

// RequireKubeContext is used by commands that need a kubernetes context name to be specified using -c flag or has a default kubecontext
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is used to get the kubecontext from a command line flag. If the flag is not set, it will use the current 
//	context from the kubeconfig. If neither of these are set, it will return an error.
//
// </AiDoc: End of OpenAI comments>
func RequireKubeContext(cmd *cobra.Command, currentContext string) (string, error) {
	kubecontext, err := cmd.Flags().GetString("context")
	if err != nil {
		return "", err
	}

	if kubecontext == "" && currentContext == "" {
		return "", errors.New("the kubeconfig has no current context")
	} else if kubecontext == "" {
		kubecontext = currentContext
	}

	return kubecontext, nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is reading the environment name from either the command line arguments or the flag. If both are specified,
//	 it will return an error.
//
// </AiDoc: End of OpenAI comments>
func ReadEnvironmentNameArgs(cmd *cobra.Command, args []string) (string, error) {
	name, err := cmd.Flags().GetString("environment")
	if err != nil {
		return "", err
	}

	if len(args) > 0 {
		if name != "" {
			return "", fmt.Errorf("cannot specify environment name via both arguments and `-e`")
		}
		name = args[0]
	}

	return name, err
}

// RequireApplicationArgs reads the application name from the following sources in priority order and returns
// an error if no application name is set.
//
// - '--application' flag
// - first positional arg
// - workspace default application
// - directory config application
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is checking if an application name has been provided as an argument, and if not, it checks if a default 
//	application has been set. If neither of these are true, it returns an error.
//
// </AiDoc: End of OpenAI comments>
func RequireApplicationArgs(cmd *cobra.Command, args []string, workspace workspaces.Workspace) (string, error) {
	applicationName, err := ReadApplicationNameArgs(cmd, args)
	if err != nil {
		return "", err
	}

	if applicationName == "" {
		applicationName = workspace.DefaultApplication
	}

	if applicationName == "" {
		applicationName = workspace.DirectoryConfig.Workspace.Application
	}

	if applicationName == "" {
		return "", fmt.Errorf("no application name provided and no default application set, " +
			"either pass in an application name or set a default application by using `rad application switch`")
	}

	return applicationName, nil
}

// ReadApplicationName reads the application name from the following sources in priority order and returns
// the empty string if no application is set.
//
// - '--application' flag
// - workspace default application
// - directory config application
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is reading the application name from a command line flag, or from the workspace's default application name
//	 or directory configuration. If none of these are present, it will return an empty string.
//
// </AiDoc: End of OpenAI comments>
func ReadApplicationName(cmd *cobra.Command, workspace workspaces.Workspace) (string, error) {
	applicationName, err := cmd.Flags().GetString("application")
	if err != nil {
		return "", err
	}

	if applicationName == "" {
		applicationName = workspace.DefaultApplication
	}

	if applicationName == "" {
		applicationName = workspace.DirectoryConfig.Workspace.Application
	}

	return applicationName, nil
}

// ReadApplicationName reads the application name from the following sources in priority order and returns
// the empty string if no application is set.
//
// - '--application' flag
// - first positional arg
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is reading an application name from either a command line flag or an argument. If both are specified, it 
//	will return an error.
//
// </AiDoc: End of OpenAI comments>
func ReadApplicationNameArgs(cmd *cobra.Command, args []string) (string, error) {
	name, err := cmd.Flags().GetString("application")
	if err != nil {
		return "", err
	}

	if len(args) > 0 {
		if name != "" {
			return "", fmt.Errorf("cannot specify application name via both arguments and `-a`")
		}
		name = args[0]
	}

	return name, err
}

// RequireApplicationArgs reads the application name from the following sources in priority order and returns
// an error if no application name is set.
//
// - '--application' flag
// - workspace default application
// - directory config application
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is used to require an application from a given workspace. It takes in a command and a workspace as 
//	parameters and returns a string and an error.
//
// </AiDoc: End of OpenAI comments>
func RequireApplication(cmd *cobra.Command, workspace workspaces.Workspace) (string, error) {
	return RequireApplicationArgs(cmd, []string{}, workspace)
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	
 
//	This function takes in a command and an array of strings as arguments and returns a resource type, resource name, and an
//	 error. It checks if the command and array of strings have the required parameters and returns the resource type and 
//	resource name if they are present. If the required parameters are not present, it returns an error.
//
// </AiDoc: End of OpenAI comments>
func RequireResource(cmd *cobra.Command, args []string) (resourceType string, resourceName string, err error) {
	results, err := requiredMultiple(cmd, args, "type", "resource")
	if err != nil {
		return "", "", err
	}
	return results[0], results[1], nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is checking if two arguments have been provided, and if so, it is returning the first argument as the 
//	resource type and the second argument as the resource name. If two arguments are not provided, it returns an error.
//
// </AiDoc: End of OpenAI comments>
func RequireResourceTypeAndName(args []string) (string, string, error) {
	if len(args) < 2 {
		return "", "", errors.New("No resource type or name provided")
	}
	resourceType, err := RequireResourceType(args)
	if err != nil {
		return "", "", err
	}
	resourceName := args[1]
	return resourceType, resourceName, nil
}

// example of resource Type: Applications.Core/httpRoutes, Applications.Link/redisCaches
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function checks if the first argument provided is a valid resource type. If it is, it returns the resource type, 
//	otherwise it returns an error. It checks the resource type against a list of supported types and if it is not found, it 
//	returns an error with a list of the supported types.
//
// </AiDoc: End of OpenAI comments>
func RequireResourceType(args []string) (string, error) {
	if len(args) < 1 {
		return "", errors.New("no resource type provided")
	}
	resourceTypeName := args[0]
	supportedTypes := []string{}
	for _, resourceType := range ucp.ResourceTypesList {
		supportedType := strings.Split(resourceType, "/")[1]
		supportedTypes = append(supportedTypes, supportedType)
		if strings.EqualFold(supportedType, resourceTypeName) {
			return resourceType, nil
		}
	}
	return "", fmt.Errorf("'%s' is not a valid resource type. Available Types are: \n\n%s\n",
		resourceTypeName, strings.Join(supportedTypes, "\n"))
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function takes in a command and a list of arguments and returns an AzureResource object and an error. It uses the 
//	requiredMultiple function to get the values for the type, resource, resource-group, and resource-subscription-id. It 
//	then creates an AzureResource object with these values and returns it.
//
// </AiDoc: End of OpenAI comments>
func RequireAzureResource(cmd *cobra.Command, args []string) (azureResource AzureResource, err error) {
	results, err := requiredMultiple(cmd, args, "type", "resource", "resource-group", "resource-subscription-id")
	if err != nil {
		return AzureResource{}, err
	}
	return AzureResource{
		ResourceType:   results[0],
		Name:           results[1],
		ResourceGroup:  results[2],
		SubscriptionID: results[3],
	}, nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is retrieving the value of the "output" flag from the given command.
//
// </AiDoc: End of OpenAI comments>
func RequireOutput(cmd *cobra.Command) (string, error) {
	return cmd.Flags().GetString("output")
}

// RequireWorkspace is used by commands that require an existing workspace either set as the default,
// or specified using the 'workspace' flag.
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is used to require a workspace. It takes in a command, config, and directory config as parameters. It then
//	 gets the workspace name from the command flags, reads the workspace section from the config, and gets the workspace 
//	from the section. If the workspace is nil, it creates a fallback workspace. Finally, it sets the directory config if it 
//	is not nil.
//
// </AiDoc: End of OpenAI comments>
func RequireWorkspace(cmd *cobra.Command, config *viper.Viper, dc *config.DirectoryConfig) (*workspaces.Workspace, error) {
	name, err := cmd.Flags().GetString("workspace")
	if err != nil {
		return nil, err
	}

	section, err := ReadWorkspaceSection(config)
	if err != nil {
		return nil, err
	}

	ws, err := section.GetWorkspace(name)
	if err != nil {
		return nil, err
	}

	// If we get here and ws is nil then this means there's no default set (or no config).
	// Lets use the fallback configuration.
	if ws == nil {
		ws = workspaces.MakeFallbackWorkspace()
	}

	if dc != nil {
		ws.DirectoryConfig = *dc
	}

	return ws, nil
}

// RequireUCPResourceGroup is used by commands that require specifying a UCP resouce group name using flag or positional args
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	
 
//	This function is used to read the resource group name from the command line arguments and check if it is provided and 
//	not empty. If the resource group name is not provided or is empty, an error is returned.
//
// </AiDoc: End of OpenAI comments>
func RequireUCPResourceGroup(cmd *cobra.Command, args []string) (string, error) {
	group, err := ReadResourceGroupNameArgs(cmd, args)
	if err != nil {
		return "", err
	}
	if group == "" {
		return "", fmt.Errorf("resource group name is not provided or is empty ")
	}

	return group, nil
}

// ReadResourceGroupNameArgs is used to get the resource group name that is supplied as either the first argument for group commands or using a -g flag
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is reading the resource group name from either the command line arguments or the -g flag. If both are 
//	specified, it will return an error.
//
// </AiDoc: End of OpenAI comments>
func ReadResourceGroupNameArgs(cmd *cobra.Command, args []string) (string, error) {
	name, err := cmd.Flags().GetString("group")
	if err != nil {
		return "", err
	}

	if len(args) > 0 {
		if name != "" {
			return "", fmt.Errorf("cannot specify resource group name via both arguments and `-g`")
		}
		name = args[0]
	}

	return name, err
}

// RequireWorkspaceArgs is used by commands that require an existing workspace either set as the default,
// or specified as a positional arg, or specified using the 'workspace' flag.
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function reads the workspace name and section from the command line arguments and configuration file. It then 
//	retrieves the workspace from the section and if it is not found, it creates a fallback workspace.
//
// </AiDoc: End of OpenAI comments>
func RequireWorkspaceArgs(cmd *cobra.Command, config *viper.Viper, args []string) (*workspaces.Workspace, error) {
	name, err := ReadWorkspaceNameArgs(cmd, args)
	if err != nil {
		return nil, err
	}

	section, err := ReadWorkspaceSection(config)
	if err != nil {
		return nil, err
	}

	ws, err := section.GetWorkspace(name)
	if err != nil {
		return nil, err
	}

	// If we get here and ws is nil then this means there's no default set (or no config).
	// Lets use the fallback configuration.
	if ws == nil {
		ws = workspaces.MakeFallbackWorkspace()
	}

	return ws, nil
}

// ReadWorkspaceNameArgs is used to get the workspace name that is supplied as either the first argument or using a -w flag
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is reading the workspace name from either the command line arguments or the flag. If both are specified, 
//	it will return an error.
//
// </AiDoc: End of OpenAI comments>
func ReadWorkspaceNameArgs(cmd *cobra.Command, args []string) (string, error) {
	name, err := cmd.Flags().GetString("workspace")
	if err != nil {
		return "", err
	}

	if len(args) > 0 {
		if name != "" {
			return "", fmt.Errorf("cannot specify workspace name via both arguments and `-w`")
		}
		name = args[0]
	}

	return name, err
}

// ReadWorkspaceName is used to get the workspace name that is supplied using a -w flag or as second arg.
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is reading the workspace name from the second argument of a command, and checking if it has been specified
//	 via the "-w" flag. If both have been specified, it will return an error.
//
// </AiDoc: End of OpenAI comments>
func ReadWorkspaceNameSecondArg(cmd *cobra.Command, args []string) (string, error) {
	name, err := cmd.Flags().GetString("workspace")
	if err != nil {
		return "", err
	}

	if len(args) > 1 {
		if name != "" {
			return "", fmt.Errorf("cannot specify workspace name via both arguments and `-w`")
		}
		name = args[1]
	}

	return name, err
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is checking if a flag called "radfile" has been passed in to the command. If it has, it will return the 
//	value of the flag. If it hasn't, it will return the path to a file called "rad.yaml" in the current directory.
//
// </AiDoc: End of OpenAI comments>
func RequireRadYAML(cmd *cobra.Command) (string, error) {
	radFile, err := cmd.Flags().GetString("radfile")
	if err != nil {
		return "", err
	}

	if radFile == "" {
		return path.Join(".", "rad.yaml"), nil
	}

	return radFile, nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is used to check if the required arguments have been provided. It takes in a command, an array of strings,
//	 and a list of names as parameters. It then creates an array of strings to store the results. It then iterates through 
//	the list of names and checks if the value of the name is present. If it is, it stores it in the results array. If the 
//	value is not present, it checks if there are any arguments left in the array of strings. If there are, it stores the 
//	first argument in the results array and removes it from the array of strings. If there are no arguments left, it returns
//	 an error saying that no name was provided.
//
// </AiDoc: End of OpenAI comments>
func requiredMultiple(cmd *cobra.Command, args []string, names ...string) ([]string, error) {
	results := make([]string, len(names))
	for i, name := range names {
		value, err := cmd.Flags().GetString(name)
		if err == nil {
			results[i] = value
		}
		if results[i] != "" {
			if len(args) > len(names)-i-1 {
				return nil, fmt.Errorf("cannot specify %v name via both arguments and switch", name)
			}
			continue
		}
		if len(args) == 0 {
			return nil, fmt.Errorf("no %v name provided", name)
		}
		results[i] = args[0]
		args = args[1:]
	}
	return results, nil
}

// RequireScope returns the scope the command should use to execute or an error if unset.
//
// This function considers the following sources:
//
// - --group flag
// - workspace scope
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is checking if a resource group has been passed in as a flag, and if not, it is checking if a workspace 
//	scope has been set. If neither of these are set, it will return an error.
//
// </AiDoc: End of OpenAI comments>
func RequireScope(cmd *cobra.Command, workspace workspaces.Workspace) (string, error) {
	resourceGroup, err := cmd.Flags().GetString("group")
	if err != nil {
		return "", err
	}

	if resourceGroup != "" {
		return fmt.Sprintf("/planes/radius/local/resourceGroups/%s", resourceGroup), nil
	} else if workspace.Scope != "" {
		return workspace.Scope, nil
	} else {
		return "", &FriendlyError{Message: "no resource group set, use `--group` to pass in a resource group name"}
	}
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is retrieving the value of the "name" flag from a given cobra command and returning it as a string. If 
//	there is an error retrieving the flag, it will return an error.
//
// </AiDoc: End of OpenAI comments>
func RequireRecipeName(cmd *cobra.Command) (string, error) {
	recipeName, err := cmd.Flags().GetString("name")
	if err != nil {
		return "", err
	}

	return recipeName, nil
}
