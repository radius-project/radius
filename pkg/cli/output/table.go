// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package output

import (
	"bytes"
	"errors"
	"io"
	"strings"
	"text/tabwriter"

	"k8s.io/client-go/util/jsonpath"
)

// Based on https://golang.org/pkg/text/tabwriter/
const (
	TableColumnMinWidth = 10
	TableTabSize        = 4
	TablePadSize        = 2
	TablePadCharacter   = ' '
	TableFlags          = 0
)

type TableFormatter struct {
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function takes an object, a writer, and a set of formatter options as input. It then checks if any columns were 
//	defined in the formatter options, and if not, returns an error. It then converts the object to a slice and creates a 
//	list of headings, parsers, and transformers based on the columns defined in the formatter options. It then creates a 
//	tabwriter and writes the headings to it. It then iterates through each row in the slice, evaluates the path for each 
//	column, and writes the result to the tabwriter, using the transformer if one is defined. Finally, it flushes the 
//	tabwriter and returns.
//
// </AiDoc: End of OpenAI comments>
func (f *TableFormatter) Format(obj any, writer io.Writer, options FormatterOptions) error {
	if len(options.Columns) == 0 {
		return errors.New("no columns were defined, table format is not supported for this command")
	}

	rows, err := convertToSlice(obj)
	if err != nil {
		return err
	}

	headings := []string{}
	parsers := []*jsonpath.JSONPath{}
	transformers := []func(string) string{}
	for _, c := range options.Columns {
		headings = append(headings, c.Heading)

		p := jsonpath.New(c.Heading).AllowMissingKeys(true)
		err := p.Parse(c.JSONPath)
		if err != nil {
			return err
		}

		parsers = append(parsers, p)
		transformers = append(transformers, c.Transformer)
	}

	tabs := tabwriter.NewWriter(writer, TableColumnMinWidth, TableTabSize, TablePadSize, TablePadCharacter, TableFlags)
	_, err = tabs.Write([]byte(strings.Join(headings, "\t") + "\n"))
	if err != nil {
		return err
	}

	for _, row := range rows {

		// For each row evaluate the path and write to output using tab as separator
		for i, p := range parsers {
			transformer := transformers[i]
			if transformer != nil {
				buf := bytes.Buffer{}
				err := p.Execute(&buf, row)
				if err != nil {
					return err
				}
				_, err = tabs.Write([]byte(transformer(buf.String())))
				if err != nil {
					return err
				}
			} else {
				err := p.Execute(tabs, row)
				if err != nil {
					return err
				}
			}
			if i < len(parsers)-1 {
				_, err = tabs.Write([]byte("\t"))
				if err != nil {
					return err
				}
			}
		}

		_, err := tabs.Write([]byte("\n"))
		if err != nil {
			return err
		}
	}

	err = tabs.Flush()
	if err != nil {
		return err
	}

	return nil
}

var _ Formatter = (*TableFormatter)(nil)
