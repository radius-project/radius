// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package output

import (
	"fmt"
	"io"
	"reflect"
	"strings"
)

type FormatterOptions struct {
	// Columns used for table formatting
	Columns []Column
}

type Column struct {
	Heading     string
	JSONPath    string
	Transformer func(string) string
}

type Formatter interface {
	Format(obj any, writer io.Writer, options FormatterOptions) error
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	
 
//	The function is creating a new formatter based on a given format string. It checks the format string and returns a 
//	formatter of the corresponding type. If the format string is not supported, an error is returned.
//
// </AiDoc: End of OpenAI comments>
func NewFormatter(format string) (Formatter, error) {
	normalized := strings.ToLower(strings.TrimSpace(format))
	switch normalized {
	case FormatJson:
		return &JSONFormatter{}, nil
	case FormatList:
		return &ListFormatter{}, nil
	case FormatTable:
		return &TableFormatter{}, nil
	default:
		return nil, fmt.Errorf("unsupported format %s", format)
	}
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The function is taking in an argument of any type and attempting to convert it into a slice of any type. It does this by
//	 using reflection to determine the type of the argument and then either adding the argument to the slice if it is a 
//	struct or interface, or looping through the argument if it is an array or slice and adding each item to the slice. If 
//	the argument is a pointer, it will follow the pointer to the underlying value before attempting to convert it. If the 
//	argument is of an unsupported type, an error is returned.
//
// </AiDoc: End of OpenAI comments>
func convertToSlice(obj any) ([]any, error) {
	// We use reflection here because we're building a table and thus need to handle both scalars (structs)
	// and slices/arrays of structs.
	var vv []any
	v := reflect.ValueOf(obj)

	// Follow pointers at the top level
	for v.Kind() == reflect.Ptr {
		if v.IsNil() {
			return nil, fmt.Errorf("value is nil")
		}

		v = v.Elem()
	}

	switch v.Kind() {
	case reflect.Struct, reflect.Interface:
		vv = append(vv, v.Interface())
	case reflect.Array, reflect.Slice:
		for i := 0; i < v.Len(); i++ {
			item := v.Index(i)
			vv = append(vv, item.Interface())
		}
	default:
		return nil, fmt.Errorf("unsupported value kind: %v", v.Kind())
	}

	return vv, nil
}
