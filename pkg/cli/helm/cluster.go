// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package helm

import (
	"context"
	"errors"
	"fmt"
	"strings"

	helmaction "helm.sh/helm/v3/pkg/action"
	"helm.sh/helm/v3/pkg/storage/driver"
	"k8s.io/cli-runtime/pkg/genericclioptions"

	"github.com/project-radius/radius/pkg/cli/output"
	"github.com/project-radius/radius/pkg/version"
)

const (
	ContourChartDefaultVersion = "11.1.1"
)

type CLIClusterOptions struct {
	Radius RadiusOptions
}

type ClusterOptions struct {
	Contour ContourOptions
	Radius  RadiusOptions
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function creates a new ClusterOptions object with default values for the Contour and Radius options. The Contour 
//	chart version is set to the default version, while the Radius chart version is set to the version of the CLI channel 
//	(major.minor) or the latest version if it is an edge build. The tag for the Radius options is set to the channel of the 
//	CLI or "latest" if it is an edge build.
//
// </AiDoc: End of OpenAI comments>
func NewDefaultClusterOptions() ClusterOptions {
	// By default we use the chart version that matches the channel of the CLI (major.minor)
	// If this is an edge build, we'll use the latest available.
	chartVersion := version.ChartVersion()
	if !version.IsEdgeChannel() {
		chartVersion = fmt.Sprintf("~%s", version.ChartVersion())
	}

	tag := version.Channel()
	if version.IsEdgeChannel() {
		tag = "latest"
	}

	return ClusterOptions{
		Contour: ContourOptions{
			ChartVersion: ContourChartDefaultVersion,
		},
		Radius: RadiusOptions{
			ChartVersion: chartVersion,
			Tag:          tag,
			AppCoreTag:   tag,
			UCPTag:       tag,
			DETag:        tag,
		},
	}
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	The previous function is taking in a set of CLI cluster options and using them to populate a set of default cluster 
//	options. If any of the CLI options are provided, they will override the default options.
//
// </AiDoc: End of OpenAI comments>
func PopulateDefaultClusterOptions(cliOptions CLIClusterOptions) ClusterOptions {
	options := NewDefaultClusterOptions()

	// If any of the CLI options are provided, override the default options.
	if cliOptions.Radius.Reinstall {
		options.Radius.Reinstall = cliOptions.Radius.Reinstall
	}

	if cliOptions.Radius.ChartPath != "" {
		options.Radius.ChartPath = cliOptions.Radius.ChartPath
	}

	if cliOptions.Radius.Image != "" {
		options.Radius.Image = cliOptions.Radius.Image
	}

	if cliOptions.Radius.Tag != "" {
		options.Radius.Tag = cliOptions.Radius.Tag
	}

	if cliOptions.Radius.AppCoreImage != "" {
		options.Radius.AppCoreImage = cliOptions.Radius.AppCoreImage
	}

	if cliOptions.Radius.AppCoreTag != "" {
		options.Radius.AppCoreTag = cliOptions.Radius.AppCoreTag
	}

	if cliOptions.Radius.UCPImage != "" {
		options.Radius.UCPImage = cliOptions.Radius.UCPImage
	}

	if cliOptions.Radius.UCPTag != "" {
		options.Radius.UCPTag = cliOptions.Radius.UCPTag
	}

	if cliOptions.Radius.PublicEndpointOverride != "" {
		options.Radius.PublicEndpointOverride = cliOptions.Radius.PublicEndpointOverride
	}

	if cliOptions.Radius.AzureProvider != nil {
		options.Radius.AzureProvider = cliOptions.Radius.AzureProvider
	}
	if cliOptions.Radius.AWSProvider != nil {
		options.Radius.AWSProvider = cliOptions.Radius.AWSProvider
	}
	if len(cliOptions.Radius.Values) > 0 {
		options.Radius.Values = cliOptions.Radius.Values
	}
	return options
}

// Installs radius based on kubecontext in "radius-system" namespace
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	
 
//	This function is installing the Radius version control plane on a given cluster. It will return a boolean value 
//	indicating whether an existing version was found, and an error if one occurred.
//
// </AiDoc: End of OpenAI comments>
func Install(ctx context.Context, clusterOptions ClusterOptions, kubeContext string) (bool, error) {
	step := output.BeginStep("Installing Radius version %s control plane...", version.Version())
	foundExisting, err := InstallOnCluster(ctx, clusterOptions, kubeContext)
	if err != nil {
		return false, err
	}

	output.CompleteStep(step)
	return foundExisting, nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is installing two helm charts, one for Radius and one for Contour, onto a Kubernetes cluster. It is also 
//	checking to see if the charts already exist on the cluster.
//
// </AiDoc: End of OpenAI comments>
func InstallOnCluster(ctx context.Context, options ClusterOptions, kubeContext string) (bool, error) {
	// Do note: the namespace passed in to rad install kubernetes
	// doesn't match the namespace where we deploy radius.
	// The RPs and other resources are all deployed to the
	// 'radius-system' namespace. The namespace passed in will be
	// where pods/services/deployments will be put for rad deploy.
	foundExisting, err := ApplyRadiusHelmChart(options.Radius, kubeContext)
	if err != nil {
		return false, err
	}

	err = ApplyContourHelmChart(options.Contour, kubeContext)
	if err != nil {
		return false, err
	}

	return foundExisting, err
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is uninstalling a system from a cluster. It is using the Helm configuration to uninstall the Contour and 
//	Radius components of the system. It is also using the kubeContext and namespace to configure the Helm configuration.
//
// </AiDoc: End of OpenAI comments>
func UninstallOnCluster(kubeContext string) error {
	var helmOutput strings.Builder

	namespace := RadiusSystemNamespace
	flags := genericclioptions.ConfigFlags{
		Namespace: &namespace,
		Context:   &kubeContext,
	}

	helmConf, err := HelmConfig(&helmOutput, &flags)
	if err != nil {
		return fmt.Errorf("failed to get helm config, err: %w, helm output: %s", err, helmOutput.String())
	}

	err = RunContourHelmUninstall(helmConf)
	if err != nil {
		return err
	}

	err = RunRadiusHelmUninstall(helmConf)
	if err != nil {
		return err
	}

	return nil
}

// Checks whethere radius installed on the cluster based of kubeContext
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is checking if the Radius system has been installed in a given Kubernetes context. It does this by using 
//	the Helm configuration to check the release history for the Radius system. If the release is found, it returns true, 
//	otherwise it returns false.
//
// </AiDoc: End of OpenAI comments>
func CheckRadiusInstall(kubeContext string) (bool, error) {
	var helmOutput strings.Builder

	namespace := RadiusSystemNamespace
	flags := genericclioptions.ConfigFlags{
		Namespace: &namespace,
		Context:   &kubeContext,
	}

	helmConf, err := HelmConfig(&helmOutput, &flags)
	if err != nil {
		return false, fmt.Errorf("failed to get helm config, err: %w, helm output: %s", err, helmOutput.String())
	}
	histClient := helmaction.NewHistory(helmConf)
	histClient.Max = 1 // Only need to check if at least 1 exists

	_, err = histClient.Run(radiusReleaseName)
	if errors.Is(err, driver.ErrReleaseNotFound) {
		return false, nil
	} else if err != nil {
		return false, err
	}

	return true, nil
}

//go:generate mockgen -destination=./mock_cluster.go -package=helm -self_package github.com/project-radius/radius/pkg/cli/helm github.com/project-radius/radius/pkg/cli/helm Interface
type Interface interface {
	CheckRadiusInstall(kubeContext string) (bool, error)
	InstallRadius(ctx context.Context, clusterOptions ClusterOptions, kubeContext string) (bool, error)
}

type Impl struct {
}

// Checks if radius is installed based on kubeContext
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is checking if the Radius software is installed on a Kubernetes cluster, specified by the kubeContext 
//	parameter. It returns a boolean value indicating whether the software is installed or not, and an error if one occurs.
//
// </AiDoc: End of OpenAI comments>
func (i *Impl) CheckRadiusInstall(kubeContext string) (bool, error) {
	return CheckRadiusInstall(kubeContext)
}

// Installs radius on a cluster based on kubeContext
//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is used to install a RADIUS server on a Kubernetes cluster. It takes a context, cluster options, and a 
//	kube context as parameters and returns a boolean and an error.
//
// </AiDoc: End of OpenAI comments>
func (i *Impl) InstallRadius(ctx context.Context, clusterOptions ClusterOptions, kubeContext string) (bool, error) {
	return Install(ctx, clusterOptions, kubeContext)
}
