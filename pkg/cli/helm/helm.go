// ------------------------------------------------------------
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// ------------------------------------------------------------

package helm

import (
	_ "embed"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	helm "helm.sh/helm/v3/pkg/action"
	"helm.sh/helm/v3/pkg/chart"
	"helm.sh/helm/v3/pkg/chart/loader"
	"helm.sh/helm/v3/pkg/cli"
	"k8s.io/cli-runtime/pkg/genericclioptions"
)

const (
	helmDriverSecret = "secret"
	installTimeout   = time.Duration(600) * time.Second
	uninstallTimeout = time.Duration(300) * time.Second
	retryTimeout     = time.Duration(10) * time.Second
	retries          = 5
)

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is initializing a helm configuration object with the given flags, namespace, and driver. It is also 
//	writing any output from the initialization process to a strings builder.
//
// </AiDoc: End of OpenAI comments>
func HelmConfig(builder *strings.Builder, flags *genericclioptions.ConfigFlags) (*helm.Configuration, error) {
	hc := helm.Configuration{}
	// helmDriver is "secret" to make the backend storage driver
	// use kubernetes secrets.
	err := hc.Init(flags, *flags.Namespace, helmDriverSecret, func(format string, v ...any) {
		builder.WriteString(fmt.Sprintf(format, v...))
		builder.WriteRune('\n')
	})
	return &hc, err
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function creates a temporary directory with a name based on the value of the variable "radiusReleaseName". It 
//	returns the path of the directory and any errors that occurred while creating it.
//
// </AiDoc: End of OpenAI comments>
func createTempDir() (string, error) {
	dir, err := os.MkdirTemp("", radiusReleaseName)
	if err != nil {
		return "", fmt.Errorf("error creating temp dir: %s", err)
	}
	return dir, nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is searching for a file in a given directory. It reads the directory and checks if there are any files 
//	present. If there are no files, it returns an error. If there is more than one file, it returns an error. If there is 
//	only one file, it returns the path to that file.
//
// </AiDoc: End of OpenAI comments>
func locateChartFile(dirPath string) (string, error) {
	files, err := os.ReadDir(dirPath)
	if err != nil {
		return "", err
	}
	if len(files) == 0 {
		return "", errors.New("radius helm chart not found")
	}

	if len(files) > 1 {
		return "", errors.New("unexpected files found when downloading helm chart")
	}

	return filepath.Join(dirPath, files[0].Name()), nil
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	This function is used to download a Helm chart from a container registry. It takes in a version, configuration, 
//	repository URL, and release name as parameters. It creates a temporary directory and downloads the chart to that 
//	directory. It then locates the chart file in the directory and loads it.
//
// </AiDoc: End of OpenAI comments>
func helmChartFromContainerRegistry(version string, config *helm.Configuration, repoUrl string, releaseName string) (*chart.Chart, error) {
	pull := helm.NewPull()
	pull.RepoURL = repoUrl
	pull.Settings = &cli.EnvSettings{}
	pullopt := helm.WithConfig(config)
	pullopt(pull)

	// If version isn't set, it will use the latest version.
	if version != "" {
		pull.Version = version
	} else {
		// Support prerelease builds when the version is unspecified. We always specify
		// the version for a release build.
		pull.Devel = true
	}

	dir, err := createTempDir()
	if err != nil {
		return nil, err
	}
	defer os.RemoveAll(dir)

	pull.DestDir = dir

	_, err = pull.Run(releaseName)
	if err != nil {
		return nil, err
	}

	chartPath, err := locateChartFile(dir)
	if err != nil {
		return nil, err
	}
	return loader.Load(chartPath)
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	
 
//	This function attempts to install a Helm chart a certain number of times, with a delay between each attempt. If the 
//	installation is successful, the function returns without error. If the installation fails, the function will wait a 
//	certain amount of time before attempting to install the chart again. If the installation fails after the specified 
//	number of attempts, the function will return an error.
//
// </AiDoc: End of OpenAI comments>
func runInstall(installClient *helm.Install, helmChart *chart.Chart) error {
	var err error
	for i := 0; i < retries; i++ {
		_, err = installClient.Run(helmChart, helmChart.Values)
		if err == nil {
			return nil
		}
		time.Sleep(retryTimeout)
	}
	return err
}

//
// <AiDoc: The following comments were generated by OpenAI explaining the code as it existed at the time of this commit>
//	
 
//	This function attempts to upgrade a release with a given name using a Helm chart and its associated values. It will 
//	attempt to do this up to a certain number of times, with a certain amount of time in between each attempt. If it is 
//	successful, it will return without an error. Otherwise, it will return an error.
//
// </AiDoc: End of OpenAI comments>
func runUpgrade(upgradeClient *helm.Upgrade, releaseName string, helmChart *chart.Chart) error {
	var err error
	for i := 0; i < retries; i++ {
		_, err = upgradeClient.Run(releaseName, helmChart, helmChart.Values)
		if err == nil {
			return nil
		}
		time.Sleep(retryTimeout)
	}
	return err
}
