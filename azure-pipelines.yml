# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

trigger: none

pr: [ main, features/*]

variables:
- name: RADIUS_CHART_LOCATION
  value: deploy/Chart/
- name: RADIUS_CONTAINER_LOG_BASE
  value: dist/container_logs
- name: RADIUS_DEPLOYMENT_TEMPLATE_LOCATION
  value: deploy/rp-full.json
- name: DOCKER_REGISTRY
  value: radiusdev.azurecr.io
- name: K8S_FUNCTIONALTEST_TIMEOUT
  value: 20m
- name: AZURE_FUNCTIONALTEST_TIMEOUT
  value: 20m
- name: REL_CHANNEL
  value: edge
- name: REL_VERSION
  value: pr-ado-$(Build.BuildNumber)
- name: INTEGRATION_TEST_LOGANALYTICS_WORKSPACEID
  value: "/subscriptions/85716382-7362-45c3-ae03-2126e459a123/resourcegroups/radiusrplogs/providers/microsoft.operationalinsights/workspaces/rplogs"
- name: INTEGRATION_TEST_SUBSCRIPTION_ID
  value: "85716382-7362-45c3-ae03-2126e459a123"
- name: DisableDockerDetector
  value: 'true'
stages:
- stage: ImageBuild
  jobs:
  - job: PublishContainerImage
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: GoTool@0
      inputs:
        version: '1.18'
    - script: |
        echo "##vso[task.setvariable variable=goBuildCache;isOutput=true]$(go env GOCACHE)"
      displayName: Set Go cache paths
      name: gocachepath
    - task: Cache@2
      inputs:
        key: 'go | "$(Agent.OS)" | go.mod'
        restoreKeys: | 
          go | "$(Agent.OS)"
        path: $(gocachepath.goBuildCache)
      displayName: Cache GO packages
    - task: Docker@2
      displayName: Login to ACR
      inputs:
        command: login
        containerRegistry: radiusdev-acr  # Service connection of radiusdev ACR: https://dev.azure.com/azure-octo/Incubations/_settings/adminservices?resourceId=09d4666f-2486-4dbf-a599-f95622e1ad29
    - script: |
        export DOCKER_TAG_VERSION=$REL_VERSION
        make docker-build && make docker-push
      displayName: publish container

- stage: FunctionalTest
  # dependsOn: ImageBuild
  jobs:
  - job: ApplicationsCoreRP
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        export PATH=$(Build.SourcesDirectory)/dist:$PATH
        export TEST_TIMEOUT=${{ variables.K8S_FUNCTIONALTEST_TIMEOUT }}
        export RADIUS_CONTAINER_LOG_PATH=$(Build.SourcesDirectory)/${{ variables.RADIUS_CONTAINER_LOG_BASE }}/corerptest
        echo "loc 155 $(MSSQL_RESOURCE_ID)" > test.txt
        echo "loc 156 $MSSQL_RESOURCE_ID" >> test.txt
        export REDIS_RESOURCE_ID=$REDIS_RESOURCE_ID
        echo "loc 158 $REDIS_RESOURCE_ID" >> test.txt
        export REDIS_RESOURCE_ID=$(REDIS_RESOURCE_ID)
        echo "loc 80 $REDIS_RESOURCE_ID" >> test.txt
        cat test.txt
        make test-functional-corerp
      env:
        MONGODB_RESOURCE_ID: $(MONGODB_RESOURCE_ID)
        TABLESTORAGE_RESOURCE_ID: $(TABLESTORAGE_RESOURCE_ID)
        MSSQL_RESOURCE_ID: $(MSSQL_RESOURCE_ID)
        SERVICEBUS_RESOURCE_ID: $(SERVICEBUS_RESOURCE_ID)
        REDIS_RESOURCE_ID: $(REDIS_RESOURCE_ID)
        MSSQL_USERNAME: $(MSSQL_USERNAME)
        MSSQL_PASSWORD: $(MSSQL_PASSWORD)
      displayName: run functional corerp tests
    - script: |
        export PATH=$(Build.SourcesDirectory)/dist:$PATH
        export TEST_TIMEOUT=${{ variables.K8S_FUNCTIONALTEST_TIMEOUT }}
        export RADIUS_CONTAINER_LOG_PATH=$(Build.SourcesDirectory)/${{ variables.RADIUS_CONTAINER_LOG_BASE }}/ucptest
        make test-functional-ucp
      displayName: run functional ucp tests
    - publish: $(Build.SourcesDirectory)/dist/container_logs
      displayName: Publish container logs
      artifact: FunctionalTest.ApplicationsCoreRPLogs.$(Build.BuildNumber)
      condition: always()
    - script: |
        az group delete \
          --subscription ${{ variables.INTEGRATION_TEST_SUBSCRIPTION_ID }} \
          --name $INTEGRATION_TEST_RESOURCE_GROUP_NAME \
          --yes \
          --verbose \
          --no-wait
      displayName: Delete environment resource groups
      condition: always()
      continueOnError: 'true'
